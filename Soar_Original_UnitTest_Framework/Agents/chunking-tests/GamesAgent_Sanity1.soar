srand 23

learn --only
smem --set learning on
smem --set initial-variable-id 999000
epmem --off

decide indifferent-selection -x

max-chunks 1000
max-elaborations 500
max-goal-depth 100
watch 1

multi-attributes object 20
multi-attributes preposition 10
multi-attributes property 9
multi-attributes relation 8

sp {selection*elaborate*name*selection
    :default
    (state <s> ^problemspace games ^choices multiple)
   -{ (<s> ^operator <o> +)
      (<o> ^name learn-action-result)}
    -->
    (<s> ^name selection +)
}

sp {selection*elaborate*evaluation*value
    :default
    (state <s> ^evaluation <e>)
    (<e> ^{ << numeric-value symbolic-value >> <a*1> } <v*1>)
    -->
    (<e> ^value true +)
}

sp {selection*elaborate*evaluation*desired
    :default
    (state <s> ^evaluation <e> ^superstate <s*1>)
    (<s*1> ^desired <d>)
    -->
    (<e> ^desired <d> +)
}

sp {selection*select*partial-failure-evaluation-becomes-worst-preference
    :default
    (state <s> ^name selection ^evaluation <e1> ^superstate <ss>)
    (<e1> ^symbolic-value partial-failure ^desired <e> ^superoperator <o1>)
    (<ss> ^desired <e>)
    -->
    (<ss> ^operator <o1> <)
}

sp {selection*elaborate*state*all-objects-evaluated
    :default
    (state <s> ^name selection ^operator <o> +)
   -{ (<o> ^name evaluate-operator ^evaluation <e*1>)
      (<e*1> ^value true)}
    -->
    (<s> ^not-all-operators-evaluated true +)
}

sp {selection*elaborate*state*found-value-true
    :default
    (state <s> ^name selection ^evaluation <e>)
    (<e> ^{ << numeric-value symbolic-value >> <a*1> } { <> novalue <v*1> })
    -->
    (<s> ^found-value true +)
}

sp {selection*select*evaluate-operator*indifferent
    :default
    (state <s> ^name selection -^operator-selection not-indifferent
          ^operator <o> +)
    (<o> ^name evaluate-operator)
    -->
    (<s> ^operator <o> =)
}

sp {selection*elaborate*evaluate-operator*evaluation
    :default
    (state <s> ^name selection ^operator <o> ^evaluation <e>)
    (<o> ^name evaluate-operator ^superoperator <ob>)
    (<e> ^superoperator <ob>)
    -->
    (<o> ^evaluation <e> +)
}

sp {selection*elaborate*evaluate-operator*superproblem-space
    :default
    (state <s> ^name selection ^operator <o> ^superstate <s*1>)
    (<o> ^name evaluate-operator)
    (<s*1> ^problem-space <p2>)
    -->
    (<o> ^superproblem-space <p2> +)
}

sp {selection*elaborate*evaluate-operator*superstate
    :default
    (state <s> ^name selection ^operator <o> ^superstate <ss>)
    (<o> ^name evaluate-operator)
    -->
    (<o> ^superstate <ss> +)
}

sp {evaluate-operator*elaborate*state*name
    :default
    (state <s> ^impasse no-change ^attribute operator ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^superstate <s*2>)
    (<s*2> ^name { <> evaluate-operator <name> })
    -->
    (<s> ^name <name> +)
}

sp {evaluate-operator*elaborate*state*duplicate-of
    :default
    (state <s> ^default-state-copy yes ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^name evaluate-operator ^superstate <sss>)
    -->
    (<s> ^duplicate-of <sss> +)
}

sp {evaluate-operator*elaborate*state*look-ahead-operator*copy
    :default
    (state <s> ^default-operator-copy yes ^superstate <s*1>
          ^problem-space <p*1>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^superproblem-space <s*2> ^superoperator <o>)
    (<s*2> ^name <n>)
    (<p*1> ^name <n>)
    -->
    (<s> ^look-ahead-operator <copy-o> + ^untried-tied-operator <copy-o> +)
    (<copy-o> ^duplicate-of <o> +)
}

sp {evaluate-operator*elaborate*evaluation*from-subgoal*duplicate-desired
    :default
    (state <s> ^superstate <ss>
          ^{ << required-success success partial-success indifferent partial-failure failure prohibit-failure >> <svalue> } <deb>)
    (<ss> ^operator <so> ^evaluation <e>)
    (<so> ^name evaluate-operator ^evaluation <e> ^evaluation <e*1>)
    (<e*1> ^desired <eb>)
    (<deb> ^duplicate-of <eb>)
    -->
    (<e> ^symbolic-value <svalue> +)
}

sp {evaluate-operator*elaborate*default-for-default-state-copy-is-yes
    :default
    (state <s> ^problem-space <p> ^superstate <s*1>)
    (<p> -^default-state-copy no)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^default-state-copy yes +)
}

sp {evaluate-operator*elaborate*state*create-duplicates-table
    :default
    (state <s> ^default-state-copy yes ^impasse no-change ^attribute operator
          ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^duplicates <d> +)
}

sp {evaluate-operator*elaborate*state*eval*desired
    :default
    (state <s> ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^default-desired-copy yes ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <d>)
    -->
    (<s> ^desired <d-copy> +)
    (<d-copy> ^duplicate-of <d> +)
}

sp {duplicate-desired*copy-old-value
    :default
    (state <s> ^duplicates <d> ^desired <o-copy> ^superstate <s*1>
          ^problem-space <p>)
    (<o-copy> ^duplicate-of <o>)
    (<s*1> ^operator <so>)
    (<so> ^name evaluate-operator ^evaluation <e*1>)
    (<e*1> ^desired <o>)
    (<o> ^{ <> duplicate-of <att> } <val>)
    (<p> -^dont-copy <att>)
    (<d> -^<val> <v*1>)
    -->
    (<o-copy> ^<att> <val> +)
}

sp {evaluate-operator*elaborate*operator*default-operator-copy-is-yes
    :default
    (state <s> ^problem-space <ps> ^superstate <s*1>)
    (<ps> -^default-operator-copy no)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name evaluate-operator)
    -->
    (<s> ^default-operator-copy yes +)
}

sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator
    :default
    (state <s> ^problem-space <p> ^duplicates <d>
          ^look-ahead-operator <o-copy>)
    (<p> -^no-local-negations <nln> -^dont-copy <att>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^{ <> duplicate-of <> desired <att> } <val>)
    (<d> -^<val> <v*1>)
    -->
    (<o-copy> ^<att> <val> +)
}

sp {evaluate-operator*propose*look-ahead
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>)
    -->
    (<s> ^operator <o> +)
}

sp {evaluate-operator*propose*look-ahead*reject-all-others
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>
          ^operator { <> <o> <o1> } +)
    -->
    (<s> ^operator <o1> -)
}

sp {evaluate-operator*elaborate*state*tried-tied-operator
    :default
    (state <s> ^look-ahead-operator <o> ^operator <o>)
    (<o> -^action-type primitive -^action-type composite)
    -->
    (<s> ^tried-tied-operator <o> +)
}

sp {evaluate-operator*elaborate*state*remove*untried-tied-operator2
    :default
    (state <s> ^untried-tied-operator <o> ^look-ahead-operator <o>
          ^operator <o>)
    (<o> -^action-type <a*1>)
    -->
    (<s> ^untried-tied-operator <o> -)
}

sp {top-ps*propose*wait
    "Propose wait if there is a state no-change."
    :default
    (state <s> ^quiescence t ^choices none ^attribute state)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name wait +)
}

sp {default*select*indifferent-and-worst*tied
    "Indifferent an object if it leads to a tie that can not be resolved."
    :default
    (state <s3> ^quiescence t ^choices none ^attribute state ^superstate <s2>)
    (<s2> ^quiescence t ^superstate <s1> ^item <o>)
    (<s1> -^ntype heuristic ^operator <o> +)
    -->
    (<s1> ^operator <o> = ^operator <o> <)
}

sp {elaborate*state*top-state
    :default
    (state <s> ^superstate <s*1> -^name evaluate-operator)
    (<s*1> ^top-state <ts>)
    -->
    (<s> ^top-state <ts> +)
}

sp {selection*elaborate*state*all-objects-total-estimated-cost
    :default
    (state <s> ^name selection ^operator <o> +)
   -{ (<o> ^evaluation <e*1>)
      (<e*1> ^total-estimated-cost <t*1>)}
    (<o> ^name evaluate-operator)
    -->
    (<s> ^not-all-operators-total-estimated-cost true +)
}

sp {selection*apply*state*evaluation
    :default
    (state <s> ^name selection ^operator <o>)
    (<o> ^name evaluate-operator ^superoperator <ob>)
   -{ (<s> ^evaluation <e*1>)
      (<e*1> ^superoperator <ob>)}
    -->
    (<s> ^evaluation <e> +)
    (<e> ^superoperator <ob> +)
}

sp {selection*propose*evaluate-operator
    :default
    (state <s> ^name selection ^item <i>)
   -{ (state <s> ^evaluation <e>)
      (<e> ^superoperator <i> ^value true)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name evaluate-operator + ^superoperator <i> +)
}

sp {top-state*elaborate*agent-params
    (state <s> ^top-state <s>)
    -->
    (<s> ^agent-params <params> +)
}

sp {top-state*elaborate*agent-params*domain
    (state <s> ^superstate nil ^agent-params <params>)
    -->
    (<params> ^domain arm +)
}

sp {top-state*elaborate*agent-params*task
    (state <s> ^superstate nil ^agent-params <params>)
    -->
    (<params> ^use-default-values true + ^use-object-variablization true +
           ^use-intra-task-transfer true + ^action-search-depth 4 +
           ^arm-simulation-level pretend +)
}

sp {top-state*elaborate*agent-params*perception
    (state <s> ^top-state <s> ^agent-params <params>)
    -->
    (<params> ^stability-check-duration 0 + ^pos-diff-threshold 0.020000 +
           ^vol-low-diff-threshold 0.800000 +
           ^vol-high-diff-threshold 1.200000 + ^max-stability-checks 5 +
           ^occlusion-threshold 0.150000 + ^occlusion-check-period 3 +
           ^clear-view-distance 0.010000 + ^stale-match-distance 0.100000 +
           ^maximum-stale-distance 0.100000 + ^contained-threshold 0.330000 +
           ^contained-by-threshold 0.500000 + ^update-object-period 3 +
           ^recheck-growth-delay 5 + ^aggressive-match-distance 0.050000 +
           ^vol-low-candidate-match 0.600000 +
           ^vol-high-candidate-match 1.400000 +)
}

sp {top-state*elaborate*agent-params*debug
    (state <s> ^top-state <s> ^agent-params <params>)
    -->
    (<params> ^debug-mode off + ^debug-perception true +
           ^debug-op-ties false + ^debug-arm true + ^enable-interrupts false +)
}

sp {top-state*propose*init-agent
    (<s> -^name rosie)
    (state <s> ^top-state <s>)
    -->
    (<s> ^operator <o> + ^operator <o> !)
    (<o> ^name init-agent +)
}

sp {top-state*propose*interaction*status-change
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^status <s*1>)
    (<s*1> ^<any> <status>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interaction + ^type status-change + ^status-info <status> +
           ^status-type <any> +)
}

sp {top-state*propose*interaction*interaction-change
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^changes <c*1>)
    (<c*1> ^<type> <change>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interaction + ^type interaction-change +
           ^change-info <change> + ^change-type <type> +)
}

sp {top-state*propose*satisfy-purpose
    (<s> -^parser-testing true ^interaction <i*1>)
    (state <s> ^top-state <s>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose { <> none <p> })
    (<p> -^type action-command -^type action -^type goal-description
          -^category goal)
    -->
    (<s> ^operator <o> +)
    (<o> ^name satisfy-purpose + ^purpose <p> +)
}

sp {top-state*better-preferences*interaction
    (state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^name interaction)
    (<o2>
          ^name { << comprehension satisfy-purpose action-learning execute-action attend-to-scene-change wait >> <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {apply*interaction*update-dialog-object-list-saved
    (state <s> ^operator <o*1> ^dialog-object-list-saved <dols>
          ^dialog-object-list { <> <dols> <dol> })
    (<o*1> ^name interaction)
    -->
    (<s> ^dialog-object-list-saved <dols> - ^dialog-object-list-saved <dol> +)
}

sp {interaction-stack*elaborate*segments*all*segments
    (state <s> ^top-state <s> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segments <segs>)
    (<segs> ^segment <s*2>)
    (<s*2> ^prev <seg>)
    -->
    (<segs> ^segment <seg> +)
}

sp {all*elaborate*name
    (state <s> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^name <name>)
    -->
    (<s> ^name <name> +)
}

sp {top-state*elaborate*top-state
    (state <s> ^superstate nil)
    -->
    (<s> ^top-state <s> +)
}

sp {all*elaborate*io
    (state <s> ^superstate <s*1> -^name selection -^name learn-param
          -^name setup-search -^name action-policy)
   -{ (<s> ^problem-space <p*1>)
      (<p*1> ^state <s*2>)
      (<s*2> ^dont-copy io)}
    (<s*1> ^io <io>)
    -->
    (<s> ^io <io> +)
}

sp {top-state*elaborate*problem-space
    (state <s> ^superstate nil)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^perception <perc> +)
    (<perc> ^attend-to-all-perception yes +)
}

sp {top-state*elaborate*agent-info
    (state <s> ^superstate nil)
    -->
    (<s> ^agent-info <info> +)
}

sp {top-state*perception-monitor*predicate-monitor*elaborate*default*predicates
    (state <s> ^superstate nil ^perception-monitor <p*1>)
    (<p*1> ^predicate-monitor <mon>)
    -->
    
}

sp {new*anystate*propose*smem-store*create-cue
    (state <s> ^store-concept <lti> -^stored <lti>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name smem-store +)
}

sp {new*anystate*apply*smem-store*create-cue
    (state <s> ^operator <op> ^store-concept <lti> ^smem <s*1>)
    (<op> ^name smem-store)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^store <lti> +)
}

sp {new*anystate*apply*smem-store*create-cue*clear
    (state <s> ^operator <op> ^smem <s*1>)
    (<op> ^name smem-store)
    (<s*1> ^command <cmd>)
    (<cmd> ^{ << retrieve query >> <command> } <olti>)
    -->
    (<cmd> ^<command> <olti> -)
}

sp {new*anystate*apply*smem-store*copy-result*copy
    (state <s> ^operator <o> ^store-concept <lti> ^smem <s*1>)
    (<o> ^name smem-store)
    (<s*1> ^result <r*1>)
    (<r*1> ^{ << success failure >> <a*1> } <lti>)
    -->
    (<s> ^stored <lti> +)
}

sp {top-state*apply*init-agent*create*name
    (state <s> ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^name rosie +)
}

sp {top-state*apply*init-agent*create*interaction-stack
    (state <s> ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^interaction <int> +)
    (<int> ^stack <stack> + ^status <status> + ^changes <changes> +)
    (<stack> ^segment <seg> + ^segments <s*1> +)
    (<s*1> ^segment <seg> +)
    (<seg> ^id 10 + ^purpose none + ^counter 1 +)
}

sp {state-no-change*propose*wait
    (state <s> ^choices none ^attribute state)
   -{ (<s> ^operator <o*1>)
      (<o*1> ^name wait)}
    -->
    (<s> ^operator <o> +)
    (<o> ^name wait +)
}

sp {anystate*prefer*others*over*wait
    (state <s> ^operator <o2> + ^operator <o1> +)
    (<o2> ^name wait)
    (<o1> ^name { <> wait <n*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*new-message
    (state <s> ^top-state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^status-type new-message ^name interaction)
    (<o2> ^name interaction
          ^<type> { << outgoing-message performed clear-interaction-stack terminate-segment modify-segment-info new-segment-info >> <t*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*outgoing-message
    (state <s> ^top-state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^change-type outgoing-message ^name interaction)
    (<o2> ^name interaction
          ^<type> { << performed clear-interaction-stack terminate-segment modify-segment-info new-segment-info >> <t*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*performed
    (state <s> ^top-state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^status-type performed ^name interaction)
    (<o2> ^name interaction
          ^<type> { << clear-interaction-stack modify-segment-info new-segment-info >> <t*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*performed*process-sentence
    (state <s> ^top-state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^status-type performed ^name interaction ^status-info <s*1>)
   -{ (<o2> ^status-info <s*2>)
      (<s*2> ^dialog-event <d*2>)
      (<d*2> ^type process-sentence)}
    (<o2> ^status-type performed ^name interaction)
    (<s*1> ^dialog-event <d*1>)
    (<d*1> ^type process-sentence)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*better-preferences*clear-interaction-stack
    (state <s> ^top-state <s> ^operator <o1> + ^operator <o2> +)
    (<o1> ^change-type terminate-segment ^name interaction)
    (<o2> ^name interaction
          ^<type> { << new-segment-info modify-segment-info performed >> <t*1> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {interaction*propose*interpret-message
    (state <s> ^status-type new-message ^name interaction ^status-info <msg>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name interpret-message + ^message <msg> +)
}

sp {interaction*propose*interpret-failure
    (state <s> ^status-type failure ^name interaction ^status-info <failure>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-failure + ^failure <failure> +)
}

sp {interaction*propose*send-message
    (state <s> ^change-type outgoing-message ^name interaction
          ^change-info <msg>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name send-message + ^message <msg> +)
}

sp {interaction*propose*push-segment
    (state <s> ^change-type new-segment-info ^name interaction
          ^change-info <info>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name push-segment + ^new-segment-info <info> +)
}

sp {interaction*propose*pop-segment
    (state <s> ^change-type terminate-segment ^name interaction
          ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name pop-segment + ^segment <seg> +)
}

sp {interaction*propose*performed-event
    (state <s> ^status-type performed ^name interaction ^status-info <event>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name performed-event + ^event <event> +)
}

sp {interaction*elaborate*status*info
    (state <s> ^name interaction ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^status-info <info> ^status-type <type>)
    -->
    (<s> ^status-info <info> + ^status-type <type> +)
}

sp {interaction*elaborate*change*info
    (state <s> ^name interaction ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^change-type <type> ^change-info <change>)
    -->
    (<s> ^change-info <change> + ^change-type <type> +)
}

sp {interaction*elaborate*current-segment
    (state <s> ^name interaction ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^current-segment <seg> +)
}

sp {interaction*propose*complete-interaction
    (state <s> ^name interaction)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interaction +)
}

sp {push-segment*elaborate*new-segment-info
    (state <s> ^name push-segment ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^new-segment-info <info>)
    (<info> ^purpose <p>)
    -->
    (<s> ^new-segment-info <info> +)
}

sp {push-segment*propose*complete-push-segment
    (state <s> ^name push-segment)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-push-segment +)
}

sp {push-segment*apply*complete-push-segment*push-segment
    (state <s> ^name push-segment ^operator <o*1> ^segment <seg>
          ^top-state <t*1> ^epmem <e*1>)
    (<o*1> ^name complete-push-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <stack>)
    (<stack> ^segment <prev-seg>)
    (<e*1> ^present-id <epmem-id>)
    -->
    (<stack> ^segment <prev-seg> - ^segment <seg> +)
    (<seg> ^epmem-id <epmem-id> +)
    (<prev-seg> ^prev <seg> +)
}

sp {push-segment*apply*complete-push-segment*remove*new-segment-info
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <info>
          ^top-state <t*1>)
    (<o*1> ^name complete-push-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^new-segment-info <info>)
    -->
    (<c> ^new-segment-info <info> -)
}

sp {push-segment*propose*create-segment
    (state <s> ^name push-segment ^new-segment-info <n*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^purpose <p*2>)}
    (<n*1> ^purpose <p*1>)
    (<p*1> ^type <t*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-segment +)
}

sp {push-segment*apply*create-segment*create*root
    (state <s> ^name push-segment ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name create-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <prev-seg>)
    (<prev-seg> ^counter <count> ^id <id>)
    -->
    (<s> ^segment <seg> +)
    (<seg> ^id (+ (* <id> 100) <count>) + ^counter 1 + ^next <prev-seg> +
           ^info <info> +)
}

sp {push-segment*apply*create-segment*purpose
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>
          ^segment <seg>)
    (<o*1> ^name create-segment)
    (<n*1> ^purpose <p>)
    -->
    (<seg> ^purpose <p> +)
}

sp {push-segment*apply*create-segment*purpose*parameters
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>)
    (<o*1> ^name create-segment)
    (<n*1> ^purpose <p>)
    (<p> -^parameters <p*1>)
    -->
    (<p> ^parameters <params> +)
}

sp {push-segment*apply*create-segment*originator
    (state <s> ^name push-segment ^operator <o*1> ^new-segment-info <n*1>
          ^segment <seg>)
    (<o*1> ^name create-segment)
    (<n*1> ^originator <orig>)
    -->
    (<seg> ^originator <orig> +)
}

sp {push-segment*apply*create-segment*copy*context
    (state <s> ^name push-segment ^operator <o*1> ^segment <seg>)
    (<o*1> ^name create-segment)
    (<seg> ^next <n*1>)
    (<n*1> ^purpose <p>)
    -->
    (<seg> ^context <p> +)
}

sp {interaction*apply*pop-segment
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name pop-segment ^segment <top-seg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <stack>)
    (<stack> ^segment <top-seg>)
    (<top-seg> ^next <next-seg>)
    -->
    (<stack> ^segment <top-seg> - ^segment <next-seg> +)
    (<next-seg> ^prev <top-seg> -)
}

sp {interaction*apply*pop-segment*remove*terminate-segment
    (state <s> ^change-type terminate-segment ^name interaction
          ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name pop-segment)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^terminate-segment <any>)
    -->
    (<c> ^terminate-segment <any> -)
}

sp {interpret-message*elaborate*instructor-message
    (state <s> ^name interpret-message ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    (<msg> -^message-type yes)
    -->
    (<s> ^instructor-message <msg> +)
}

sp {interpret-message*elaborate*instructor-message*yes-message
    (state <s> ^name interpret-message ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    (<msg> ^message-type yes)
    -->
    (<s> ^instructor-message <msg> +)
}

sp {interpret-message*apply*any-op*mark*message*interpreted
    (state <s> ^name interpret-message ^mark-interpreted <msg> ^operator <o>)
    -->
    (<msg> ^interpreted true +)
}

sp {interpret-message*elaborate*message-context
    (state <s> ^name interpret-message ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^context <context>)
    -->
    (<s> ^message-context <context> +)
}

sp {interpret-message*elaborate*current-purpose
    (state <s> ^name interpret-message ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p>)
    -->
    (<s> ^current-purpose <p> +)
}

sp {interpret-message*propose*complete-interpret-message
    (state <s> ^name interpret-message)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interpret-message +)
}

sp {interpret-message*apply*complete-interpret-message*delete*nl-il
    (state <s> ^name interpret-message ^operator <o*1>
          ^instructor-message <msg> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^new-message <msg>)
    -->
    (<status> ^new-message <msg> -)
}

sp {interpret-message*apply*complete-interpret-message*copy*new-segment-info
    (state <s> ^name interpret-message ^operator <o*1>
          ^new-segment-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^new-segment-info <info> +)
}

sp {interpret-message*apply*complete-interpret-message*copy*outgoing-message
    (state <s> ^name interpret-message ^operator <o*1> ^outgoing-message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^outgoing-message <msg> +)
}

sp {interpret-message*propose*interpret-object-description
    (state <s> ^name interpret-message ^instructor-message <msg>)
   -{ (<msg> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)}
    (<msg> -^interpreted true ^message-type object-description)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-object-description + ^message <msg> +)
}

sp {interpret-message*elaborate*interpret-object-description*goal
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^arg1 <obj>)
    (<obj> ^handle goal)
    -->
    (<o> ^goal <obj> +)
}

sp {interpret-message*elaborate*interpret-object-description*predicate
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^predicate <pred>)
    -->
    (<o> ^predicate <pred> +)
}

sp {interpret-message*elaborate*interpret-object-description*relation
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^{ << relation predicate >> <a*1> } <rel>)
   -{ (<rel> ^property <p*1>)
      (<p*1> ^handle { << color shape size >> <h*1> })}
    -->
    (<o> ^relation <rel> +)
}

sp {interpret-message*elaborate*interpret-object-description*subclause
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^message <m*1>)
    (<m*1> ^subclause <sub>)
    -->
    (<o> ^subclause <sub> +)
}

sp {interpret-message*elaborate*interpret-object-description*purpose*learn-goal-definition
    (state <s> ^name interpret-message ^operator <o> +)
    (<o> ^name interpret-object-description ^subclause <sub> ^goal <goal>)
    -->
    (<o> ^purpose learn-goal-definition +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-puzzle-name
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-object-description ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^2 <q>)
    (<q> ^handle name1 ^2 <v*1>)
    (<v*1> ^{ << game handle >> <a*2> } puzzle1)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-puzzle-name + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-object-description*create*segment*learn-goal-predicate*setup
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>
          ^top-state <t*2>)
    (<o> ^purpose learn-goal-definition ^name interpret-object-description
          ^message <msg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <changes>)
    (<t*2> ^dialog-context <dc>)
    (<dc> ^type game-learning ^needs-goal-setup <n*1> ^learn-link <l*1>)
    -->
    (<dc> ^parsed-goal <msg> +)
    (<msg> ^interpreted true +)
    (<changes> ^outgoing-message <msg2> +)
    (<msg2> ^type simple-message + ^message-type setup-goal +)
}

sp {interpret-message*propose*interpret-done-teaching
    (state <s> ^name interpret-message ^instructor-message <msg>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learn-link <l*1>)}
   -{ (<msg> ^interaction-status <i*1>)
      (<i*1> ^failure <f*1>)}
    (<msg> -^interpreted true ^message-type finished)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-done-teaching + ^message <msg> +)
}

sp {interpret-message*apply*interpret-done-teaching*create*segment*finished-game-teaching
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^name interpret-done-teaching ^message <msg>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type finished-game-teaching + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*propose*interpret-conditional-predicate
    (state <s> ^name interpret-message ^instructor-message <msg>
          ^top-state <t*1>)
    (<msg> -^interpreted true ^message-type conditional)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-conditional-predicate + ^message <msg> +)
}

sp {interpret-message*elaborate*interpret-conditional-predicate*purpose*learn-action-predicate-definition
    (state <s> ^name interpret-message ^operator <o> + ^top-state <t*1>)
   -{ (<s> ^top-state <t*2>)
      (<t*2> ^dialog-context <d*2>)
      (<d*2> ^learning-predicate <l*1>)}
    (<o> ^name interpret-conditional-predicate)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^type game-learning)
    -->
    (<o> ^purpose learn-action-predicate-definition +)
}

sp {interpret-message*elaborate*interpret-conditional-predicate*purpose*learn-predicate-definition
    (state <s> ^name interpret-message ^operator <o> + ^top-state <t*1>)
    (<o> ^name interpret-conditional-predicate)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    -->
    (<o> ^purpose learn-predicate-definition +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-property-predicate
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type process-unknown-word + ^originator instructor +)
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-property-predicate + ^parameters <p*2> +
           ^satisfaction <sat> +)
    (<p*2> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*segment*learn-action-predicate-definition
    (state <s> ^name interpret-message ^operator <o>)
    (<o> ^purpose learn-action-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
   -{ (<msg> ^then-subclause <t*1>)
      (<t*1> ^action <a*1>)
      (<a*1> ^handle lose)}
   -{ (<msg> ^action <a*2>)
      (<a*2> ^handle { << avoid has consider prefer >> <h*1> })}
   -{ (<msg> ^then-subclause <t*2>)
      (<t*2> ^action <a*3>)
      (<a*3> ^handle { << avoid consider prefer >> <h*2> })}
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-action-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*then-cluase
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learn-link <l*1> -^store-learn-link <s*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^actions <a>)
    (<o> ^message <msg>)
   -{ (<msg> ^action <a*1>)
      (<a*1> ^handle { << avoid consider prefer >> <h*1> })}
   -{ (<msg> ^then-subclause <t*3>)
      (<t*3> ^action <a*2>)
      (<a*2> ^handle { << avoid consider prefer >> <h*2> })}
    (<msg> ^then-subclause <t*2>)
    (<t*2> ^action <act>)
    (<act> -^handle { << has is1 lose >> <h*3> })
    -->
    (<dc> ^learn-link <ll> +)
    (<a> ^action <ll> +)
    (<ll> ^handle (make-constant-symbol action-default) +
           ^item-type predicate + ^predicate-structure <p> + ^type action +
           ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*default-name*goal
    (state <s> ^name interpret-message ^top-state <t*1> ^operator <o>)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learn-link <l*1> -^store-learn-link <s*1> ^type game-learning
          ^structure <s*2>)
    (<s*2> ^goals <a>)
    (<o> ^message <msg>)
    (<msg> ^arg1 <a*1>)
    (<a*1> ^handle goal)
    -->
    (<dc> ^learn-link <ll> + ^needs-goal-setup true +)
    (<a> ^goal <ll> +)
    (<ll> ^handle (make-constant-symbol goal-default) + ^item-type predicate +
           ^predicate-structure <p> + ^type goal + ^word-structure <n> +)
    (<n> ^referent <ll> + ^spelling default +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> -^2 <v*1> ^handle <name> ^property <p>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <lp>)
    (<lp> ^name <name>)
    -->
    (<dc> ^learn-link <ll> + ^input-object-1 <obj> +)
    (<ll> ^handle <name> + ^item-type predicate + ^property <p> +)
}

sp {interpret-message*apply*interpret-conditional-predicate*create*context-links*2args
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^purpose learn-predicate-definition
          ^name interpret-conditional-predicate ^message <msg>)
    (<msg> ^then-subclause <tc>)
    (<tc> -^arg2 <a*1> ^predicate <pred> ^arg1 <obj>)
    (<pred> -^handle of1 ^handle <name> ^2 <obj2>)
    (<t*1> ^dialog-context <dc>)
   -{ (<dc> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
    (<dc> ^learning-predicate <lp>)
    (<lp> ^name <name>)
    -->
    (<dc> ^learn-link <ll> + ^input-object-1 <obj> + ^input-object-2 <obj2> +)
    (<ll> ^handle <name> + ^item-type predicate +)
}

sp {interpret-message*op-no-change*propose*report-failure
    (state <s> ^impasse no-change -^allow-substate true ^attribute operator
          ^superstate <s*1>)
    (<s*1> ^name interpret-message)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name report-failure +)
}

sp {interpret-message*op-no-change*apply*report-failure
    (state <s> ^superstate <s*1> ^operator <o*1> ^superstate <ss>)
    (<s*1> ^name interpret-message)
    (<o*1> ^name report-failure)
    (<ss> ^operator <o>)
    -->
    (<ss> ^operator <o> -)
}

sp {interpret-message*propose*interpret-yes-no-message
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true ^message-type { << yes no >> <type> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-yes-no-message + ^message <msg> +
           ^message-type <type> +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal-initiate-state
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^message-type yes ^name interpret-yes-no-message)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^needs-setup true ^learning true)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-initial-state + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal*predescribed
    (state <s> ^name interpret-message ^operator <o> ^top-state <ts>)
    (<o> ^message-type yes ^name interpret-yes-no-message ^message <msg>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learning true ^parsed-goal <msg2> ^needs-goal-setup <t>)
    -->
    (<msg> ^interpreted true +)
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type learn-goal-predicate + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <msg2> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-yes-no-message*create*segment*finished-game-learning
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>)
    (<o> ^name interpret-yes-no-message ^message <msg> ^message-type <yesno>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^finished-game-teaching true)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type finished-game-learning + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^message <yesno> +)
    (<sat> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {interpret-message*apply*interpret-game-state-change
    (state <s> ^name interpret-message ^operator <o> ^instructor-message <msg>)
    (<o> ^name interpret-game-state-change ^type <type>)
    -->
    (<s> ^new-segment-info <info> + ^mark-interpreted <msg> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type game-state-change + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^message <type> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type game-state-change + ^originator agent +)
}

sp {dialog-event*propose*game-state-change-respond
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type game-state-change ^parameters <p*1>)
    (<p*1> ^message <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name game-state-change-respond + ^type <type> +)
}

sp {dialog-event*apply*game-state-change-respond
    (state <s> ^name dialog-event ^operator <o> ^top-state <t*1>
          ^top-state <t*2>)
    (<o> ^name game-state-change-respond ^type <type>)
    (<t*1> ^interaction <i*1>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type game-state-change + ^originator agent +)
    (<changes> ^outgoing-message <msg1> +)
    (<msg1> ^type simple-message + ^message-type ok +)
}

sp {dialog-event*apply*game-state-change-respond*final-8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type final-8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o1> +)
    (<in1> ^1 <o11> + ^2 <o2> +)
    (<in2> ^1 <o12> + ^2 <o4> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o1> + ^2 <o10> +)
    (<in9> ^1 <o2> + ^2 <o11> +)
    (<in10> ^1 <o4> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {dialog-event*apply*game-state-change-respond*init-8puzzle
    (state <s> ^name dialog-event ^operator <o> ^top-state <ts>)
    (<o> ^name game-state-change-respond ^type init-8puzzle)
    (<ts> ^world <wo2>)
    -->
    (<ts> ^world <wo2> - ^world <wo> +)
    (<wo> ^objects <objs> + ^predicates <preds> + ^robot <ro> +)
    (<ro> ^handle rosie + ^item-type object + ^arm <a*1> + ^predicate <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objs> ^object <self> + ^object <o1> + ^object <o2> + ^object <o3> +
           ^object <o4> + ^object <o5> + ^object <o6> + ^object <o7> +
           ^object <o8> + ^object <o9> + ^object <o10> + ^object <o11> +
           ^object <o12> + ^object <o13> + ^object <o14> + ^object <o15> +
           ^object <o16> + ^object <o17> +)
    (<self> ^type object + ^handle self + ^predicates <p*2> +)
    (<p*2> ^type object +)
    (<preds> ^predicate <on1> + ^predicate <below1> + ^predicate <near1> +
           ^predicate <diagonal-with1> +)
    (<o1> ^item-type object + ^handle object-0 + ^predicates <pr0> +)
    (<pr0> ^visible true + ^category location + ^color red1 +)
    (<o2> ^item-type object + ^handle object-1 + ^predicates <pr1> +)
    (<pr1> ^visible true + ^category location + ^color orange1 +)
    (<o3> ^item-type object + ^handle object-2 + ^predicates <pr2> +)
    (<pr2> ^visible true + ^category location +)
    (<o4> ^item-type object + ^handle object-3 + ^predicates <pr3> +)
    (<pr3> ^visible true + ^category location + ^color yellow1 +)
    (<o5> ^item-type object + ^handle object-4 + ^predicates <pr4> +)
    (<pr4> ^visible true + ^category location + ^color green1 +)
    (<o6> ^item-type object + ^handle object-5 + ^predicates <pr5> +)
    (<pr5> ^visible true + ^category location + ^color blue1 +)
    (<o7> ^item-type object + ^handle object-6 + ^predicates <pr6> +)
    (<pr6> ^visible true + ^category location + ^color purple1 +)
    (<o8> ^item-type object + ^handle object-7 + ^predicates <pr7> +)
    (<pr7> ^visible true + ^category location + ^color gray1 +)
    (<o9> ^item-type object + ^handle object-8 + ^predicates <pr8> +)
    (<pr8> ^visible true + ^category location + ^color brown1 +)
    (<o10> ^item-type object + ^handle object-9 + ^predicates <pr9> +)
    (<pr9> ^visible true + ^category block + ^color red1 +)
    (<o11> ^item-type object + ^handle object-10 + ^predicates <pr10> +)
    (<pr10> ^visible true + ^category block + ^color orange1 +)
    (<o12> ^item-type object + ^handle object-11 + ^predicates <pr11> +)
    (<pr11> ^visible true + ^category block + ^color yellow1 +)
    (<o13> ^item-type object + ^handle object-12 + ^predicates <pr12> +)
    (<pr12> ^visible true + ^category block + ^color green1 +)
    (<o14> ^item-type object + ^handle object-13 + ^predicates <pr13> +)
    (<pr13> ^visible true + ^category block + ^color blue1 +)
    (<o15> ^item-type object + ^handle object-14 + ^predicates <pr14> +)
    (<pr14> ^visible true + ^category block + ^color purple1 +)
    (<o16> ^item-type object + ^handle object-15 + ^predicates <pr15> +)
    (<pr15> ^visible true + ^category block + ^color gray1 +)
    (<o17> ^item-type object + ^handle object-16 + ^predicates <pr16> +)
    (<pr16> ^visible true + ^category block + ^color brown1 +)
    (<on1> ^item-type predicate + ^handle on1 + ^instance <in0> +
           ^instance <in1> + ^instance <in2> + ^instance <in3> +
           ^instance <in4> + ^instance <in5> + ^instance <in6> +
           ^instance <in7> +)
    (<in0> ^1 <o10> + ^2 <o2> +)
    (<in1> ^1 <o11> + ^2 <o3> +)
    (<in2> ^1 <o12> + ^2 <o1> +)
    (<in3> ^1 <o13> + ^2 <o5> +)
    (<in4> ^1 <o14> + ^2 <o6> +)
    (<in5> ^1 <o15> + ^2 <o7> +)
    (<in6> ^1 <o16> + ^2 <o8> +)
    (<in7> ^1 <o17> + ^2 <o9> +)
    (<below1> ^item-type predicate + ^handle below1 + ^instance <in8> +
           ^instance <in9> + ^instance <in10> + ^instance <in11> +
           ^instance <in12> + ^instance <in13> + ^instance <in14> +
           ^instance <in15> +)
    (<in8> ^1 <o2> + ^2 <o10> +)
    (<in9> ^1 <o3> + ^2 <o11> +)
    (<in10> ^1 <o1> + ^2 <o12> +)
    (<in11> ^1 <o5> + ^2 <o13> +)
    (<in12> ^1 <o6> + ^2 <o14> +)
    (<in13> ^1 <o7> + ^2 <o15> +)
    (<in14> ^1 <o8> + ^2 <o16> +)
    (<in15> ^1 <o9> + ^2 <o17> +)
    (<near1> ^item-type predicate + ^handle near1 + ^instance <in16> +
           ^instance <in17> + ^instance <in18> + ^instance <in19> +
           ^instance <in20> + ^instance <in21> + ^instance <in22> +
           ^instance <in23> + ^instance <in24> + ^instance <in25> +
           ^instance <in26> + ^instance <in27> + ^instance <in28> +
           ^instance <in29> + ^instance <in30> + ^instance <in31> +
           ^instance <in32> + ^instance <in33> + ^instance <in34> +
           ^instance <in35> + ^instance <in36> + ^instance <in37> +
           ^instance <in38> + ^instance <in39> + ^instance <in40> +
           ^instance <in41> + ^instance <in42> + ^instance <in43> +
           ^instance <in44> + ^instance <in45> + ^instance <in46> +
           ^instance <in47> + ^instance <in48> + ^instance <in49> +
           ^instance <in50> + ^instance <in51> + ^instance <in52> +
           ^instance <in53> + ^instance <in54> + ^instance <in55> +)
    (<in16> ^1 <o1> + ^2 <o2> +)
    (<in17> ^1 <o1> + ^2 <o4> +)
    (<in18> ^1 <o1> + ^2 <o5> +)
    (<in19> ^1 <o2> + ^2 <o1> +)
    (<in20> ^1 <o2> + ^2 <o3> +)
    (<in21> ^1 <o2> + ^2 <o4> +)
    (<in22> ^1 <o2> + ^2 <o5> +)
    (<in23> ^1 <o2> + ^2 <o6> +)
    (<in24> ^1 <o3> + ^2 <o2> +)
    (<in25> ^1 <o3> + ^2 <o5> +)
    (<in26> ^1 <o3> + ^2 <o6> +)
    (<in27> ^1 <o4> + ^2 <o1> +)
    (<in28> ^1 <o4> + ^2 <o2> +)
    (<in29> ^1 <o4> + ^2 <o5> +)
    (<in30> ^1 <o4> + ^2 <o7> +)
    (<in31> ^1 <o4> + ^2 <o8> +)
    (<in32> ^1 <o5> + ^2 <o1> +)
    (<in33> ^1 <o5> + ^2 <o2> +)
    (<in34> ^1 <o5> + ^2 <o3> +)
    (<in35> ^1 <o5> + ^2 <o4> +)
    (<in36> ^1 <o5> + ^2 <o6> +)
    (<in37> ^1 <o5> + ^2 <o7> +)
    (<in38> ^1 <o5> + ^2 <o8> +)
    (<in39> ^1 <o5> + ^2 <o9> +)
    (<in40> ^1 <o6> + ^2 <o2> +)
    (<in41> ^1 <o6> + ^2 <o3> +)
    (<in42> ^1 <o6> + ^2 <o5> +)
    (<in43> ^1 <o6> + ^2 <o8> +)
    (<in44> ^1 <o6> + ^2 <o9> +)
    (<in45> ^1 <o7> + ^2 <o4> +)
    (<in46> ^1 <o7> + ^2 <o5> +)
    (<in47> ^1 <o7> + ^2 <o8> +)
    (<in48> ^1 <o8> + ^2 <o7> +)
    (<in49> ^1 <o8> + ^2 <o4> +)
    (<in50> ^1 <o8> + ^2 <o5> +)
    (<in51> ^1 <o8> + ^2 <o6> +)
    (<in52> ^1 <o8> + ^2 <o9> +)
    (<in53> ^1 <o9> + ^2 <o8> +)
    (<in54> ^1 <o9> + ^2 <o5> +)
    (<in55> ^1 <o9> + ^2 <o6> +)
    (<diagonal-with1> ^item-type predicate + ^handle diagonal-with1 +
           ^instance <in56> + ^instance <in57> + ^instance <in58> +
           ^instance <in59> + ^instance <in60> + ^instance <in61> +
           ^instance <in62> + ^instance <in63> + ^instance <in64> +
           ^instance <in65> + ^instance <in66> + ^instance <in67> +
           ^instance <in68> + ^instance <in69> + ^instance <in70> +
           ^instance <in71> +)
    (<in56> ^1 <o1> + ^2 <o5> +)
    (<in57> ^1 <o2> + ^2 <o4> +)
    (<in58> ^1 <o2> + ^2 <o6> +)
    (<in59> ^1 <o3> + ^2 <o5> +)
    (<in60> ^1 <o4> + ^2 <o2> +)
    (<in61> ^1 <o4> + ^2 <o8> +)
    (<in62> ^1 <o5> + ^2 <o1> +)
    (<in63> ^1 <o5> + ^2 <o3> +)
    (<in64> ^1 <o5> + ^2 <o7> +)
    (<in65> ^1 <o5> + ^2 <o9> +)
    (<in66> ^1 <o6> + ^2 <o2> +)
    (<in67> ^1 <o6> + ^2 <o8> +)
    (<in68> ^1 <o7> + ^2 <o5> +)
    (<in69> ^1 <o8> + ^2 <o4> +)
    (<in70> ^1 <o8> + ^2 <o6> +)
    (<in71> ^1 <o9> + ^2 <o5> +)
}

sp {interpret-message*propose*interpret-game-state-change
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> -^interpreted true
          ^message-type { << init-risk init-8puzzle4 init-sokoban2 final-familycross final-blocksworld fail-tower3 init-blocksworld final-tower3 fail-fox fail-3mens init-i8puzzle init-8puzzle6 init-8puzzle6alt init-fox final-connect-4 final-frog3 second-breakthrough final-mahjong final-frog4 init-8puzzle5 second-mac second-tower5 init-pushmaze final-tictactoe second-frog second-tower3 third-mac final-tower5 fail-tower4 init-mahjong final-maze fail-risk init-frog second-frog4 final-othello init-connect-4 final-frog fail-sudoku4 fail-connect-3 init-frog3 fail-connect-4 second-frog3 final-sokoban init-sudoku4 init-tictactoe final-connect-3 final-peg init-frog4 init-i15puzzle fail-breakthrough final-pushmaze fail-othello final-fox init-peg final-mac init-3mens final-tower4 init-blocksworld2 fail-tower5 final-blocksworld2 init-tower5 fail-husbands init-5puzzle init-othello fail-fox2 final-i5puzzle init-sokoban init-15puzzle final-risk final-husbands final-8puzzle init-i5puzzle init-mac final-i15puzzle init-peg2 init-breakthrough init-8puzzle final-i8puzzle init-familycross final-breakthrough init-tower4 final-3mens init-tower3 fail-mac second-fox init-husbands init-connect-3 final-sudoku4 fail-tictactoe final-5puzzle init-maze second-tower4 >> <type> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-game-state-change + ^type <type> +)
}

sp {interpret-message*propose*interpret-unknown-word
    (state <s> ^name interpret-message ^instructor-message <msg>)
    (<msg> ^type unknown-word ^word <word>)
    -->
    (<s> ^operator <o> + ^operator <o> > ^operator <o> =)
    (<o> ^name interpret-unknown-word + ^word <word> + ^message <msg> +)
}

sp {interpret-message*apply*interpret-unknown-word*create*segment
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>
          ^top-state <t*2>)
    (<o> ^name interpret-unknown-word ^word <word> ^message <msg>)
    (<t*1> ^dialog-context <dc>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type process-unknown-word + ^parameters <p*1> +
           ^satisfaction <sat> +)
    (<p*1> ^word <word> +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-unknown-word + ^originator instructor +)
    (<dc> ^learning-predicate <lp> +)
    (<lp> ^name <word> +)
    (<s> ^mark-interpreted <msg> + ^outgoing-message <out-msg> +)
    (<out-msg> ^type unknown-word + ^fields <f*1> +)
    (<f*1> ^word <word> +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word
    (state <s> ^name interpret-message ^operator <o> ^smem <s*1>)
    (<o> -^word husband -^word passenger -^word adjacent
          ^name interpret-unknown-word ^word <word> ^message <msg>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <p3> +)
    (<w1> ^handle <word> + ^property <p3> +)
    (<spell> ^spelling <word> + ^structure-type ADJ + ^referent <w1> +)
    (<p3> ^handle property + ^type visual +)
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word*adjacent
    (state <s> ^name interpret-message ^operator <o> ^top-state <t*1>
          ^smem <s*1>)
    (<o> ^word adjacent ^name interpret-unknown-word ^word <word>
          ^message <msg>)
    (<t*1> ^dialog-context <dc>)
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <w1> + ^store <spell> + ^store <next> + ^store <next-to1> +)
    (<w1> ^handle <word> +)
    (<spell> ^spelling <word> + ^structure-type P + ^converts-to PP +
           ^relation <w1> +)
    (<next> ^prior-word <word> + ^current-word to + ^spelling adjacent-to +
           ^structure-type P + ^relation <w1> + ^assigners <next-to1> +
           ^converts-to PP +)
    (<next-to1> ^structure-type DP + ^relative-position after +
           ^syntactic-structure head + ^required true +)
}

sp {interpret-failure*elaborate*failure
    (state <s> ^name interpret-failure ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^failure <failure>)
    -->
    (<s> ^failure <failure> +)
}

sp {interpret-failure*propose*complete-interpret-failure
    (state <s> ^name interpret-failure)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-interpret-failure +)
}

sp {interpret-failure*apply*complete-interpret-failure*clear*status
    (state <s> ^name interpret-failure ^operator <o*1> ^top-state <t*1>
          ^failure <failure>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^failure <failure>)
    -->
    (<status> ^failure <failure> -)
}

sp {interpret-failure*apply*complete-interpret-failure*copy*new-segment-info
    (state <s> ^name interpret-failure ^operator <o*1>
          ^new-segment-info <info> ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^new-segment-info <info> +)
}

sp {interpret-failure*apply*complete-interpret-failure*copy*outgoing-message
    (state <s> ^name interpret-failure ^operator <o*1> ^outgoing-message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-interpret-failure)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<c> ^outgoing-message <msg> +)
}

sp {interpret-failure*propose*interpret-unknown-task
    (state <s> ^name interpret-failure -^new-segment-info <n*1> ^failure <f*1>)
    (<f*1> ^type unknown-task)
    -->
    (<s> ^operator <o> +)
    (<o> ^name interpret-unknown-task +)
}

sp {interpret-failure*apply*interpret-unknown-task*add*purpose
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-task)
    -->
    (<s> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator agent +)
    (<p> ^type get-next-task + ^satisfaction <s*1> +)
    (<s*1> ^dialog-event <de> +)
    (<de> ^type command + ^originator instructor +)
}

sp {interpret-failure*apply*interpret-unknown-task*send*message
    (state <s> ^name interpret-failure ^operator <o*1>)
    (<o*1> ^name interpret-unknown-task)
    -->
    (<s> ^outgoing-message <msg> +)
    (<msg> ^type get-next-task +)
}

sp {send-message*elaborate*message
    (state <s> ^name send-message ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^message <msg>)
    -->
    (<s> ^message <msg> +)
}

sp {send-message*propose*complete-send-message
    (state <s> ^name send-message)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete-send-message +)
}

sp {send-message*apply*complete-send-message*delete*message
    (state <s> ^name send-message ^operator <o*1> ^message <msg>
          ^top-state <t*1>)
    (<o*1> ^name complete-send-message)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    (<c> ^outgoing-message <msg>)
    -->
    (<c> ^outgoing-message <msg> -)
}

sp {send-message*propose*create-get-next-task
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type get-next-task)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-get-next-task +)
}

sp {send-message*apply*create-get-next-task
    (state <s> ^name send-message ^operator <o*1>)
    (<o*1> ^name create-get-next-task)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type get-next-task + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-learned-game
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type learned-game)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-learned-game-message +)
}

sp {send-message*apply*create-learned-game-message
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-learned-game-message)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type learned-game + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-unknown-word
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type unknown-word)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-unknown-word +)
}

sp {send-message*apply*create-unknown-word
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-unknown-word)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type unknown-word + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-learned-unknown-word
    (state <s> ^name send-message -^created-message <c*1> ^message <m*1>)
    (<m*1> ^type learned-unknown-word)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-learned-unknown-word +)
}

sp {send-message*apply*create-learned-unknown-word
    (state <s> ^name send-message ^operator <o*1> ^message <m*1>)
    (<o*1> ^name create-learned-unknown-word)
    (<m*1> ^fields <f>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type learned-unknown-word + ^originator agent + ^fields <f> +)
}

sp {send-message*propose*create-simple-message
    (state <s> ^name send-message -^created-message <c*1> ^message <msg>)
    (<msg> ^type simple-message ^message-type <type>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name create-simple-message + ^message-type <type> +)
}

sp {send-message*apply*create-simple-message
    (state <s> ^name send-message ^operator <o>)
    (<o> ^name create-simple-message ^message-type <type>)
    -->
    (<s> ^created-message <msg> +)
    (<msg> ^type <type> + ^originator agent + ^fields <f> +)
}

sp {interaction*apply*performed-event*remove*performed
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name performed-event ^event <event>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<status> ^performed <event>)
    -->
    (<status> ^performed <event> -)
}

sp {interaction*apply*performed-event*satisfied*purpose*pop
    (state <s> ^name interaction ^operator <o> ^top-state <t*1>)
    (<o> ^name performed-event ^event <event>)
    (<t*1> ^interaction <i>)
    (<i> ^changes <changes> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <p*1>)
    (<p*1> ^satisfaction <sat>)
    (<sat> ^<event-cat> <sat-event>)
    (<event> ^<event-cat> <perf-event>)
   -{ (<sat-event> ^{ <> info <attr> } <val>)
      (<perf-event> -^<attr> <val>)}
    (<sat-event> ^type <event-type>)
    (<perf-event> ^type <event-type>)
    -->
    (<changes> ^terminate-segment true +)
}

sp {satisfy-purpose*elaborate*purpose
    (state <s> ^name satisfy-purpose ^top-state <t*1>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^stack <s*1>)
    (<s*1> ^segment <s*2>)
    (<s*2> ^purpose <purp>)
    -->
    (<s> ^purpose <purp> +)
}

sp {satisfy-purpose*propose*dialog-event*from*agent
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator agent)
    -->
    (<s> ^operator <o> +)
    (<o> ^name dialog-event +)
}

sp {satisfy-purpose*propose*learning-event
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^learning-event <l*1>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learning-event +)
}

sp {satisfy-purpose*propose*dialog-event*instructor
    (state <s> ^name satisfy-purpose ^purpose <p*1>)
    (<p*1> ^satisfaction <s*1>)
    (<s*1> ^dialog-event <de>)
    (<de> ^originator instructor)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name wait-for-response +)
}

sp {dialog-event*elaborate*purpose
    (state <s> ^name dialog-event ^superstate <s*1>)
    (<s*1> ^purpose <p>)
    -->
    (<s> ^purpose <p> +)
}

sp {learning-event*propose*learn-goal-demonstration*initial
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-goal-initial-state)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-goal-demonstration + ^type initial +)
}

sp {learning-event*propose*finished-game-teaching
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type finished-game-teaching)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finished-game-teaching + ^type game +)
}

sp {learning-event*propose*finished-game-teaching*learned
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type finished-game-learning ^parameters <p*1>)
    (<p*1> ^message <yesno>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name finished-game-teaching + ^response <yesno> +)
}

sp {learning-event*elaborate*puzzle-retrieval
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-puzzle-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^retrieve-game <name> + ^multiplayer false +)
}

sp {learning-event*propose*learn-puzzle-name
    (state <s> ^name learning-event -^retrieve-handle <r*1> ^purpose <p>
          ^retrieve-game <name>)
    (<p> ^type learn-puzzle-name ^parameters <p*1>)
    (<p*1> ^message <msg>)
    (<msg> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name store-predicate-structure + ^type puzzle + ^storing name +
           ^handle <name> + ^message <msg> +)
}

sp {learning-event*propose*finished-learning
    (state <s> ^name learning-event ^finished-learning <type>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    -->
    (<s> ^operator <o1> + ^operator <o1> >)
    (<o1> ^name finished-learning + ^type <type> +)
}

sp {learning-event*propose*learn-predicate*goal
    (state <s> ^name learning-event -^finished-learning goal ^purpose <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    (<p> ^type learn-goal-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type goal +)
}

sp {learning-event*apply*learn-predicate*goal*clean-setup
    (state <s> ^name learning-event ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name learn-predicate)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^parsed-goal <m> ^needs-goal-setup <t>)
    -->
    (<dc> ^needs-goal-setup <t> - ^parsed-goal <m> -)
}

sp {learning-event*propose*learn-predicate*action
    (state <s> ^name learning-event -^finished-learning action ^purpose <p>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finalize-chunk <f*1>)}
    (<p> ^type learn-action-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type action +)
}

sp {learning-event*apply*chunk-predicate-structure
    (state <s> ^name learning-event ^operator <o*1> ^store-link <dd>)
    (<o*1> ^name chunk-predicate-structure)
    -->
    (<s> ^store-link <dd> -)
}

sp {learning-event*propose*chunk-predicate-structure
    (state <s> ^name learning-event ^finished-learning <type> ^purpose <p>
          ^top-state <t*2>)
    (<t*2> ^dialog-context <d*1>)
    (<d*1> ^finalize-chunk <h>)
   -{ (<s> ^<type> <t*1>)
      (<t*1> ^handle <h>)}
    (<p>
          ^type { << learn-action-predicate learn-heuristic-predicate learn-goal-predicate learn-failure-predicate >> <t*3> })
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype <type> +
           ^predicate-handle <h> +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*action
    :o-support
    (state <s> ^finished-learning action ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*1> ^interaction <i*2>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-action +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*apply*chunk-predicate-structure*finished*goal
    :o-support
    (state <s> ^finished-learning goal ^name learning-event
          ^finished-learning <type> ^top-state <ts> ^<type> <t*1>)
    (<ts> ^dialog-context <dc> ^interaction <i*1> ^interaction <i*2>)
    (<dc> ^finalize-chunk <name>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<t*1> ^handle <h>)
    -->
    (<dc> ^finalize-chunk <name> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type learned-goal +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {learning-event*propose*learn-predicate*property
    (state <s> ^name learning-event ^purpose <p>)
    (<p> ^type learn-property-predicate ^parameters <p*1>)
    (<p*1> ^message <msg>)
    -->
    (<s> ^operator <o> +)
    (<o> ^name learn-predicate + ^message <msg> + ^type predicate +)
}

sp {learning-event*elaborate*purpose
    (state <s> ^name learning-event ^superstate <s*1>)
    (<s*1> ^purpose <purp>)
    -->
    (<s> ^purpose <purp> +)
}

sp {learn-predicate*elaborate*verb-structure
    :o-support
    (state <s> ^gtype action ^name learn-predicate ^verb-structure <vs>
          ^action <a>)
    -->
    (<a> ^verb-structure <vs> +)
}

sp {learn-predicate*elaborate*input-args
    (state <s> ^name learn-predicate ^predicate <T5> ^gtype <gtype>
          ^<gtype> <g*1>)
    (<T5> ^formated predicate ^condition <c> ^link <co> ^handle <name>
          ^potential-args <P125> ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg ^rtype <rtype> ^parameter <p*1> ^result <r*2>)
    (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^learning-predicate <l*1>)
      (<l*1> ^name <name>)}
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<g*1> ^condition <co>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <a1>)
    (<c1> ^rtype <rtype> ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <in1>)
    (<r*2> ^set <res2>)
    -->
    (<res2> ^instance <in1> +)
}

sp {learn-predicate*elaborate*input-args*learning-predicate
    (state <s> ^name learn-predicate ^predicate <T5> ^top-state <t*1>)
    (<T5> ^formated predicate ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg)
    (<nlps> ^aname <name>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    (<l*1> ^name <name>)
    -->
    (<c> ^result <r*1> +)
    (<r*1> ^set <res> +)
}

sp {learn-predicate*elaborate*input-args*object
    (state <s> ^name learn-predicate ^predicate <T5> ^world <w*1>
          ^top-state <t*1>)
    (<T5> ^formated predicate ^condition <c> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg ^result <r*1>)
    (<nlps> ^aname <name>)
    (<w*1> ^objects <o*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning-predicate <l*1>)
    (<l*1> ^name <name>)
    (<r*1> ^set <res>)
    (<o*1> ^object <obj>)
    -->
    (<res> ^instance <in> +)
    (<in> ^1 <obj> +)
}

sp {learn-predicate*elaborate*problem-space*predicate-structure
    (state <s> ^name learn-predicate ^top-state <t*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name selection)}
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^name action + ^world <world> +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {learn-predicate*elaborate*tcn
    (state <s> ^name learn-predicate ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^message <t>
          ^type { << predicate action goal failure heuristic >> <type> })
    (<t> -^learned-structure <l*1>)
    -->
    (<s> ^parsed-structure <t> + ^gtype <type> + ^main-type <type> +
           ^<type> <act> +)
    (<act> ^parameter-set <ps> + ^potential-args <po> +)
}

sp {learn-predicate*propose*convert-language-format
    (state <s> ^name learn-predicate -^tcn <t*1> ^gtype <gtype>
          ^parsed-structure <t>)
   -{ (<s> ^<gtype> <g*1>)
      (<g*1> ^nlp-set <n*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name convert-parsed-format + ^structure <t> +)
}

sp {learn-predicate*store*verb-structure
    :o-support
    (state <s> ^name learn-predicate ^verb-structure <vs> ^action <t>
          ^top-state <t*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    -->
    (<ll> ^verb-structure <vs> +)
}

sp {learn-predicate*store*structure
    :o-support
    (state <s> ^name learn-predicate
          ^gtype { << action goal failure heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^predicate-structure <ps>)
    (<t> ^formated <f*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<ps> ^conditions <nlp> +)
}

sp {learn-predicate*store*structure*argnum
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << action goal failure heuristic >> <gtype> }
          ^top-state <t*1> ^<gtype> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^handle <n>)
    (<t> ^handle <n> ^parameter-set <p*1>)
    (<p*1> ^argnum <an>)
    -->
    (<ll> ^argnum <an> +)
}

sp {learn-predicate*store*structure*learned-predicate
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << predicate heuristic >> <type> } ^gtype <type>
          ^top-state <t*1> ^<type> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^handle <name>)
    (<t> ^handle <name> ^formated <f*1> ^parameter-set <p*1> ^nlp-set <nl>)
    (<p*1> ^argnum <an>)
    -->
    (<ll> ^predicate-structure <ps> + ^argnum <an> +)
}

sp {learn-predicate*store*structure*learned-predicate*conditions
    :o-support
    (state <s> ^name learn-predicate
          ^main-type { << predicate heuristic >> <type> } ^gtype <type>
          ^top-state <t*1> ^<type> <t>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^type game-learning ^learn-link <ll>)
    (<ll> ^predicate-structure <ps> ^handle <name>)
    (<t> ^handle <name> ^formated <f*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<ps> ^conditions <nlp> +)
}

sp {learn-predicate*elaborate*list-games
    (state <s> ^name learn-predicate ^main-type <type2> ^top-state <t*1>
          ^<type2> <gt> ^superstate <s*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <l*1> ^name <name>)
    (<l*1> ^handle <pname>)
    (<gt> ^handle <pname> ^formated <f*1>)
    (<s*1> ^operator <op>)
    (<op> ^type <type>)
    -->
    (<s> ^list <l*2> + ^objects <o> + ^current <g> +)
    (<l*2> ^game <g> +)
    (<g> ^game <name> + ^type <type> + ^type predicate +)
}

sp {learn-predicate*elaborate*game-name
    (state <s> ^name learn-predicate ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^name <name>)
    (<s*1> ^operator <op>)
    (<op> ^message <m*1> ^type <type>)
    -->
    (<s> ^game <name> +)
}

sp {learn-predicate*elaborate*actiongoalname
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^aname <aname>)
    -->
    (<t> ^aname <aname> + ^handle <aname> +)
}

sp {learn-predicate*elaborate*handlename
    (state <s> ^name learn-predicate ^main-type <type> ^<type> <t>)
    (<t> ^handle <aname>)
    -->
    (<t> ^aname <aname> +)
}

sp {learn-predicate*propose*formate-conditions
    (state <s> ^name learn-predicate ^main-type <type> ^<type> <t>)
    (<t> -^formated <f*1> ^nlp-set <nlp>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name format-conditions + ^type <type> + ^nlp-set <nlp> +)
}

sp {learn-predicate*elaborate*sub-conditions
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*elaborate*simulated-true
    (state <s> ^name learn-predicate ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    -->
    (<s> ^simulated true +)
}

sp {learn-predicate*elaborate*sub-conditions*predicate
    (state <s> ^name learn-predicate
          ^gtype { << predicate heuristic >> <type> } ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {learn-predicate*elaborate*nlp-set*verb-structure
    (state <s> ^gtype action ^name learn-predicate ^action <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^verb-structure <vs>)
    -->
    (<t> ^verb-structure <vs> +)
}

sp {evaluate-predicate*eval-condition*impasse
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^list <l*1>)
    (<l*1> ^game <g*1>)
    -->
    (force-learn <s>)
    (<s> ^name evaluate-predicate + ^linkstate <ss> + ^result <r> +)
}

sp {evaluate-predicate*propose*resolve-conditions
    (state <s> ^name evaluate-predicate)
   -{ (<s> ^result <r*1>)
      (<r*1> ^set <set>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name resolve-conditions +)
}

sp {evaluate-predicate*elaborate*problemspace*games
    (state <s> ^superstate <s*1>)
    (<s*1> ^problemspace { << games >> <ps> })
    -->
    (<s> ^problemspace <ps> +)
}

sp {format-conditions*elaborate*parameter-set
    (state <s> ^name format-conditions)
    -->
    (<s> ^parameter-set <ps> +)
}

sp {format-conditions*elaborate*operator*condition
    (state <s> ^name format-conditions ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^nlp-set <n*1>)
    (<n*1> ^nlp <nlp>)
    -->
    (<s> ^condition <nlp> + ^condition-set <nlp> +)
}

sp {format-conditions*elaborate*sub-conditions
    (state <s> ^name format-conditions ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<s> ^condition <cond> +)
}

sp {format-conditions*propose*calculate1
    (state <s> ^name format-conditions -^tested calculate1)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name calculate1 +)
}

sp {format-conditions*propose*calculate2
    (state <s> ^tested calculate1 -^tested calculate2 ^name format-conditions)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name calculate2 +)
}

sp {format-conditions*propose*complete
    (state <s> ^tested calculate1 ^tested calculate2 ^name format-conditions)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name complete +)
}

sp {format-conditions*apply*complete*parameter-set
    (state <s> ^name format-conditions ^operator <o*1> ^parameter-set <ps>
          ^superstate <ss>)
    (<o*1> ^name complete)
    (<ps> ^argnum <num>)
    (<ss> ^operator <o*2> ^<type> <t>)
    (<o*2> ^type <type>)
    (<t> ^parameter-set <ps2>)
    -->
    (<ps2> ^argnum <num> +)
    (<t> ^formated <type> +)
}

sp {format-conditions*apply*complete*condition
    (state <s> ^name format-conditions ^operator <o*1> ^condition-set <cs>
          ^parameter-set <ps> ^superstate <ss>)
    (<o*1> ^name complete)
    (<ss> ^operator <o*2> ^<type> <t>)
    (<o*2> ^type <type>)
    -->
    (<t> ^condition <cs> +)
}

sp {format-conditions*apply*calculate1*default
    (state <s> ^name format-conditions ^operator <o*1>)
   -{ (<s> ^condition <c>)
      (<c> -^rtype <r*1>)}
    (<o*1> ^name calculate1)
    -->
    (<s> ^tested calculate1 +)
}

sp {format-conditions*apply*calculate2*default
    (state <s> ^name format-conditions ^operator <o*1>)
   -{ (<s> ^condition <c>)
      (<c> -^result <r*1> -^attribute input-arg)}
    (<o*1> ^name calculate2)
    -->
    (<s> ^tested calculate2 +)
}

sp {format-conditions*apply*calculate1*negative-test
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^negative <n*1>)
    (<o*1> ^name calculate1)
    -->
    (<co> ^negative false +)
}

sp {format-conditions*apply*calculate1*type2
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> ^rtype <type> ^parameter <p>)
    (<p> ^num <arg2> ^<arg2> <a1>)
    (<a1> -^type <t*1>)
    (<o*1> ^name { << calculate1 calculate2 >> <n*1> })
    -->
    (<a1> ^type <type> +)
}

sp {format-conditions*apply*calculate1*empty-args
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^args <a*1>)
    (<o*1> ^name calculate1)
    -->
    (<co> ^args <a1> +)
}

sp {format-conditions*apply*calculate2*paramlinking
    (state <s> ^name format-conditions ^condition <co> ^operator <o*1>)
    (<co> -^result <r*1> -^attribute input-arg ^parameter <p*1>)
    (<o*1> ^name calculate2)
    (<p*1> ^num <n*1>)
    -->
    (<co> ^result <r*2> +)
    (<r*2> ^set <p> +)
}

sp {format-conditions*apply*calculate1*location-block*no-obj
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate2)
    (<co> ^args <a1> ^rtype <type> ^name { << location block >> <n*1> })
    (<a1> -^<something> <s*1>)
    -->
    (<a1> ^num 1 + ^1 <c2> +)
    (<c2> ^name object + ^args <a3> + ^negative false + ^result <r*1> +
           ^rtype single + ^parameter <p*1> + ^type attribute +
           ^attribute primitive +)
    (<r*1> ^set <res> +)
    (<p*1> ^num 0 +)
}

sp {format-conditions*apply*calculate1*parameter-num2
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate1)
    (<co> ^parameter <p>)
    (<p> -^num <n*1> -^result <r*1>)
    -->
    (<p> ^num (size <p>) +)
}

sp {format-conditions*apply*calculate1*arg-num
    (state <s> ^name format-conditions ^operator <o*1> ^condition <co>)
    (<o*1> ^name calculate2)
    (<co> ^args <a>)
    (<a> -^num <n*1> ^<something> <s*1>)
    -->
    (<a> ^num (size <a>) +)
}

sp {format-conditions*apply*calculate1*parameter-set*argnum
    (state <s> ^name format-conditions ^parameter-set <ps> ^operator <o*1>
          ^condition <co>)
    (<ps> -^argnum <a*1>)
    (<o*1> ^name calculate1)
    (<co> ^parameter <p*1>)
    (<p*1> ^{ << 1 2 3 4 5 6 7 8 9 >> <arg2> } <a*2>)
    (<a*2> ^param-id <num>)
   -{ (<s> ^condition <c*1>)
      (<c*1> ^parameter <p*2>)
      (<p*2> ^{ << 1 2 3 4 5 6 7 8 9 >> <arg> } <a*3>)
      (<a*3> ^param-id { > <num> <p*3> })}
    -->
    (<ps> ^argnum <num> +)
}

sp {retrieve-predicate-structure*elaborate*predicate-handle
    (state <s> ^name retrieve-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^handle <handle>)
    -->
    (<s> ^handle <handle> +)
}

sp {retrieve-predicate-structure*elaborate*condition
    (state <s> ^name retrieve-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^condition <co>)
    -->
    (<s> ^condition <co> +)
}

sp {retrieve-predicate-structure*elaborate*smem-query
    (state <s> ^name retrieve-predicate-structure ^handle <handle> ^smem <s*1>)
    (<s*1> ^command <c>)
    -->
    (<c> ^query <cue> + ^depth 15 +)
    (<cue> ^handle <handle> + ^item-type predicate +)
}

sp {retrieve-predicate-structure*propose*complete
    (state <s> ^name retrieve-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype action)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> -^opponent <o*2> ^primary-rtype <rtype> ^predicate-structure <ps>
          ^argnum <an> ^verb-structure <vs> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^action <p> +)
    (<p> ^handle <name> + ^aname <name> + ^verb-structure <vs> +
           ^nlp-set <ps> + ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result*no-condition-link*goal
    (state <s> ^name retrieve-predicate-structure ^superstate <ss>
          ^operator <o*1> ^copy-structure <c*1> ^smem <s*1>)
    (<ss> ^gtype goal)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^type goal ^primary-rtype <rtype> ^predicate-structure <ps>
          ^argnum <an> ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^goal <p> +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <ps> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> +)
    (<P124> ^argnum <an> +)
    (<dest> ^aname <name> +)
    (<ps> ^aname <name> +)
}

sp {retrieve-predicate-structure*apply*complete*smem-query*result
    (state <s> ^name retrieve-predicate-structure ^operator <o*1>
          ^condition <co> ^copy-structure <c*1> ^smem <s*1> ^superstate <ss>)
    (<o*1> ^name complete)
    (<c*1> ^destination <dest>)
    (<dest> ^primary-rtype <rtype> ^predicate-structure <p2> ^argnum <an>
          ^handle <name>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<ss> ^predicate <p> + ^gtype predicate +)
    (<p> ^handle <name> + ^aname <name> + ^nlp-set <p2> +
           ^primary-rtype <rtype> + ^formated predicate +
           ^parameter-set <P124> + ^potential-args <P125> + ^link <co> +)
    (<P124> ^argnum <an> +)
    (<p2> ^aname <name> +)
}

sp {retrieve-predicate-structure*copy*stucture
    (state <s> ^name retrieve-predicate-structure ^smem <s*1>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    -->
    (<s> ^copy-structure <copy> +)
    (<copy> ^source <pred> + ^destination <pred> +)
}

sp {store-predicate-structure*elaborate*attributes
    (state <s> ^name store-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^storing <t> ^message <msg> ^handle <h> ^type <y>)
    -->
    (<s> ^storing <t> + ^handle <h> + ^message <msg> + ^ptype <y> +)
}

sp {store-predicate-structure*propose*complete
    (state <s> ^name store-predicate-structure)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {store-predicate-structure*apply*complete*puzzle-name
    (state <s> ^ptype puzzle ^name store-predicate-structure ^operator <o*1>
          ^top-state <t*1> ^top-state <t*2>)
    (<o*1> ^name complete)
    (<t*1> ^interaction <i*1>)
    (<t*2> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type describe-puzzle +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {store-predicate-structure*elaborate*top-state*dialogue-context*puzzle
    (state <s> ^ptype puzzle ^storing name ^name store-predicate-structure
          ^operator <o*1> ^message <m*1> ^handle <handle> ^top-state <ts>)
    (<o*1> ^name complete)
    (<m*1> ^predicate <pred>)
    -->
    (<ts> ^dialog-context <dc> +)
    (<dc> ^type game-learning + ^name <handle> + ^structure <pred> +
           ^learning true + ^needs-setup true +)
    (<pred> ^actions <act> + ^goals <go> + ^failures <fa> +
           ^heuristics <heu> + ^multiplayer false + ^task-type puzzle +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*goal
    (state <s1> ^gtype { << goal >> <c2> } ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*action
    (state <s1> ^gtype { << action >> <c2> } -^main-type heuristic ^list <l1>
          ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^aname <c1> ^parameter-set <p1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs> +)
}

sp {satisfy-predicate-conditions*propose*finished-learning
    (state <s1> ^main-type predicate ^gtype predicate ^list <l1>
          ^predicate <a1> ^top-state <t*1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning true ^learn-link <l*1>)
    (<l*1> ^handle <c1>)
    -->
    (<s1> ^operator <o1> + ^operator <o1> =)
    (<o1> ^name finished-learning + ^type predicate +)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning
    (state <s1> ^operator <o> ^main-type { << action >> <type> }
          ^top-state <t*1> ^superstate <ss> ^<type> <a1>)
    (<o> -^duplicate-of <d*2> ^type <type>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type> +)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*goal
    (state <s1> ^operator <o> ^main-type { << goal failure >> <type> }
          ^top-state <t*1> ^superstate <s*1> ^superstate <ss> ^<type> <a1>)
    (<o> -^duplicate-of <d*2> ^type <type>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<s*1> ^superstate <sss>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<sss> ^finished-learning <type> +)
    (<ss> ^finished-learning <type> +)
}

sp {satisfy-predicate-conditions*apply*finished-learning*elab-store-link
    (state <s1> ^operator <o*1> ^top-state <t*1> ^top-state <t*2>)
    (<o*1> ^name finished-learning)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^learn-link <ll>)
    (<ll> ^predicate-structure <p*1>)
    -->
    (<s1> ^store-link (deep-copy <ll>) +)
}

sp {satisfy-predicate-conditions*apply*finished-learning*elaborate*source
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning true ^name <name>)
    -->
    (<ll> ^from <name> +)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c>)
    (<c> -^name number ^result <r*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance2
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance3
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <n*1>)
    (<n*1> ^args <a*2>)
    (<a*2> ^<n1> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance4
    (state <s1> ^operator <o*1> ^store-link <ll> ^top-state <t*1>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^args <a*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    (<a*1> ^<n> <n*1>)
    (<n*1> ^args <a*2>)
    (<a*2> ^<n1> <n*2>)
    (<n*2> ^args <a*3>)
    (<a*3> ^<n2> <c>)
    (<c> -^name number ^result <r*1>)
    (<r*1> ^set <res>)
    (<res> ^instance <i>)
    -->
    (<res> ^instance <i> -)
}

sp {finished-learning*store*predicate*concept
    (state <s> ^name finished-learning ^smem <s*1> ^superstate <s*2>)
    (<s*1> ^command <sc>)
    (<s*2> ^store-link <ll>)
    -->
    (<s> ^store-link <ll> + ^to-store <ll> +)
    (<sc> ^store <ll> +)
}

sp {finished-learning*propose*store*primary*rtype
    (state <s> ^operator <o*1> ^store-link <ll>)
    (<o*1> ^name finished-learning)
    (<ll> ^predicate-structure <p*1>)
    (<p*1> ^conditions <c*1>)
    (<c*1> ^parameter <p*2>)
    (<p*2> ^<num> <p>)
    (<p> ^param-id 1 ^type <rtype>)
    -->
    (<ll> ^primary-rtype <rtype> +)
}

sp {finished-learning*propose*store-next-level
    (state <s> ^name finished-learning -^all-stored <a*1> ^store-link <ts>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name store-game-level + ^to-store <ts> +)
}

sp {finished-learning*apply*store-next-level*finished
    (state <s> ^name finished-learning ^operator <o>)
   -{ (<s> ^to-store <t*1> -^to-store <t2>)
      (<t*1> ^<something> { <=> <s> <t2> })}
    (<o> ^name store-game-level)
    -->
    (<s> ^all-stored true +)
}

sp {finished-learning*apply*store-next-level2
    (state <s> ^name finished-learning ^operator <o> ^to-store <ts>
          ^smem <s*1>)
    (<o> ^name store-game-level)
    (<s*1> ^command <sc>)
    (<ts>
          ^{ <> final <> goal-state <> initial <something> } { <=> <s> <something2> })
    -->
    (<s> ^to-store <something2> +)
    (<sc> ^store <something2> +)
}

sp {finished-learning*propose*complete
    (state <s> ^name finished-learning)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {satisfy-purpose*finished-learning*apply*complete*remove-learn-link
    (state <s1> ^name interaction ^operator <o> ^top-state <t*1>)
   -{ (<o> ^event <e*1>)
      (<e*1> ^learning-event <l*1>)
      (<l*1> ^type game-name)}
   -{ (<o> ^event <e*2>)
      (<e*2> ^dialog-event <d*1>)
      (<d*1> ^type process-unknown-word)}
   -{ (<o> ^event <e*3>)
      (<e*3> ^dialog-event <d*2>)
      (<d*2> ^type process-sentence)}
    (<o> ^name performed-event)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^argnum <a>)
    -->
    (<dc> ^learn-link <ll> -)
}

sp {satisfy-purpose*clean*dialog-object-list
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-object-list { <=> <s1> <dol> })
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list nil +)
}

sp {satisfy-purpose*clean*dialog-object-list-saved
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-object-list-saved { <=> <s1> <dol> })
    -->
    (<ts> ^dialog-object-list-saved <dol> - ^dialog-object-list-saved nil +)
}

sp {satisfy-purpose*clean*dialog-world
    (state <s1> ^name satisfy-purpose ^operator <o*1> ^top-state <ts>)
    (<o*1> ^name wait-for-response)
    (<ts> ^dialog-world <d*1>)
    (<d*1> ^{ << objects predicates >> <a*1> } <dw>)
    (<dw> ^<something> <obj>)
    -->
    (<dw> ^<something> <obj> -)
}

sp {finished-learning*apply*complete*input-object-1
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^input-object-1 <lp>)
    -->
    (<dc> ^input-object-1 <lp> -)
}

sp {finished-learning*apply*complete*input-object-2
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^input-object-2 <lp>)
    -->
    (<dc> ^input-object-2 <lp> -)
}

sp {finished-learning*apply*complete*send-message*predicate
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>
          ^top-state <t*2> ^top-state <t*3>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <lp> ^learn-link <l*1>)
    (<l*1> ^handle <word>)
    (<lp> ^name <word>)
    (<t*2> ^interaction <i*1>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<dc> ^learning-predicate <lp> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type learned-unknown-word + ^fields <f*1> +)
    (<f*1> ^word <word> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
}

sp {finished-learning*apply*complete*send-message*action
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>
          ^superstate <ss>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^learning-predicate <l*1> ^structure <s*1>)
    (<s*1> ^actions <act>)
    (<act> ^action <a>)
    (<a> ^handle <name>)
    -->
    (<act> ^action <a> - ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {finished-learning*apply*complete*send-message*goal
    (state <s1> ^name finished-learning ^operator <o*1> ^top-state <t*1>
          ^top-state <t*2> ^top-state <t*3>)
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <dc>)
    (<dc> -^goal-relationships <g*1> -^learning-predicate <l*1>
          ^structure <s*1>)
    (<s*1> ^goals <act>)
    (<t*2> ^interaction <i*1>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
    -->
    (<act> ^goal <a> - ^retrieve-handle <name> +)
    (<dc> ^finalize-chunk <name> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^rtype <rtype> ^result <r1> ^name <c2> ^attribute <c1>)
    (<r1> ^set <s2>)
    (<t1> ^primary-rtype <rtype> ^link <c4> ^nlp-set <n1> ^instance <i1>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^rtype set ^type concept ^args <a*1> ^parameter <p*2> ^result <r1>
          ^name <c2> ^attribute <c1>)
    (<p*2> ^num { < 2 <n*1> })
    (<a*1> ^1 <v*1>)
    (<v*1> ^parameter <p*1>)
    (<p*1> ^num 0)
    (<r1> ^set <s2>)
   -{ (<t1> -^instance <i*1>)
      (state <s1> ^<a*2> <v*2>)}
    (<t1> ^primary-rtype single ^link <c4> ^nlp-set <n1>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
    (<i1> ^1 <set> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*copy-objects
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^rtype set ^type concept ^args <a*1> ^parameter <p*2> ^result <r1>
          ^name <c2> ^attribute <c1>)
    (<p*2> ^num { < 2 <n*1> })
    (<a*1> ^1 <v*1>)
    (<v*1> ^parameter <p*1>)
    (<p*1> ^num 0)
    (<r1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <set>)
    (<t1> ^primary-rtype single ^link <c4> ^nlp-set <n1> ^instance <i*2>)
    (<n1> ^aname <c2>)
    (<i*2> ^1 <obj>)
    -->
    (<set> ^<object> <obj> +)
}

sp {satisfy-predicate-conditions*elaborate*calculate6
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate5 ^tested calculate4)
    -->
    (<p2> ^tested calculate6 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate5
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate4 ^tested calculate3)
    -->
    (<p2> ^tested calculate5 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate4
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate2 ^tested calculate3)
    -->
    (<p2> ^tested calculate4 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate2
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate1)
    -->
    (<p2> ^tested calculate2 + ^tested calculate3 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate1
    (state <s1> ^simulated true ^gtype <c1> ^<c1> <a1> ^list <l1>)
   -{ (<a1> ^condition <c>)
      (<c> ^return-type number ^result <r*1>)
      (<r*1> ^set <rset>)
     -{ (<rset> ^instance <i*1>)
        (<i*1> ^1 <v*2>)}}
   -{ (<a1> ^condition <c2>)
      (<c2> -^return-type number ^result <r*2>)
      (<r*2> ^set <rset2>)
     -{ (<rset2> ^instance <i*2>)
        (<i*2> ^1 <v*3>)
        (<v*3> ^<elem> <e*1>)}}
    (<a1> ^potential-args <p1> ^parameter-set <p2>)
   -{ (<p1> -^<asdf> <a*2>)
      (state <s1> ^<a*1> <v*1>)}
    (<l1> ^game <g1>)
    -->
    (<p2> ^tested calculate1 +)
}

sp {satisfy-predicate-conditions*elaborate*instance*from-predicate-results
    (state <s1> ^gtype predicate ^list <l1> ^predicate <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3>)
    (<p2> ^tested calculate1 ^tested calculate2 ^tested calculate5
          ^tested calculate6 ^set <s2>)
    -->
    (<p1> ^instance <s2> +)
}

sp {satisfy-predicate-conditions*elaborate*result*set
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate1 ^tested calculate2 ^tested calculate5
          ^tested calculate4 ^tested calculate6 ^tested calculate3 ^iset <i1>)
   -{ (<p2> ^neg <neg1>)
      (<neg1> ^<ind4> <obj3>)
      (<i1> ^<ind4> <obj3>)}
   -{ (<p2> ^negpair3 <pair3>)
      (<pair3> ^<ind3> <objc> ^{ <> <ind3> <ind2> } <objb>
            ^{ <> <ind2> <> <ind3> <ind1> } <obja>)
      (<i1> ^<ind3> <objc> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<p2> ^negpair <pair>)
      (<pair> ^<ind2> <objb> ^{ <> <ind2> <ind1> } <obja>)
      (<i1> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<i1> ^<ind1> { <=> <i1> <obja> } ^<ind1> <obja>
            ^{ <> <ind1> <ind2> } <obja>)}
    -->
    (<p2> ^set <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*3-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 3)
    (<p1> ^3 <o3> ^2 <o2> ^1 <o1>)
   -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^negpair <pair8>)
      (<pair8> ^3 <o3> ^2 <o2>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
   -{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*2-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 2)
    (<p1> ^2 <o2> ^1 <o1>)
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*1-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 1)
    (<p1> ^1 <o1>)
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*2-arguments
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p4> ^result <r1>)
    (<p4> ^num 2 ^2 <*1> ^1 <*2>)
    (<*1> ^param-id <x1>)
    (<*2> ^param-id <x2>)
    (<p3> ^<x2> <*3> ^<x1> <*4>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p5>)
      (<p5> ^2 <*4> ^1 <*3>)}
    -->
    (<p2> ^negpair <n1> +)
    (<n1> ^<x2> <*3> + ^<x1> <*4> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*1-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^<c6> <p4>)
    (<p4> ^param-id <c4>)
    (<p1> ^<c4> <o1>)
   -{ (<r1> ^set <s*1>)
      (<s*1> ^instance <p*1>)
      (<p*1> ^<c6> <o1>)}
    -->
    (<p2> ^neg <n1> +)
    (<n1> ^<c4> <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument*number
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c3> ^potential-args <p1> ^parameter-set <p2>)
    (<c3> ^return-type number ^rtype single ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <v*1> ^<c4> <c7>)
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
    -->
    (<p1> ^<c6> <c7> +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^condition <c1>)
    (<c1> ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <o2> ^{ << 1 2 3 4 5 >> <c4> } <o1>)
   -{ (<o2> -^<wme> <w*1>)
      (<s1> ^list <l*1>)}
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
    -->
    (<p1> ^<c6> <o1> +)
}

sp {chunk-predicate-structure*elaborate*result*actiongoal
    (state <s> ^name chunk-predicate-structure ^operator <o*1> ^gtype <t>
          ^retrieve-handle <r*1> ^superstate <ss> ^<t> <p>)
    (<o*1> ^name complete)
    -->
    (<ss> ^<t> <p> +)
}

sp {chunk-predicate-structure*propose*complete
    (state <s> ^name chunk-predicate-structure ^gtype <t>
          ^retrieve-handle <r*1> ^<t> <p>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete +)
}

sp {chunk-predicate-structure*propose*check-smem-concept
    (state <s> ^name chunk-predicate-structure -^retrieve-handle <r*1>
          -^unknown <u*1> -^known <k*1>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name check-smem-concept +)
}

sp {chunk-predicate-structure*elaborate*smem-query*auto-transfer
    (state <s> ^name check-smem-concept ^smem <s*1> ^superstate <ss>)
    (<s*1> ^command <c>)
    (<ss> ^gtype <gtype> ^<gtype> <g*1>)
    (<g*1> ^condition <co>)
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<c> ^query <cue> + ^depth 1 +)
    (<cue> ^handle <name> + ^item-type predicate +)
}

sp {chunk-predicate-structure*elaborate*known
    :o-support
    (state <s> ^name check-smem-concept ^superstate <ss> ^smem <s*1>)
   -{ (<ss> ^superstate <s*2>)
      (<s*2> ^superstate <s*3>)
      (<s*3> ^name transfer-action-goal)}
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <r*2>)
    -->
    (<ss> ^known true +)
}

sp {chunk-predicate-structure*elaborate*gtype
    (state <s> ^name chunk-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^gtype <gtype> ^<gtype> <a>)
    -->
    (<s> ^gtype <gtype> + ^<gtype> <a> +)
}

sp {chunk-predicate-structure*elaborate*predicate-handle
    (state <s> ^name chunk-predicate-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^gtype <gtype> ^predicate-handle <handle>)
    -->
    (<s> ^gtype <gtype> + ^retrieve-handle <handle> +)
}

sp {chunk-predicate-structure*impasse*actiongoal
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^retrieve-handle <handle>)
    -->
    (<s> ^name chunk-predicate-impasse + ^linkstate <ss> + ^handle <handle> +
           ^gtype <t> +)
}

sp {chunk-predicate-structure*impasse*actiongoal2323
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^retrieve-handle <handle>)
    -->
    (force-learn <s>)
}

sp {chunk-predicate-structure*impasse
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^<t> <a>)
    -->
    (force-learn <s>)
}

sp {chunk-predicate-structure*impasse454
    (state <s> ^choices none -^world <w*1> ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> ^gtype <t> ^<t> <a>)
    -->
    (<s> ^name chunk-predicate-impasse + ^linkstate <ss> + ^condition <co> +
           ^<t> <a> + ^gtype <t> +)
}

sp {chunk-predicate-impasse*propose*retrieve-predicate-structure*action
    (state <s> ^name chunk-predicate-impasse -^action <a*1> -^heuristic <h*1>
          -^failure <f*1> -^goal <g*1> ^gtype <gtype> ^handle <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-predicate-structure + ^handle <name> +)
}

sp {chunk-predicate-impasse*propose*retrieve-predicate-structure
    (state <s> ^name chunk-predicate-impasse -^handle <h*1> -^unknown <u*1>
          ^gtype <gtype> ^<gtype> <g*1>)
    (<g*1> ^condition <co>)
   -{ (<s> ^predicate <p*1>)
      (<p*1> ^link <co>)}
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-predicate-structure + ^condition <co> +
           ^handle <name> +)
}

sp {chunk-predicate-impasse*propose*complete
    (state <s> ^name chunk-predicate-impasse)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {chunk-predicate-impasse*apply*complete
    (state <s> ^name chunk-predicate-impasse -^handle <h*1> ^operator <o*1>
          ^gtype <gtype> ^predicate <p> ^<gtype> <g*1> ^superstate <ss>)
    (<o*1> ^name complete)
    (<p> ^link <co>)
    (<co> ^type concept ^attribute predicate)
    (<g*1> ^condition <co>)
    -->
    (<ss> ^predicate <p> + ^gtype predicate +)
}

sp {chunk-predicate-impasse*apply*complete*action
    (state <s> ^name chunk-predicate-impasse ^operator <o*1>
          ^gtype { << action goal failure heuristic >> <type> } ^handle <h>
          ^superstate <ss> ^<type> <p>)
    (<o*1> ^name complete)
    -->
    (<ss> ^<type> <p> +)
}

sp {chunk-game-structure*elaborate*predicate-handle
    (state <s> ^name chunk-game-structure ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^predicate-handle <handle>)
    -->
    (<s> ^retrieve-game <handle> +)
}

sp {chunk-puzzle-structure*impasse*actiongoal
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <ss>)
    (<ss> -^opponent <o*1> ^retrieve-game <handle>)
    -->
    (force-learn <s>)
    (<s> ^name chunk-puzzle-impasse + ^linkstate <ss> + ^handle <handle> +)
}

sp {chunk-puzzle-impasse*propose*retrieve-predicate-structure*action
    (state <s> ^name chunk-puzzle-impasse -^retrieve-handle <r*1>
          ^handle <name>)
    -->
    (<s> ^operator <o> + ^operator <o> >)
    (<o> ^name retrieve-game-structure + ^handle <name> +)
}

sp {retrieve-game-structure*elaborate*smem-query
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <s*2>)
    (<s*1> ^command <c>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^handle <handle>)
    -->
    (<c> ^query <cue> +)
    (<cue> ^handle <handle> + ^retrieve game +)
}

sp {chunk-puzzle-impasse*apply*complete
    (state <s> ^name chunk-puzzle-impasse ^operator <o*1> ^retrieve-handle <r>
          ^superstate <ss>)
    (<o*1> ^name complete)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {chunk-puzzle-impasse*propose*complete
    (state <s> ^name chunk-puzzle-impasse)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {retrieve-game-structure*apply*complete
    (state <s> ^name retrieve-game-structure ^smem <s*1> ^superstate <ss>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <pred>)
    (<pred> ^retrieve-handle <r> -^opponent <r>)
    -->
    (<ss> ^retrieve-handle <r> +)
}

sp {learn-heuristic*chunk-parameters*propose*new-operator*snc*t71-4
    (state <s1> ^gtype action ^list <l1> ^action <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^verb-structure <v*1>)
    (<p2> ^tested calculate1 ^tested calculate2 ^tested calculate5
          ^tested calculate4 ^tested calculate6 ^tested calculate3 ^set <s2>)
    (<v*1> ^1 <vs>)
    (<vs> ^2 <v2> ^1 <v1>)
    (<s2> ^<v1> <ob1> ^<v2> <ob2>)
    -->
    (<p1> ^instance <s4> +)
    (<s4> ^1 <ob1> + ^2 <ob2> +)
}

sp {all-states*elaborate*linkstate
    (state <s> ^superstate <ts>)
    (<ts> ^linkstate <ss>)
    -->
    (<s> ^linkstate <ss> +)
}

sp {resolve-conditions*elaborate*type
    (state <s> ^name resolve-conditions)
    -->
    (<s> ^type action + ^type goal + ^type failure +)
}

sp {resolve-conditions*elaborate*nlp-set
    (state <s> ^name resolve-conditions ^linkstate <ts>)
    (<ts> ^{ << action goal predicate failure heuristic >> <type> } <t*1>)
    (<t*1> ^condition <c>)
    -->
    (<s> ^condition <c> +)
}

sp {resolve-conditions*propose*retrieve-predicate-structure
    (state <s> ^name learn-predicate ^gtype <gtype> ^<gtype> <g>)
    (<g> ^condition <co>)
   -{ (<s> ^predicate <p*1>)
      (<p*1> ^link <co>)}
    (<co> ^type concept ^attribute predicate ^name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> >)
    (<o> ^name chunk-predicate-structure + ^<gtype> <g*1> + ^gtype <gtype> +)
    (<g*1> ^condition <co> +)
}

sp {resolve-conditions*propose*learn-condition
    (state <s> ^name resolve-conditions ^condition <co>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name learn-condition + ^condition <co> +)
}

sp {resolve-conditions*disprefer*concepts
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^type concept)
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*disprefer*input-args
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^attribute input-arg)
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*prefer*learn-condition*childresults
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <a*2> } <c1>)
   -{ (<c1> ^result <r*1>)
      (<r*1> ^set <s*1>)
      (<s*1> ^instance <i*1>)
      (<i*1> ^1 <v*1>)}
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*prefer*learn-condition*childresults-under
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <a*2> } <c1>)
   -{ (<c1> ^result <r*1>)
      (<r*1> ^set <s*1>)
      (<s*1> ^instance <i*1>)
      (<i*1> ^1 <v*1>)
      (<v*1> ^<something> <s*2>)}
    (<c1> -^return-type number)
    -->
    (<s> ^operator <o> <)
}

sp {resolve-conditions*prefer*learn-condition*reject-complete
    (state <s> ^name resolve-conditions ^operator <o> + ^linkstate <ls>)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <a>)
   -{ (<a> -^<something> <s*2>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^operator <o> -)
}

sp {resolve-conditions*prefer*learn-condition*reject-complete*number
    (state <s> ^name resolve-conditions ^operator <o> +)
    (<o> ^name learn-condition ^condition <co>)
    (<co> ^return-type number ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <i*1>)
    (<i*1> ^1 <something>)
    -->
    (<s> ^operator <o> -)
}

sp {learn-condition*elaborate*conditions
    (state <s> ^name learn-condition ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^condition <co>)
    -->
    (<s> ^condition <co> +)
}

sp {learn-condition*impasse
    (state <s> ^choices none ^impasse no-change ^attribute state
          ^superstate <s*1> ^superstate <s*2>)
    (<s*1> ^name learn-condition)
    (<s*2> ^condition <co>)
    -->
    (<s> ^name learn-condition-impasse + ^condition <co> +)
}

sp {learn-condition-impasse*propose*with-attribute
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type attribute ^args <args> ^negative <bool> ^parameter <p>
          ^name <name> ^attribute <attr>)
    (<args> ^1 <a1>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args2> + ^name with-attribute + ^negative <bool> +
           ^parameter <p> +)
    (<args2> ^3 <a2> + ^2 <a3> + ^1 <a1> +)
    (<a2> ^name number + ^args <ag2> + ^rtype single + ^result <r*1> +
           ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <a22> +)
    (<a22> ^1 <attr> +)
    (<a3> ^name number + ^args <ag3> + ^rtype single + ^result <r*2> +
           ^return-type number +)
    (<r*2> ^set <s*2> +)
    (<s*2> ^instance <a33> +)
    (<a33> ^1 <name> +)
}

sp {learn-condition-impasse*propose*with-attribute*primitive-object
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^name object ^type attribute ^attribute primitive ^args <args>
          ^negative <bool> ^parameter <p>)
    (<args> -^1 <a1>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args2> + ^name with-attribute + ^negative <bool> +
           ^parameter <p> +)
}

sp {learn-condition-impasse*propose*top-pair
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type state-pair ^args <args> ^negative <bool> ^parameter <p>
          ^name <name> ^attribute <attr>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name top-pair + ^type <name> + ^attribute <attr> +
           ^negative <bool> + ^parameter <p> +)
}

sp {learn-condition-impasse*propose*function
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type function ^function <func> ^args <args> ^negative <bool>
          ^parameter <p> ^name <name>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name <func> + ^type <name> + ^negative <bool> +
           ^parameter <p> +)
}

sp {learn-condition-impasse*propose*attribute-of
    (state <s> ^name learn-condition-impasse ^superstate <ss>)
    (<ss> ^condition <co>)
    (<co> ^type attribute-of ^args <args> ^negative <bool> ^parameter <p>
          ^name <type>)
    -->
    (<ss> ^operator <op> + ^operator <op> =)
    (<op> ^args <args> + ^name attribute-of + ^type <type> +
           ^negative <bool> + ^parameter <p> +)
}

sp {attribute-of*propose*complete
    (state <s> ^name attribute-of ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {attribute-of*apply*complete
    (state <s> ^name attribute-of ^operator <op> ^instance <s1>
          ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {attribute-of*numeric-evaluate*value*instance
    (state <s> ^name attribute-of ^superstate <s*1> ^superstate <s*2>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <p*1> ^type <type>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> -^rtype set ^result <r*2>)
    (<r*2> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*2>)
    (<p*2> ^<type> <value>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <value> + ^2 <obja> +)
}

sp {with-attribute*elaborate*results*0-param*primitive
    (state <s> ^name with-attribute ^linkstate <l*1> ^superstate <s*1>
          ^superstate <s*2>)
    (<l*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^args <args>)
    (<args> -^1 <a1> -^2 <v*1>)
    (<o*1> ^object <obja>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {with-attribute*elaborate*results*1-param
    (state <s> ^name with-attribute ^superstate <s*1> ^superstate <s*2>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^args <args> ^parameter <pp>)
    (<pp> ^num { < 2 <n*1> })
    (<args> ^3 <a2> ^2 <a3> ^1 <a1>)
    (<a1> ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<obja> ^predicates <p*1>)
    (<a2> ^result <r*2>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <attr>)
    (<a3> ^result <r*3>)
    (<r*3> ^set <s*5>)
    (<s*5> ^instance <i*3>)
    (<i*3> ^1 <name>)
    (<p*1> ^<attr> <name>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {with-attribute*propose*complete
    (state <s> ^name with-attribute ^instance <e>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <e> +)
}

sp {with-attribute*apply*complete*instance
    (state <s> ^name with-attribute ^operator <op> ^superstate <s*1>)
    (<op> ^name complete ^instance <o>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <o> +)
}

sp {top-pair*perference*complete*diff
    (state <s> ^name top-pair ^operator <o1> +)
    (<o1> ^name complete ^instance <instance>)
    -->
    (<s> ^operator <o1> >)
}

sp {top-pair*propose*complete
    (state <s> ^name top-pair ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {top-pair*apply*complete
    (state <s> ^name top-pair ^operator <op> ^instance <s1> ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {top-pair*with-type*2param*no-set
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*1>
          ^superstate <s*2>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^instance <instance1> ^handle <c3>)
    (<instance1> ^2 <objb> ^1 <obja>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^negative false ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 <objb>)
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> +)
}

sp {top-pair*with-type*1param*no-set*negative
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*1>
          ^superstate <s*2>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^1 <a1> ^2 <a2>)
    (<a1> -^rtype set ^result <r*1>)
    (<p*2> ^num { < 2 <n*1> })
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
   -{ (<pa> ^instance <instance>)
      (<instance> ^1 <obja> ^2 <objb>)
      (<a2> ^result <r*2>)
      (<r*2> ^set <s*4>)
      (<s*4> ^instance <i*2>)
      (<i*2> ^1 <objb>)}
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> +)
}

sp {top-pair*with-type*2param*no-set*negative
    (state <s> ^name top-pair ^linkstate <ls> ^superstate <s*1>
          ^superstate <s*2>)
    (<ls> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <pa>)
    (<pa> ^handle <c3>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^rtype single)
    (<s*2> ^operator <o>)
    (<o> ^negative true ^type <c3> ^args <args> ^parameter <p*2>)
    (<args> ^num 2 ^2 <a2> ^1 <a1>)
    (<p*2> ^num 2)
    (<a2> -^rtype set ^result <r*2>)
    (<a1> -^rtype set ^result <r*1>)
    (<r*1> ^set <s*3>)
    (<s*3> ^instance <i*1>)
    (<i*1> ^1 <obja>)
    (<r*2> ^set <s*4>)
    (<s*4> ^instance <i*2>)
    (<i*2> ^1 { <> <obja> <objb> })
   -{ (<pa> ^instance <instance1>)
      (<instance1> ^2 <objb> ^1 <obja>)}
    -->
    (<s> ^instance <instance> +)
    (<instance> ^1 <obja> + ^2 <objb> +)
}

sp {soar-count*propose*complete
    (state <s> ^name soar-count ^instance <instance>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete + ^instance <instance> +)
}

sp {soar-count*apply*complete
    (state <s> ^name soar-count ^operator <op> ^instance <s1>
          ^superstate <s*1>)
    (<op> ^name complete ^instance <s1>)
    (<s*1> ^condition <c*1>)
    (<c*1> ^result <r*1>)
    (<r*1> ^set <res>)
    -->
    (<res> ^instance <s1> +)
}

sp {soar-count*elaborate*rhs*2params
    (state <s> ^name soar-count ^linkstate <ls> ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name soar-count ^args <args> ^parameter <p*1>)
    (<args> ^num 1 ^2 <a1>)
    (<p*1> ^num 2)
    (<a1> ^rtype set ^result <r>)
    (<r> ^set <s*2>)
    (<s*2> ^instance <i*1>)
    (<i*1> ^1 <set>)
   -{ (<set> -^<something> <s*3>)
      (state <ls> ^<a*1> <v*1>)}
    -->
    (<s> ^instance <p> +)
    (<p> ^2 <set> + ^1 (size <set>) +)
}

sp {learn-predicate*elaborate*diff-table
    (state <s> ^name learn-predicate)
    -->
    (<s> ^diff-table <dtt> +)
    (<dtt> ^diff <d1> + ^diff <d2> +)
    (<d1> ^pair <p> + ^pair <p1> + ^pair <p2> + ^pair <p3> + ^pair <p4> +
           ^result 1 +)
    (<p> ^num 1 + ^num 2 +)
    (<p1> ^num 3 + ^num 2 +)
    (<p2> ^num 4 + ^num 3 +)
    (<p3> ^num 1 + ^num 0 +)
    (<p4> ^num 5 + ^num 4 +)
    (<d2> ^pair <pa> + ^pair <pa2> + ^pair <p21> + ^pair <p22> + ^result 2 +)
    (<pa> ^num 1 + ^num 3 +)
    (<pa2> ^num 0 + ^num 2 +)
    (<p21> ^num 4 + ^num 2 +)
    (<p22> ^num 5 + ^num 3 +)
}

sp {game-search*elaborate*diff-table
    (state <s> ^name game-search)
    -->
    (<s> ^diff-table <dtt> +)
    (<dtt> ^diff <d1> + ^diff <d2> +)
    (<d1> ^pair <p> + ^pair <p1> + ^pair <p2> + ^pair <p3> + ^pair <p4> +
           ^result 1 +)
    (<p> ^num 1 + ^num 2 +)
    (<p1> ^num 3 + ^num 2 +)
    (<p2> ^num 4 + ^num 3 +)
    (<p3> ^num 1 + ^num 0 +)
    (<p4> ^num 5 + ^num 4 +)
    (<d2> ^pair <pa> + ^pair <pa2> + ^pair <p21> + ^pair <p22> + ^result 2 +)
    (<pa> ^num 1 + ^num 3 +)
    (<pa2> ^num 0 + ^num 2 +)
    (<p21> ^num 4 + ^num 2 +)
    (<p22> ^num 5 + ^num 3 +)
}

sp {convert-parsed-format*elaborate*sentence
    (state <s> ^name convert-parsed-format ^superstate <s*1>)
    (<s*1> ^operator <sop>)
    (<sop> ^structure <t>)
    -->
    (<s> ^sentence <t> +)
}

sp {convert-parsed-format*elaborate*only-parameter
    (state <s> ^name convert-parsed-format ^sentence <s*1>)
    (<s*1> ^{ << if-subclause then-subclause subclause >> <a*1> } <c>)
    (<c> ^predicate <p>)
    (<p> ^item-type <type> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*learning-predicate
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <dc>)
    (<dc> ^learning-predicate <np> ^learn-link <ll>)
    -->
    (<s> ^learning-predicate <np> + ^learn-link <ll> +)
}

sp {convert-parsed-format*elaborate*input-object
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^input-object-1 <np>)
    -->
    (<s> ^input-object-1 <np> +)
}

sp {convert-parsed-format*elaborate*input-object-2
    (state <s> ^name convert-parsed-format ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^input-object-2 <np>)
    -->
    (<s> ^input-object-2 <np> +)
}

sp {convert-parsed-format*elaborate*object-count
    (state <s> ^name convert-parsed-format)
    -->
    (<s> ^object-count 1 + ^action-count 1 + ^nlp-set <nps> +)
    (<nps> ^verb-structure <vs> +)
}

sp {convert-parsed-format*elaborate*sentence*subclause
    (state <s> ^name convert-parsed-format ^sentence <s2>)
    -->
    (<s> ^clause <s2> +)
}

sp {convert-parsed-format*elaborate*clause*subclause
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << if-subclause subclause then-subclause >> <a*1> } <s1>)
    -->
    (<s> ^clause <s1> +)
}

sp {convert-parsed-format*elaborate*arg1*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 2 >> <a*1> } <p>)
    (<p> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*predicate-is-predicate
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg1 <p> ^predicate <pp>)
    (<p> -^handle more-than1 ^item-type predicate)
    (<pp> -^handle more-than1 ^item-type predicate)
    -->
    (<c> ^formatted true +)
    (<s> ^predicate <p> + ^predicate <pp> +)
    (<p> ^equal-to <pp> +)
    (<pp> ^equal-to <p> +)
}

sp {convert-parsed-format*elaborate*predicate*modifier
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^modifier <m> ^arg1 <p> ^predicate <pp>)
    -->
    (<pp> ^modifier <m> +)
}

sp {convert-parsed-format*elaborate*predicate*number*attribute
    (state <s> ^name convert-parsed-format ^parameter <c>)
    (<c> ^formatted <f2> ^parameter-index <id2> ^predicates <p*1>)
    (<p*1> ^number <num>)
    -->
    (<s> ^predicate <p> + ^predicate <pp> +)
    (<p> ^property <p*2> + ^handle <num> + ^equal-to <pp> +)
    (<p*2> ^handle number +)
    (<pp> ^handle of1 + ^2 <p2> + ^equal-to <p> +)
    (<p2> ^2 <c> + ^handle number1 +)
}

sp {convert-parsed-format*elaborate*predicate-objects
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle of1 ^2 <p2>)
    (<p2> ^2 <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*predicate-objects*of*second
    (state <s> ^name convert-parsed-format ^predicate <c>)
    (<c> ^handle of1 ^2 <r>)
    (<r> ^handle <name> ^2 <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*arg1*relation*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 >> <a*1> } <a>)
    (<a> ^2 <p>)
    (<p> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*arg1*of-concept*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^{ << arg1 arg2 >> <a*1> } <a>)
    (<a> ^handle of1 ^2 <p>)
    -->
    (<s> ^predicate <a> +)
}

sp {convert-parsed-format*elaborate*parameter*relation*parameter
    (state <s> ^name convert-parsed-format ^parameter <p>)
    (<p> ^relation <r>)
    (<r> ^{ << 2 3 >> <a*1> } <pp>)
    (<pp> ^predicates <p*1>)
    (<p*1> ^category <type>)
    -->
    (<s> ^parameter <pp> +)
}

sp {convert-parsed-format*elaborate*arg2*parameter
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^predicate <p*1>)
    (<p*1> ^2 <p>)
    (<p> ^predicates <p*2>)
    (<p*2> ^category <type>)
    -->
    (<s> ^parameter <p> +)
}

sp {convert-parsed-format*elaborate*arg2*parameter*indef
    (state <s> ^name convert-parsed-format ^clause <c>
          -^{ << input-object-1 input-object-2 output-object-1 >> <a*1> } <p>)
    (<c> ^predicate <p*1>)
    (<p*1> ^2 <p>)
   -{ (<p> ^predicates <p*3>)
      (<p*3> ^number <n*1>)}
   -{ (<s> ^clause <c2>)
      (<c2> ^{ << arg1 arg2 >> <a*2> } <p>)}
   -{ (<s> ^parameter <pp>)
      (<pp> ^relation <r>)
      (<r> ^2 <p>)}
   -{ (<s> ^parameter <pp>)
      (<pp> ^relation <r>)
      (<r> ^3 <p>)}
   -{ (<p> ^relation <rr>)
      (<rr> ^2 <v*1>)}
   -{ (<s> ^clause { <> <c> <c3> })
      (<c3> ^predicate <p*4>)
      (<p*4> ^2 <p>)}
   -{ (<s> ^clause { <> <c> <c3> })
      (<c3> ^predicate <p*5>)
      (<p*5> ^3 <p>)}
   -{ (<s> ^clause { <> <c> <c4> })
      (<c4> ^arg2 <a*3> ^action <act>)
      (<a*3> ^2 <p>)}
   -{ (<s> ^clause { <> <c> <c4> })
      (<c4> ^arg1 <p> ^action <act>)}
    (<p> ^item-type <type> ^predicates <p*2>)
    (<p*2> ^category <type>)
    -->
    (<s> ^indef <p> +)
}

sp {prefer*create-object*lower*hanlde*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +
          -^input-object-1 <p> -^input-object-2 <p> -^output-object-1 <p>)
    (<o1> ^name create-object ^parameter <p*1>)
    (<o2> ^name create-object ^parameter <p>)
    (<p*1> ^handle <h1>)
    (<p> ^handle { > <h1> <h2> })
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-clause)
    (<o2> ^name complete)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-predicate*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-predicate)
    (<o2> ^name complete)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*of*handle-predicate*over*handle-predicate
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-predicate ^predicate <p*1>)
    (<p*1> ^handle of1)
   -{ (<o2> ^predicate <p*2>)
      (<p*2> ^handle of1)}
    (<o2> ^name handle-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*handle-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-clause)
    (<o2> ^name handle-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-clause*over*handle-clause-clause*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-clause ^parameter <p*1>)
    (<o2> ^name handle-clause ^clause <c*1>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*handle-action*over*complete*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name handle-action)
    (<o2> ^name complete)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-clause*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name create-object)
    (<o2> ^name handle-clause)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-action*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name create-object)
    (<o2> ^name handle-action)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*handle-predicate*convert-parsed-format
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +)
    (<o1> ^name create-object)
    (<o2> ^name handle-predicate)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*create-object*over*input-object
    (state <s> ^name convert-parsed-format ^operator <o1> +
          ^{ << output-object-1 input-object-2 input-object-1 >> <a*1> } <p>)
    (<o1> ^name create-object ^parameter <p>)
    -->
    (<s> ^operator <o1> >)
}

sp {prefer*create-object*over*create-object*input-object
    (state <s> ^name convert-parsed-format ^operator <o1> + ^operator <o2> +
          ^input-object-2 <p2>
          ^{ << output-object-1 input-object-1 >> <a*1> } <p>)
    (<o1> ^name create-object ^parameter <p>)
    (<o2> ^name create-object ^parameter <p2>)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {convert-parsed-format*propose*create-object
    (state <s> ^name convert-parsed-format ^parameter <c>)
    (<c> -^formatted <f*1>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name create-object + ^parameter <c> +)
}

sp {convert-parsed-format*apply*create-object*increment-object-count
    (state <s> ^name convert-parsed-format ^operator <o> -^indef <c>
          ^object-count <oc>)
    (<o> ^name create-object ^parameter <c>)
    (<c> -^parameter-index <p*1>)
    -->
    (<c> ^parameter-index <oc> +)
    (<s> ^object-count (+ 1 <oc>) + ^object-count <oc> -)
}

sp {create-object*elaborate*parameter*input-object
    (state <s> ^name create-object ^superstate <s*1> ^superstate <s*2>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^parameter <c>)
    (<c> ^parameter-index <oc>)
    (<s*1> ^{ << input-object-2 input-object-1 >> <a*1> } <c>)
    -->
    (<s> ^condition <co> + ^last-condition <co> +)
    (<co> ^args <A67> + ^attribute input-arg + ^name object +
           ^negative false + ^parameter <P628> + ^rtype single +)
    (<P628> ^1 <para> +)
    (<para> ^param-id <oc> +)
}

sp {create-object*elaborate*parameter
    (state <s> ^name create-object ^superstate <s*3>)
    (<s*3> ^operator <o*1>)
    (<o*1> ^parameter <c>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^input-object-1 <c>)}
   -{ (<s> ^superstate <s*2>)
      (<s*2> ^input-object-2 <c>)}
    -->
    (<s> ^parameter <c> +)
}

sp {create-object*elaborate*category
    :o-support
    (state <s> ^name create-object ^parameter <p*1>)
    (<p*1> ^predicates <c>)
    (<c> ^category { <> object <cat> })
    -->
    (<s> ^condition <c1> + ^last-condition <c1> +)
    (<c1> ^name <cat> + ^parameter <p> + ^type attribute +
           ^attribute category + ^rtype single +)
}

sp {create-object*elaborate*cateogy*object
    :o-support
    (state <s> ^name create-object ^parameter <p*1>)
    (<p*1> ^predicates <c>)
    (<c> ^category { << object >> <cat> })
    -->
    (<s> ^condition <c1> + ^last-condition <c1> +)
    (<c1> ^name <cat> + ^parameter <p> + ^type attribute +
           ^attribute primitive + ^rtype single +)
}

sp {create-object*propose*unary-predicate
    (state <s> ^name create-object ^parameter <c>)
    (<c> ^predicates <p>)
    (<p>
          ^{ <> category <> quantified <> property-modifier <> dialog-object <> value <> handle <> type <> visible <> visibility <> multiple <> number <att> } { <> linear <val> })
   -{ (<s> ^condition <c*1>)
      (<c*1> ^name <val>)}
   -{ (<p> ^<att> { << moved >> <val> })
      (<s> ^moved <mov>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name unary-predicate + ^attribute <att> + ^value <val> +)
}

sp {preference*create-object*dispref*unary-predicate
    (state <s> ^name create-object ^operator <o> +)
    (<o> ^name unary-predicate ^attribute { << relation property >> <a*1> })
    -->
    (<s> ^operator <o> <)
}

sp {preference*create-object*prefer*unary-predicate*over*complete
    (state <s> ^name create-object ^operator <o> + ^operator <o2> +)
    (<o> ^name unary-predicate)
    (<o2> ^name complete)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {create-object*elaborate*condition*learned-predicate
    (state <s> ^name create-object ^operator <o> ^last-condition <cond>
          ^parameter <c>)
    (<o> -^value moved ^name unary-predicate ^attribute property ^value <val>)
   -{ (<s> ^property-modifier <m>)
      (<m> ^handle negation ^modifying <m*1>)
      (<m*1> ^handle <val>)}
    -->
    (<s> ^condition <co> + ^last-condition <cond> - ^last-condition <co> +)
    (<co> ^name <val> + ^parameter <p> + ^type concept +
           ^attribute predicate + ^args <a> + ^rtype single +)
    (<a> ^1 <cond> +)
}

sp {create-object*propose*complete
    (state <s> ^name create-object ^last-condition <co>)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name complete +)
}

sp {create-object*apply*complete*remove-rtype
    (state <s> ^name create-object ^operator <o*1> ^last-condition <cond>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<cond> ^rtype <rtype>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    -->
    (<s> ^complete true +)
    (<cond> ^rtype <rtype> -)
}

sp {create-object*apply*complete*not-indef-parameter*set
    (state <s> ^name create-object ^operator <o*1> ^last-condition <cond>
          ^superstate <s*1>)
    (<o*1> ^name complete)
    (<cond> ^parameter <p>)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
    (<c> -^relation <r*1> ^parameter-index <id> ^predicates <p*1>)
    (<p*1> ^number { <> singular <n*1> })
    -->
    (<p> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type set +)
}

sp {create-object*apply*complete*multiple
    (state <s> ^complete true ^name create-object ^operator <o*1>
          ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^relation <r>)
      (<r> -^handle between)}
    (<c> ^predicates <p*1>)
    (<p*1> ^multiple true)
    -->
    (<c> ^formatted <cond> +)
    (<cond> ^rtype set +)
}

sp {create-object*apply*complete*single
    (state <s> ^complete true -^moved <m*1> ^name create-object
          ^operator <o*1> ^last-condition <cond> ^superstate <s*1>)
    (<o*1> ^name complete)
    (<s*1> ^operator <o*2>)
    (<o*2> ^parameter <c>)
   -{ (<c> ^predicates <p*1>)
      (<p*1> ^multiple true)}
   -{ (<c> ^predicates <p*2> ^relation <r*1>)
      (<p*2> ^number { <> singular <n*1> })}
    -->
    (<c> ^formatted <cond> +)
    (<cond> ^rtype single +)
}

sp {convert-parsed-format*propose*handle-action
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> ^arg1 <a1> -^arg1 { <> <a1> <a3> } ^action <a> ^arg2 <a2>)
    (<a> -^formatted <f*1>)
   -{ (<s> ^clause <c*1>)
      (<c*1> ^action { <> <a> <a4> })
      (<a4> -^handle is1)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-action + ^action <a> + ^arg1 <a1> + ^arg2 <a2> +)
}

sp {convert-parsed-format*apply*handle-action
    (state <s> ^name convert-parsed-format ^operator <o> ^action-count <an>
          ^nlp-set <nps> ^superstate <ss>)
    (<o> -^arg1b <a*1> ^name handle-action ^arg2 <a2> ^arg1 <a1> ^action <a>)
    (<nps> ^verb-structure <va2>)
    (<a1> ^parameter-index <pa>)
    (<a2> ^handle <rname> ^2 <obj2>)
    (<obj2> ^parameter-index <pa2>)
    (<a> ^handle <name>)
    -->
    (<s> ^action-count <an> - ^action-count (+ <an> 1) +)
    (<ss> ^verb-structure <va2> +)
    (<va2> ^<an> <va> +)
    (<va> ^verb-name <name> + ^verb-prep <rname> + ^1 <pa> + ^2 <pa2> +)
    (<a> ^formatted true +)
}

sp {convert-parsed-format*propose*handle-predicate*parameter
    (state <s> ^name convert-parsed-format ^predicate <p>)
    (<p> -^formatted <f*1> -^handle of1 ^handle <name>)
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-predicate + ^predicate <p> +)
}

sp {convert-parsed-format*propose*handle-predicate*attribute-of
    (state <s> ^name convert-parsed-format ^predicate <p>)
    (<p> -^formatted <f*1> ^handle of1 ^2 <v*1>)
    (<v*1> ^handle <name>)
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-predicate + ^predicate <p> +)
}

sp {convert-parsed-format*apply*handle-predicate
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> -^handle number1 ^handle <name> ^2 <c2>)
   -{-{ (<s> ^superstate <s*1>)
        (<s*1> ^world <w*1>)
        (<w*1> ^objects <o*1>)
        (<o*1> ^object <o*2>)
        (<o*2> ^predicates <p*1>)
        (<p*1> ^<name> <n*1>)}
      (state <s> ^<a*1> <v*1>)}
    (<c2> ^formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*equal-exists
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> ^handle of1 ^2 <p2> ^equal-to <eq>)
    (<p2> -^handle number1 ^handle <name> ^2 <c2>)
    (<eq> ^formatted <oc>)
    (<oc> ^parameter <p*1>)
    (<c2> ^formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <id1>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type attribute-of +
           ^rtype <rtype2> + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id1> + ^type <rtype2> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-predicate*number*equal
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-predicate ^predicate <c>)
    (<c> -^2 <v*1> ^equal-to <e*1> ^handle <name> ^property <p*1>)
    (<e*1> ^formatted <oc>)
    (<oc> ^parameter <p*2>)
    (<p*2> ^1 <v*2>)
    (<v*2> ^param-id <id1>)
    (<p*1> ^handle number)
    -->
    (<c> ^formatted <n> +)
    (<s> ^nlp <n> +)
    (<n> ^name number + ^result <r*1> + ^args <a> + ^parameter <para> +
           ^rtype single + ^return-type number +)
    (<r*1> ^set <s*1> +)
    (<s*1> ^instance <i> +)
    (<i> ^1 <name> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id1> + ^type single +)
}

sp {convert-parsed-format*apply*handle-predicate*count
    (state <s> ^name convert-parsed-format ^operator <o> ^object-count <oc>)
    (<o> ^name handle-predicate ^predicate <c>)
   -{ (<c> ^equal-to <e*1>)
      (<e*1> ^formatted <f*1>)}
    (<c> ^handle of1 ^2 <p2>)
    (<p2> ^handle number1 ^2 <c2>)
    (<c2> -^new-formatted <n*1> ^formatted <f2> ^parameter-index <id2>)
    (<f2> ^rtype <rtype2>)
    -->
    (<c> ^formatted <n> +)
    (<s> ^object-count <oc> - ^object-count (+ <oc> 1) + ^nlp <n> +)
    (<n> ^name count + ^args <a> + ^parameter <para> + ^type function +
           ^function soar-count + ^rtype single + ^return-type number +)
    (<a> ^2 <f2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <oc> + ^type single +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*propose*handle-clause*parameter
    (state <s> ^name convert-parsed-format ^parameter <p>)
    (<p> ^relation <r>)
    (<r> -^formatted <f*1> ^handle <name>)
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^parameter <p> +)
}

sp {convert-parsed-format*propose*handle-clause
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^formatted <f*1> ^predicate <p> ^arg1 <a*1>)
    (<p> -^handle of1 ^handle <name> ^2 <v*1>)
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^clause <c> +)
}

sp {convert-parsed-format*propose*handle-clause*attribute-of
    (state <s> ^name convert-parsed-format ^clause <c>)
    (<c> -^formatted <f*1> ^predicate <p> ^arg1 <a*1>)
    (<p> ^handle of1 ^2 <v*1>)
    (<v*1> ^handle <name>)
   -{ (<s> ^learn-link <l*1>)
      (<l*1> ^handle <name>)}
   -{ (<s> ^learning-predicate <l*2>)
      (<l*2> ^spelling <name>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name handle-clause + ^clause <c> +)
}

sp {convert-parsed-format*apply*handle-clause
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^clause <c>)
   -{ (<c> ^modifier <m*1>)
      (<m*1> ^handle negation)}
    (<c> ^predicate <r> ^arg1 <c1>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
    (<c1> ^formatted <p> ^parameter-index <id>)
    (<p> ^rtype <rtype>)
    (<c2> ^formatted <p2> ^parameter-index <id2>)
    (<p2> ^rtype <rtype2>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*negative
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
    (<c> ^modifier <m*1> ^predicate <r> ^arg1 <c1>)
    (<m*1> ^handle negation)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
    (<c1> ^formatted <p> ^parameter-index <id>)
    (<p> ^rtype <rtype>)
    (<c2> ^formatted <p2> ^parameter-index <id2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^negative true +
           ^type state-pair + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*negative*indef
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^clause <c>)
    (<c> ^modifier <m*1> ^predicate <r> ^arg1 <c1>)
    (<m*1> ^handle negation)
    (<r> -^3 <v*1> ^2 <c2> ^handle <name>)
    (<c2> -^parameter-index <p*1> ^formatted <p2>)
    (<p2> ^rtype <rtype2>)
    (<c1> ^formatted <p> ^parameter-index <id>)
    (<p> ^rtype <rtype>)
    -->
    (<c> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^negative true +
           ^type state-pair + ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*nortype
    (state <s> ^name convert-parsed-format ^operator <o> ^superstate <s*1>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> -^rtype <r*1> ^formatted <p> ^parameter-index <id> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<s*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p*2>)
    (<p*2> ^handle <name>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
    (<c2> ^formatted <p2> ^parameter-index <id2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<c1> ^new-formatted <n> +)
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type state-pair +
           ^attribute prepositions + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*apply*handle-clause*parameter*concept
    (state <s> ^name convert-parsed-format ^operator <o>)
    (<o> ^name handle-clause ^parameter <c1>)
    (<c1> ^formatted <p> ^parameter-index <id> ^relation <r>)
    (<p> ^rtype <rtype>)
    (<r> -^3 <v*1> ^handle <name> ^2 <c2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^world <w*1>)
      (<w*1> ^predicates <p*1>)
      (<p*1> ^predicate <p*2>)
      (<p*2> ^handle <name>)}
    (<c2> ^formatted <p2> ^parameter-index <id2>)
    (<p2> ^rtype <rtype2>)
    -->
    (<r> ^formatted true +)
    (<s> ^nlp <n> +)
    (<n> ^name <name> + ^args <a> + ^parameter <para> + ^type concept +
           ^attribute predicate + ^rtype <rtype> +)
    (<a> ^1 <p> + ^2 <p2> +)
    (<para> ^1 <para1> + ^2 <para2> +)
    (<para1> ^param-id <id> + ^type <rtype> +)
    (<para2> ^param-id <id2> + ^type <rtype2> +)
}

sp {convert-parsed-format*propose*complete
    (state <s> ^name convert-parsed-format)
    -->
    (<s> ^operator <op> + ^operator <op> <)
    (<op> ^name complete +)
}

sp {convert-parsed-format*apply*complete-flag
    (state <s> ^name convert-parsed-format ^operator <o*1> ^nlp <nlp>
          ^nlp-set <nps>)
    (<o*1> ^name complete)
    -->
    (<s> ^complete-flag true +)
}

sp {convert-parsed-format*apply*complete
    (state <s> ^name convert-parsed-format ^operator <o*1> ^nlp <nlp>
          ^nlp-set <nps>)
    (<o*1> ^name complete)
    -->
    (<nps> ^nlp <nlp> +)
}

sp {convert-parsed-format*apply*complete*superstate*copy
    (state <s> ^complete-flag true -^prefer <p*1> -^avoid <a*1>
          -^consider <c*1> ^name convert-parsed-format ^nlp-set <nps>
          ^operator <o*1> ^top-state <t*1> ^superstate <ss>)
   -{ (<s> ^nlp <nlp>)
      (<nps> -^nlp <nlp>)}
    (<o*1> ^name complete)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learn-link <l*1>)
    (<l*1> ^handle <name>)
    (<ss> ^gtype <type> ^<type> <a>)
    -->
    (<a> ^nlp-set <nps> + ^aname <name> +)
    (<nps> ^aname <name> +)
}

sp {game-search*elaborate*problem-space
    (state <s> ^simulated true ^name game-search ^dcount <dc>
          -^depth-limit <dc>)
    -->
    (<s> ^ntype action + ^ntype goal + ^ntype failure + ^gtype action +
           ^gtype failure + ^gtype heuristic +)
}

sp {game-search*elaborate*problem-space*bottom
    (state <s> ^simulated true ^name game-search ^depth-limit <dc>
          ^dcount <dc>)
    -->
    (<s> ^ntype action + ^ntype goal + ^ntype failure + ^gtype failure +)
}

sp {game-search*elaborate*operator
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name game-search ^list <l> ^depth-limit <dl> ^dcount <dc>
          ^game <name> ^current <g>)
    -->
    (<s> ^dcount <dc> + ^depth-limit <dl> + ^list <l> + ^problemspace games +
           ^desired <d> + ^current <g> + ^game <name> +)
    (<d> ^found true +)
}

sp {game-search*elaborate*goal
    (state <s> ^simulated true -^multiplayer true ^name game-search
          ^depth-limit <dc> ^dcount <dc>)
    -->
    (<s> ^gtype goal + ^goal-search-delay 1 +)
}

sp {game-search*increment-goal-delay
    (state <s> ^name game-search ^goal-search-delay { < 50 <d> })
    -->
    (<s> ^goal-search-delay (+ 1 <d>) +)
}

sp {game-search*elaborate*multiplayer
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^multiplayer <m>)
    -->
    (<s> ^multiplayer <m> +)
}

sp {game-search*elaborate*game
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^game <m>)
    -->
    (<s> ^game <m> +)
}

sp {game-search*elaborate*depth-limit
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^depth-limit <m>)
    -->
    (<s> ^depth-limit <m> +)
}

sp {game-search*elaborate*list
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^list <m>)
    -->
    (<s> ^list <m> +)
}

sp {game-search*elaborate*dcount
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^dcount <dc>)
    -->
    (<s> ^dcount (+ 1 <dc>) +)
}

sp {game-search*elaborate*problem-space*world
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^superstate <s*2>)
    (<s*2> ^world <world2>)
    -->
    (<s> ^problem-space <ps> +)
    (<ps> ^world <world> + ^name action + ^dont-copy-anything true +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {game-search*apply*simulate
    (state <s> ^name game-search ^operator <o> ^copy-objects-map <com>
          ^world <w*1>)
    (<o> ^type action ^verb-structure <v*1> ^parameters <p> ^name <cname>)
    (<w*1> ^predicates <p2>)
    (<p2> ^predicate <prep> ^predicate <prep2>)
    (<prep> ^handle below1 ^instance <instance>)
    (<prep2> ^handle on1 ^instance <instance2>)
    (<instance> ^2 <obja>)
    (<instance2> ^1 <obja>)
    (<com> ^<obj> <obja> ^<obj1> <objb>)
    (<obj> ^handle <ha>)
    (<p> ^<i1> <obj> ^<i2> <obj1>)
    (<v*1> ^<num> <v1>)
    (<v1> ^verb-prep on1 ^1 <i1> ^2 <i2>)
    -->
    (<prep> ^instance <instance> - ^instance <instance3> +)
    (<prep2> ^instance <instance2> - ^instance <instance4> +)
    (<instance3> ^1 <objb> + ^2 <obja> +)
    (<instance4> ^1 <obja> + ^2 <objb> +)
}

sp {game-search*elaborate*top-level*simulated
    (state <s> ^name game-search ^superstate <s*1>)
    (<s*1> ^name find-solution)
    -->
    (<s> ^simulated true +)
}

sp {game-search*elaborate*other-levels*simulated
    (state <s> ^name game-search ^operator <o>)
    (<o> ^type action ^duplicate-of <d*1>)
    -->
    (<s> ^simulated true +)
}

sp {game-search*elaborate*sub-conditions
    (state <s> ^name game-search ^gtype <type> ^<type> <t>)
    (<t> ^condition <co>)
    (<co> ^args <a*1>)
    (<a*1> ^{ << 1 2 3 4 5 6 7 8 9 10 >> <arg> } <cond>)
    (<cond> ^name <name>)
    -->
    (<t> ^condition <cond> +)
}

sp {game-search*elaborate*sub-conditions*predicate
    (state <s> ^name game-search ^gtype <type> ^<type> <t>)
    (<t> ^nlp-set <n*1>)
    (<n*1> ^conditions <cond>)
    -->
    (<t> ^condition <cond> +)
}

sp {game-search*elaborate*retrieve-game
    (state <s> ^name game-search ^game <m>)
    -->
    (<s> ^retrieve-game <m> +)
}

sp {game-search*elaborate*input-args
    (state <s> ^name game-search ^gtype <gtype> ^predicate <T5> ^<gtype> <g*1>)
    (<T5> ^condition <c> ^link <co> ^potential-args <P125>
          ^parameter-set <P124> ^nlp-set <nlps>)
    (<c> ^attribute input-arg ^rtype <rtype> ^parameter <p*1> ^result <r*2>)
    (<co> ^type concept ^attribute predicate ^args <args> ^name <name>)
    (<g*1> ^condition <co>)
    (<args> ^num { > 0 <n*1> } ^<a1> <c1>)
    (<nlps> ^aname <name>)
    (<p*1> ^1 <v*1>)
    (<v*1> ^param-id <a1>)
    (<c1> ^rtype <rtype> ^result <r*1>)
    (<r*1> ^set <s*1>)
    (<s*1> ^instance <in1>)
    (<r*2> ^set <res2>)
    -->
    (<res2> ^instance <in1> +)
}

sp {game-search*propose*default
    (state <s> ^name game-search)
   -{ (<s> ^action <a>)
     -{ (<a> ^parameter-set <p*1>)
        (<p*1> ^argnum <a*1>)}}
    -->
    (<s> ^operator <o1> +)
    (<o1> ^name default +)
}

sp {game-search*apply*default
    (state <s> ^name game-search -^multiplayer true -^dcount 0 ^operator <o*1>
          ^desired <d>)
    (<o*1> ^name default)
    -->
    (<s> ^partial-failure <d> +)
}

sp {game-search*apply*default*depth-limit-increase
    (state <s> ^dcount 0 ^multiplayer false ^name game-search ^operator <o*1>
          ^superstate <ss>)
    (<o*1> ^name default)
    (<ss> ^depth-limit <d>)
    -->
    (interrupt)
    (interrupt)(interrupt)
    (interrupt)(interrupt)(write (crlf) (+ <d> 1))
    (<ss> ^depth-limit <d> - ^depth-limit (+ <d> 1) +)
}

sp {selection*prefer*evaluate*action*over*default
    (state <s> ^name selection ^operator <o1> + ^operator <o2> +)
    (<o1> ^name evaluate-operator ^superoperator <s*1>)
    (<s*1> ^type action)
    (<o2> ^name evaluate-operator ^superoperator <s*2>)
    (<s*2> ^name default)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {setup-search*elaborate*tcn
    (state <s> ^name setup-search ^top-state <t*1> ^superstate <s*2>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^multiplayer <cg>)
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^multiplayer <cg> +)
}

sp {setup-search*elaborate*multiplayer
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^multiplayer <m> ^game-name <name>)
    -->
    (<s> ^multiplayer <m> +)
}

sp {setup-search*propose*find-solution
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> -^multiplayer <m*1> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-solution + ^game-name <name> +)
}

sp {setup-search*propose*find-solution2
    (state <s> ^name setup-search ^superstate <s*1>)
    (<s*1> ^operator <op>)
    (<op> ^multiplayer <m*1> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name find-solution + ^replay true + ^game-name <name> +)
}

sp {setup-search*elaborate*problem-space*predicate-structure
    (state <s> ^name setup-search ^top-state <t*1>)
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <p*1> +)
    (<p*1> ^world <world> +)
    (<world> ^source <world2> + ^copy-type deep +)
}

sp {finished-game-teaching*propose*setup-search
    (state <s> ^name finished-game-teaching ^top-state <t*1> ^superstate <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^handle <name>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^type game)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^game-name <name> +)
}

sp {finished-game-teaching*propose*setup-search*yes
    (state <s> ^name finished-game-teaching ^top-state <t*2> ^superstate <s*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^structure <s*1>)
      (<s*1> ^multiplayer true)}
    (<t*2> ^dialog-context <d*2>)
    (<d*2> ^structure <s*3>)
    (<s*3> ^handle <name>)
    (<s*2> ^operator <o*1>)
    (<o*1> ^response yes)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name setup-search + ^multiplayer false + ^game-name <name> +)
}

sp {find-solution*propose*game-search*elaborate*retrieve-game
    (state <s> ^name find-solution ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^game-name <name>)
    -->
    (<s> ^game <name> + ^retrieve-game <name> + ^gtype goal + ^gtype action +
           ^gtype failure + ^gtype heuristic +)
}

sp {find-solution*propose*game-search*elaborate*initial-depth-limit
    (state <s> ^name find-solution -^start-search-depth <s*1>
          ^retrieve-game <name>)
    -->
    (<s> ^depth-limit 1 +)
}

sp {find-solution*propose*game-search*elab-replay-true
    (state <s> ^name find-solution ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^replay true)
    -->
    (<s> ^chunked true + ^replay true +)
}

sp {find-solution*elaborate*problem-space*world
    (state <s> ^name find-solution ^top-state <t*1>)
    (<t*1> ^world <world2>)
    -->
    (<s> ^problem-space <p*1> +)
    (<p*1> ^world <world> +)
    (<world> ^source <world2> + ^copy-type shallow +)
}

sp {find-solution*propose*chunk-game
    (state <s> ^name find-solution -^chunked <c*1> -^found-action <f*1>
          ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <st>)
    (<st> ^handle <h>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-game + ^predicate-handle <h> +)
}

sp {find-solution*propose*chunk-game-structure
    (state <s> ^name find-solution -^retrieve-handle <r*1>
          -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <st>)
    (<st> ^handle <h>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-game-structure + ^predicate-handle <h> +)
}

sp {chunk-game*game-handle
    (state <s> ^name chunk-game ^top-state <t*1> ^smem <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*2> ^handle <gname>)
    (<s*1> ^command <sc>)
    -->
    (<s> ^game-struct <g> +)
    (<g> ^handle <gname> + ^retrieve game +)
}

sp {chunk-game*retrieve-handles
    (state <s> ^name chunk-game ^game-struct <g> ^top-state <t*1> ^smem <s*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*2>)
    (<s*1> ^command <sc>)
    (<s*2> ^{ << actions goals failures heuristics >> <a*1> } <v*1>)
    (<v*1> ^retrieve-handle <gname>)
    -->
    (<g> ^retrieve-handle <gname> +)
}

sp {fchunk-game*chunk-game-structure
    (state <s> ^name chunk-game ^game-struct <g> ^smem <s*1> ^superstate <ss>)
   -{ (<g> -^retrieve-handle <r*1>)
      (state <s> ^<a*1> <v*1>)}
    (<s*1> ^command <sc>)
    -->
    (<sc> ^store <g> +)
    (<ss> ^chunked true +)
}

sp {find-solution*propose*chunk-predicate-structure*action
    (state <s> ^name find-solution -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^actions <a*2>)
    (<a*2> ^retrieve-handle <h>)
   -{ (<s> ^action <a*1>)
      (<a*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype action +
           ^predicate-handle <h> +)
}

sp {find-solution*propose*chunk-predicate-structure*goal
    (state <s> ^name find-solution -^found-action <f*1> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^structure <s*1>)
    (<s*1> ^goals <g*2>)
    (<g*2> ^retrieve-handle <h>)
   -{ (<s> ^goal <g*1>)
      (<g*1> ^handle <h>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name chunk-predicate-structure + ^gtype goal +
           ^predicate-handle <h> +)
}

sp {find-solution*propose*game-search
    (state <s> ^name find-solution -^found-action <f*1> ^depth-limit <dl>
          ^action <a*1> ^goal <g*1> ^superstate <s*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name game-search + ^dcount 0 + ^depth-limit <dl> + ^list <l*1> +
           ^current <g> + ^game <name> +)
    (<l*1> ^game <g> +)
    (<g> ^game <name> + ^type action + ^type goal + ^type failure +
           ^type heuristic +)
}

sp {find-solution*elaborate*depth-limit-1-less
    (state <s> ^name find-solution ^depth-limit <dl>)
    -->
    (<s> ^depth-limit-1-less (- <dl> 1) +)
}

sp {find-solution*prefer*chunk-predicate-structure*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name game-learning-complete)
    (<o> ^name chunk-predicate-structure)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-game-structure*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name game-learning-complete)
    (<o> ^name chunk-game-structure)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-game-structure*over*chunk-predicate-structure
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name chunk-predicate-structure)
    (<o> ^name chunk-game-structure)
    -->
    (<s> ^operator <o> < <o2>)
}

sp {find-solution*prefer*chunk-game*over*chunk-predicate-structure
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name chunk-predicate-structure)
    (<o> ^name chunk-game)
    -->
    (<s> ^operator <o> < <o2>)
}

sp {find-solution*prefer*chunk-game*over*chunk-game-structure
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name chunk-game-structure)
    (<o> ^name chunk-game)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*prefer*chunk-game*over*game-learning-complete
    (state <s> ^name find-solution ^operator <o2> + ^operator <o> +)
    (<o2> ^name game-learning-complete)
    (<o> ^name chunk-game)
    -->
    (<s> ^operator <o> > <o2>)
}

sp {find-solution*propose*game-learning-complete*puzzle
    (state <s> ^name find-solution -^replay true -^found-action <f*1>
          ^superstate <s*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^finished-game-teaching true)}
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^multiplayer true)}
    (<s*2> ^operator <op>)
    (<op> ^game-name <name>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name game-learning-complete + ^type puzzle + ^game <name> +)
}

sp {find-solution*apply*game-learning-complete
    (state <s> ^name find-solution ^operator <o> ^top-state <t*1>
          ^top-state <t*2> ^top-state <t*3>)
    (<o> ^name game-learning-complete ^game <name> ^type <type>)
    (<t*1> ^dialog-context <dc>)
    (<t*2> ^interaction <i*1>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type learned-game + ^fields <f> +)
    (<f> ^game <name> + ^type <type> +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <de> +)
    (<de> ^type game + ^originator agent +)
    (<dc> ^finished-game-teaching true +)
}

sp {prefer*copy-relationships*over*copy-objects
    (state <s> ^name extract-state ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-relationships)
    (<o2> ^name copy-objects)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*copy-predicates
    (state <s> ^name extract-state ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-objects)
    (<o2> ^name copy-predicates)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-relationships*over*complete-state
    (state <s> ^name extract-state ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-relationships)
    (<o2> ^name complete-state)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-objects*over*complete-state
    (state <s> ^name extract-state ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-objects)
    (<o2> ^name complete-state)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {prefer*copy-predicates*over*complete-state
    (state <s> ^name extract-state ^operator <o1> + ^operator <o2> +)
    (<o1> ^name copy-predicates)
    (<o2> ^name complete-state)
    -->
    (<s> ^operator <o1> > <o2>)
}

sp {extract-state*elaborate*operator-attrs
    (state <s> ^name extract-state ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^name extract-state)
    -->
    (<s> ^relationships <rels> + ^object-set <objects> +
           ^predicate-set <preds> +)
}

sp {extract-state*propose*copy-relationships
    (state <s> ^name extract-state)
   -{ (<s> ^relationships <r*1>)
      (<r*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-relationships +)
}

sp {extract-state*apply*copy-relationships*default
    (state <s> ^name extract-state ^operator <o*1> ^relationships <rels>)
    (<o*1> ^name copy-relationships)
    -->
    (<rels> ^done true +)
}

sp {extract-state*apply*copy-relationships
    (state <s> ^name extract-state ^operator <o*1> ^relationships <rels>
          ^top-state <t*1>)
    (<o*1> ^name copy-relationships)
    (<t*1> ^world <w*1>)
    (<w*1> ^predicates <p*1>)
    (<p*1> ^predicate <p>)
    (<p> ^instance <instance3> ^handle <name>)
    (<instance3> -^3 <v*1> ^2 <idb> ^1 <ida>)
    -->
    (<rels> ^relations <r> +)
    (<r> ^name <name> + ^instance <instance> +)
    (<instance> ^1 <ida> + ^2 <idb> +)
}

sp {extract-state*propose*copy-objects
    (state <s> ^name extract-state)
   -{ (<s> ^object-set <o*1>)
      (<o*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-objects +)
}

sp {extract-state*apply*copy-objects*default
    (state <s> ^name extract-state ^operator <o*1> ^object-set <set>)
    (<o*1> ^name copy-objects)
    -->
    (<set> ^done true +)
}

sp {extract-state*apply*copy-objects
    (state <s> ^name extract-state ^operator <o*2> ^object-set <os>
          ^relationships <r*1> ^relationships <rels> ^top-state <t*1>)
    (<o*2> ^name copy-objects)
    (<r*1> ^relations <p>)
    (<p> ^instance <instance> ^name <name>)
    (<t*1> ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<instance> ^{ << 1 2 3 >> <a*1> } <obja>)
    (<o*1> ^object <obja>)
    -->
    (<os> ^object <obja> +)
}

sp {extract-state*propose*copy-predicates
    (state <s> ^name extract-state)
   -{ (<s> ^predicate-set <p*1>)
      (<p*1> ^done <d*1>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name copy-predicates +)
}

sp {extract-state*apply*copy-predicates*mark*done
    (state <s> ^name extract-state ^operator <o*1> ^predicate-set <preds>)
    (<o*1> ^name copy-predicates)
    -->
    (<preds> ^done true +)
}

sp {extract-state*apply*copy-predicates*create*objects
    (state <s> ^name extract-state ^operator <o*1> ^predicate-set <preds>
          ^object-set <o*2>)
    (<o*1> ^name copy-predicates)
    (<o*2> ^object <obj>)
    (<obj> ^predicates <p*1>)
    (<p*1>
          ^{ <> door1 <> movable <> indicated <> object-handle <> category <> arm-status <> dialog-object <> value <> handle <> type <> visible <> multiple <> number <att> } { <> grid-green <val> })
    -->
    (<preds> ^predicate <pred> +)
    (<pred> ^object <obj> + ^name <att> + ^value <val> +)
}

sp {extract-state*propose*complete-state
    (state <s> ^name extract-state)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name complete-state +)
}

sp {extract-state*apply*complete-state
    (state <s> ^name extract-state ^operator <o*1> ^predicate-set <preds>
          ^object-set <os> ^relationships <rels> ^superstate <s*1>
          ^superstate <ss>)
    (<o*1> ^name complete-state)
    (<s*1> ^operator <op>)
    -->
    (<ss> ^state-result <res> +)
    (<res> ^relationships <rels> + ^objects <os> + ^predicate-set <preds> +)
}

sp {learn-goal-demonstration*propose*extract-state
    (state <s> ^name learn-goal-demonstration
          ^type { << initial final >> <type> } ^top-state <t*3>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^dialog-context <d*1>)
      (<d*1> ^<type> <t*2>)}
    (<t*3> ^dialog-context <d*2>)
    (<d*2> ^type game-learning)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name extract-state + ^type <type> +)
}

sp {learn-goal-demonstration*apply*extract-state
    (state <s> ^name learn-goal-demonstration ^operator <o>
          ^type { << initial final >> <type> } ^state-result <staterep>
          ^top-state <t*1>)
    (<o> ^name extract-state ^type <type>)
    (<t*1> ^dialog-context <g>)
    -->
    (<g> ^<type> <staterep> +)
}

sp {learn-goal-demonstration*elaborate*attend
    :o-support
    (state <s> ^name learn-goal-demonstration ^top-state <t*1>)
    (<t*1> ^dialog-context <g>)
    (<g> -^attend <a*1> ^initial <i*1>)
    -->
    (<g> ^attend <at> + ^ignore <ig> +)
}

sp {learn-goal-demonstration*send-message*game-final-state
    :o-support
    (state <s> ^name learn-goal-demonstration ^type initial ^top-state <t*1>
          ^top-state <t*2> ^top-state <t*3>)
    (<t*1> ^interaction <i*1>)
    (<t*2> ^dialog-context <dc>)
    (<dc> -^final <f*1> ^needs-setup <t> ^initial <i*3>)
    (<t*3> ^interaction <i*2>)
    (<i*2> ^changes <changes>)
    (<i*1> ^status <status>)
    -->
    (<dc> ^needs-setup <t> -)
    (<changes> ^outgoing-message <msg> +)
    (<msg> ^type simple-message + ^message-type define-actions +)
    (<status> ^performed <p*1> +)
    (<p*1> ^learning-event <l*1> +)
    (<l*1> ^type game +)
}

sp {learn-goal-demonstration*elaborate*copy-down-attrs
    (state <s> ^name learn-goal-demonstration ^superstate <s*1>)
    (<s*1> ^operator <o>)
    (<o> ^type <type>)
    -->
    (<s> ^type <type> +)
}

sp {elaborate*status*unknown*task
    (state <s> ^choices none ^attribute state ^top-state <ts> ^superstate <ts>)
    (<ts> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^failure <f> +)
    (<f> ^type unknown-task +)
}

sp {top-state*elaborate*extract-relations
    (state <s> ^top-state <s>)
    -->
    (<s> ^extract-relations <rels> +)
}

sp {language-comprehension*elaborate-operator*language-comprehension-init
    (state <s> ^superstate nil)
    -->
    (<s> ^world-usage internal + ^create-trace-file false +
           ^dialog-world <world> + ^dialog-object-list nil +
           ^dialog-object-list-saved nil +)
    (<world> ^objects <objects> + ^predicates <predicates> +)
}

sp {rosie*propose*process-new-sentence*scripted
    (state <s> ^world-usage internal -^terminated-sentence <cs>
          ^current-sentence <sentence> ^current-sentence-number <csn>)
    (<sentence> -^segment-proposed true)
    -->
    (<s> ^operator <op> + ^operator <op> >)
    (<op> ^name process-new-sentence + ^sentence <sentence> +)
}

sp {rosie*apply*process-new-sentence*copy*new-segment-info*from-script
    (state <s> ^name rosie ^operator <op> ^top-state <t*1>)
    (<op> ^name process-new-sentence ^sentence <sentence>)
    (<sentence> ^original-sentence <os>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^changes <c>)
    -->
    (<sentence> ^segment-proposed true +)
    (<c> ^new-segment-info <info> +)
    (<info> ^purpose <p> + ^originator instructor +)
    (<p> ^type process-sentence + ^parameters <p*1> + ^satisfaction <sat> +)
    (<p*1> ^sentence (deep-copy <os>) +)
    (<sat> ^dialog-event <de> +)
    (<de> ^type process-sentence + ^originator agent +)
}

sp {dialog-event*propose*comprehension
    (state <s> ^name dialog-event ^purpose <p>)
    (<p> ^type process-sentence ^parameters <p*1>)
    (<p*1> ^sentence <sentence>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name comprehension + ^sentence <sentence> +)
}

sp {apply*performed-event*clean*dialog-world
    (state <s1> ^name interaction ^operator <o> ^top-state <t*1>)
   -{ (<o> ^event <e*1>)
      (<e*1> ^dialog-event <d*2>)
      (<d*2> ^type process-unknown-word)}
   -{ (<o> ^event <e*2>)
      (<e*2> ^dialog-event <d*3>)
      (<d*3> ^type process-sentence)}
    (<o> ^name performed-event)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^{ << objects predicates >> <a*1> } <dw>)
    (<dw> ^<something> <obj>)
    -->
    (<dw> ^<something> <obj> -)
}

sp {comprehension*elaborate*sentence
    (state <s> ^segment <seg> ^superstate <s*1>)
    (<s*1> ^operator <o*1>)
    (<o*1> ^sentence <sentence>)
    -->
    (<seg> ^input-sentence (deep-copy <sentence>) +
           ^current-word (deep-copy <sentence>) +
           ^original-sentence (deep-copy <sentence>) +)
}

sp {pass-down-segment*elaborate*substate
    (state <s> ^impasse no-change
          ^name { << print-semantics termination-processing comprehend-word comprehend-construction ground-referent process-multiple-groundings >> <n*1> }
          ^superstate <s*1>)
    (<s*1> ^segment <seg>)
    -->
    (<s> ^segment <seg> +)
}

sp {comprehension*elaborate-problem-space
    (state <s> ^name comprehension)
    -->
    (<s> ^problem-space <ps> + ^desired <d> +)
    (<ps> ^default-operator-copy no + ^default-state-copy no +
           ^dont-copy-anything true + ^name comprehend +)
}

sp {comprehension*elaborate-segment
    (state <s> ^name comprehension -^name evaluate-operator)
    -->
    (<s> ^segment <seg> +)
    (<seg> ^semantics <sem> + ^last-merge <lm> +)
    (<lm> ^receiver nil + ^assigner nil + ^structure-type none +)
}

sp {elaborate*comprehend*dialog-object-list-access*copy
    (state <s> ^name comprehension ^segment <seg> ^top-state <t*1>)
    (<t*1> ^dialog-object-list-saved <dol>)
    -->
    (<seg> ^dialog-object-list-access <dol> +)
}

sp {elaborate*comprehend*hypothetical*game-learning
    :o-support
    (state <s> ^segment <seg> ^top-state <t*1>)
    (<t*1> ^dialog-context <d*1>)
    (<d*1> ^learning true)
    -->
    (<seg> ^hypothetical true +)
}

sp {elaborate*top-state*pass-down-evaluate
    (state <s> ^name evaluate-operator ^superstate <s*1>)
    (<s*1> ^top-state <ts>)
    -->
    (<s> ^top-state <ts> +)
}

sp {comprehension*elaborate*state
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^current-word <c*1>)
    (<c*1> ^spelling <w>)
    -->
    
}

sp {comprehension*elaborate*state*sentence
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^original-sentence <o*1>)
    (<o*1> ^complete-sentence <w>)
    -->
    
}

sp {comprehension*propose*comprehend-completion
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^comprehension-structure <c*1>)
    (<c*1> ^processed true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-completion +)
}

sp {apply*comprehend-completion*remove-comprehension-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <cs>)
    -->
    (<seg> ^comprehension-structure <cs> -)
}

sp {apply*comprehend-completion*remove-comprehension-structure-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^current-word <cw>)
    (<c*1> ^failed true)
    -->
    (<cw> ^comprehend-completed true +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*receiver
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-receiver <item>)
    -->
    (<seg> ^not-merged-receiver <item> +)
}

sp {apply*comprehend-completion*remove-comprehension-structure*assigner
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-assigner <item>)
    -->
    (<seg> ^not-merged-assigner <item> +)
}

sp {comprehension*compare*comprehend-completion*comprehend-construction
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-completion)
    (<op2> ^name { << failed-comprehension comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*comprehend-completion*remove-comprehension-structure*snip-receiver
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^not-merged-receiver <rr> ^comprehension-structure <c*1>)
    (<c*1> ^remove-receiver <rr>)
    -->
    (<seg> ^not-merged-receiver <rr> -)
}

sp {apply*comprehend-completion*create-receiver*init-retrieved-stack
    (state <s> ^segment <ss> ^operator <o*1>)
    (<ss> -^retrieved-stack <x> ^comprehension-structure <c*1>)
    (<o*1> ^name comprehend-completion)
    (<c*1> ^not-merged-receiver <item>)
    -->
    (<ss> ^retrieved-stack <stack> +)
    (<stack> ^item <item> + ^prior nil +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*noskip
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^comprehension-structure <cs> ^retrieved-stack <rc>)
    (<cs> ^type word -^remove-receiver <rr>
          ^not-merged-receiver { <> <rr> <item> })
    (<rc> ^item <rr>)
    -->
    (<ss> ^retrieved-stack <rc> - ^retrieved-stack <nrc> +)
    (<nrc> ^item <item> + ^prior <rc> +)
}

sp {apply*comprehend-completion*create-receiver*push-retrieved-stack*skip1*stale-receiver
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^retrieved-stack <rc> ^comprehension-structure <cs>)
    (<rc> ^prior <prior> ^item <rr>)
    (<cs> ^remove-receiver <rr> -^remove-receiver <rr2>
          ^not-merged-receiver { <> <rr> <item> })
    (<prior> ^item <rr2>)
    -->
    (<rc> ^item <rr> - ^item <item> +)
}

sp {apply*comprehend-completion*save-most-recent-alternative-structure
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1>)
    (<c*1> ^not-merged-receiver <nmr>)
    (<nmr> ^lt <l*1>)
    (<l*1> ^alternative-structure <a*1>)
    -->
    (<seg> ^alternative-structure-receiver <nmr> +)
}

sp {apply*comprehend-completion*stale-receiver-prior-word
    (state <s> ^quiescence t ^operator <o*1> ^segment <ss>)
    (<o*1> ^name comprehend-completion)
    (<ss> ^comprehension-structure <cs> ^retrieved-stack <rc>)
    (<cs> ^words prior-word ^remove-receiver <item>)
    (<rc> ^prior <prior>)
    (<prior> ^item <item> ^prior <prior2>)
    -->
    (<rc> ^prior <prior> - ^prior <prior2> +)
}

sp {apply*comprehend-completion*failed-with-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^retrieved-stack <rs>)
    (<c*1> ^failed true)
    (<rs> ^prior <p>)
    (<p> ^prior { <> nil <p2> })
    -->
    (<rs> ^prior <p> - ^prior <p2> +)
}

sp {apply*comprehend-completion*failed-without-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name comprehend-completion)
    (<seg> ^comprehension-structure <c*1> ^retrieved-stack <rs>)
    (<c*1> ^failed true)
    (<rs> ^prior <p>)
    (<p> ^prior nil)
    -->
    (<seg> ^failed-construction true +)
}

sp {comprehension*propose*comprehend-construction*after-success-assigner
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
    (<seg> -^failed-construction true ^current-word <c*1>
          ^not-merged-receiver <c-item> ^retrieved-stack <rs>
          ^not-merged-receiver { <> nil <p-item> })
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
    (<c*1> ^processed true)
   -{ (<c-item> ^lt <l*1> -^structure-type <dp>)
      (<l*1> ^converts-to <dp>)}
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
    (<rs> ^item <c-item> ^prior <p*1>)
   -{ (<seg> ^construction-comprehended <cc>)
      (<cc> ^current-item <c-item> ^prior-item <p-item>)}
    (<p*1> ^item <p-item>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {comprehension*propose*comprehend-construction2
    (state <s> ^name comprehension ^segment <seg>)
   -{ (<seg> ^current-word <c*2>)
      (<c*2> ^comprehend-completed true)}
    (<seg> -^failed-construction true ^current-word <c*1>
          ^not-merged-receiver <c-item> ^retrieved-stack <rs>
          ^not-merged-receiver { <> nil <p-item> })
   -{ (<seg> ^comprehension-structure <cs>)
      (<cs> ^processed true ^type construction)}
    (<c*1> ^processed true)
   -{ (<c-item> ^lt <l*2>)
      (<l*2> ^structure CP)}
    (<rs> ^item <c-item> ^prior <p*1>)
    (<c-item> ^structure-type <p> ^lt <l*1>)
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type <p>)}
    (<p*1> ^item <p-item>)
    (<l*1> ^converts-to { <> CP <dp> })
   -{ (<seg> ^not-merged-assigner <n*2>)
      (<n*2> ^structure-type <dp>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name comprehend-construction + ^current-item <c-item> +
           ^prior-item <p-item> +)
}

sp {comprehension*compare*comprehend-construction
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-construction)
    (<op2> ^name next-word)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-word*comprehend-completion
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2> ^name { << comprehend-completion >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*avoid-tie
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <pi>)
    (<op2> ^name comprehend-construction ^prior-item <pi>)
    -->
    (<s> ^operator <op1> = <op2>)
}

sp {comprehension*compare*merge*comprehend-construction
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
   -{ (<s> ^operator <op3> +)
      (<op3> ^name merge ^assigner <a*1>)
      (<a*1> ^lt <l*1>)
      (<l*1> ^delay-merge true)}
   -{ (<op1> ^assigner <a*2>)
      (<a*2> ^lt <l*2>)
      (<l*2> ^delay-merge true)}
    (<op1> ^name merge ^receiver <pi>)
    (<op2> ^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction2
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <pi> ^assigner <a*1>)
   -{ (<op2> ^current-item <c*1>)
      (<c*1> ^lt <l*2>)
      (<l*2> ^delay-retry true)}
    (<op2> ^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    (<a*1> ^lt <l*1>)
    (<l*1> ^delay-merge true)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*merge*comprehend-construction3
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <pi> ^assigner <a*1>)
    (<op2> ^prior-item <pi> ^current-item <c*1>
          ^name { << comprehend-construction >> <n*1> })
    (<c*1> ^lt <l*2>)
    (<l*2> ^delay-retry true)
    (<a*1> ^lt <l*1>)
    (<l*1> ^delay-merge true)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*prefer-merge-to-terminal
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2> ^name comprehend-construction ^current-item <c*1>)
    (<c*1> ^structure-type T)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*comprehend-construction*diff*pi
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <pi>)
    (<op2> -^prior-item <pi> ^name { << comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*comprehend-construction*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-construction)
    (<op2> ^name { << process-semantics >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*comprehend-construction*process-phrase-end
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name comprehend-construction)
    (<op2> ^name { << process-phrase-end >> <n*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehend-construction*elaborate*substate
    (state <s> ^name comprehend-construction ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name comprehend-construction ^current-item <c-item>
          ^prior-item <p-item>)
    -->
    (<s> ^current-item <c-item> + ^prior-item <p-item> +
           ^created-assigners 0 + ^retrievals 0 +)
}

sp {comprehend-construction*elaborate*substate2
    (state <s> ^name comprehend-construction)
    -->
    (<s> ^comprehension-structure <cs> +)
    (<cs> ^type construction +)
}

sp {comprehend-construction*current-word
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>)
    (<c*1> ^retrieved-lexical-item <x>)
    -->
    (<s> ^current-word <x> +)
}

sp {comprehend-construction*propose*remove-stale-receiver-second-most-recent
    (state <s> ^name comprehend-construction ^comprehension-structure <c*1>
          ^segment <seg>)
    (<c*1> ^words prior-word)
    (<seg> ^not-merged-receiver <uri1> ^retrieved-stack <r*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^remove-receiver <uri1>)}
    (<r*1> ^prior <p*1>)
    (<p*1> ^item <uri1>)
    (<uri1> ^structure-type <type> ^lt <l*1>)
    (<l*1> ^spelling <spelling>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name remove-stale-receiver + ^stale-receiver <uri1> +)
}

sp {apply*remove-stale-receiver
    (state <s> ^operator <o> ^comprehension-structure <cs>)
    (<o> ^name remove-stale-receiver ^stale-receiver <uri1>)
    (<uri1> ^current-word <c*1> ^structure-type <st>)
    (<c*1> ^spelling <pw>)
    -->
    (<cs> ^remove-receiver <uri1> +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-phrase*first-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^current-item <c-item> ^prior-item <p-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^structure-type <pick-type> ^lt <l*1>)
    (<c*2> ^first-word true)
    (<l*1> ^converts-to <pick-type>)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^prior-word <pick-type>
            ^current-word <up-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first true + ^priority 1 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-phrase
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<p-item> ^structure-type <pick-type> ^lt <l*1>)
    (<l*1> ^converts-to <pick-type>)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^prior-word <pick-type>
            ^current-word <up-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first false + ^priority 2 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase*first-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
    (<p-item> ^current-word <c*3> ^structure-type <pick-type>)
    (<c*3> ^first-word true)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^prior-word <pick-type>
            ^current-word <up-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first true + ^priority 3 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-word-not-phrase
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^lt <l*1>)
      (<l*1> ^converts-to <c*2>)}
   -{ (<p-item> ^current-word <c*3>)
      (<c*3> ^first-word true)}
    (<p-item> ^structure-type <pick-type>)
    (<c-item> ^lt <lli>)
    (<lli> ^spelling <up-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^prior-word <pick-type>
            ^current-word <up-word>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-word> +
           ^prior-structure <pick-type> + ^words current-word +
           ^prior-word-first false + ^priority 4 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word*first
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^current-item <c-item> ^prior-item <p-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^lt <lli>)
    (<c*2> ^first-word true)
    (<c-item> ^structure-type <up-type>)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^prior-word <pick-word>
            ^current-word <up-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-word> + ^prior-word-first true +
           ^words prior-word + ^priority 5 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-word
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item> ^segment <s*1>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<c-item> ^structure-type <up-type>)
    (<p-item> ^lt <lli>)
    (<lli> ^spelling <pick-word>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^prior-word <pick-word>
            ^current-word <up-type>)}
    (<s*1> ^retrieved-stack <rs>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-word> + ^prior-word-first false +
           ^words prior-word + ^priority 6 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type*prior-word-first
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^current-item <c-item> ^prior-item <p-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
    (<p-item> ^current-word <c*2> ^structure-type <pick-type>)
    (<c*2> ^first-word true)
    (<c-item> ^structure-type <up-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first true ^prior-word <pick-type>
            ^current-word <up-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-type> + ^prior-word-first true +
           ^priority 7 +)
}

sp {comprehend-construction*propose*smem-construction-retrieval*structure-type-structure-type
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^current-item <c-item>)
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<p-item> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<c-item> ^structure-type <up-type>)
    (<p-item> ^structure-type <pick-type>)
   -{ (<s> ^failed-retrieval <fr2>)
      (<fr2> ^prior-word-first false ^prior-word <pick-type>
            ^current-word <up-type>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-construction-retrieval + ^current-structure <up-type> +
           ^prior-structure <pick-type> + ^prior-word-first false +
           ^priority 8 +)
}

sp {comprehend-construction*compare*smem-construction-retrieval
    (state <s> ^name comprehend-construction ^operator <op1> +
          ^operator <op2> +)
    (<op1> ^name smem-construction-retrieval ^priority <p>)
    (<op2> ^name smem-construction-retrieval ^priority { > <p> <p*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-construction*apply*smem-construction-retrieval*receiver*first-word-true
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^prior-word-first true ^name smem-construction-retrieval
          ^current-structure <up> ^prior-structure <pick>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> + ^prior-word-first true +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*receiver
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^prior-word-first false ^name smem-construction-retrieval
          ^current-structure <up> ^prior-structure <pick>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> + ^prior-word-first false +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*success*construction
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name smem-construction-retrieval)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^prior-word <pick> ^construction <sp> ^current-word <up>)
    (<c> ^query <q>)
    (<q> ^prior-word <pick> ^current-word <up>)
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> + ^successful-query <q> +)
}

sp {comprehend-construction*apply*smem-construction-retrieval*success*words-from-constructions
    (state <s> ^operator <o> ^comprehension-structure <cs> ^smem <smem>)
    (<o> ^name smem-construction-retrieval ^words <words>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^construction <sp>)
    (<c> ^query <q>)
    -->
    (<cs> ^words <words> +)
}

sp {comprehend-word*apply*smem-construction-retrieval*fail
    (state <s> ^smem <smem> ^superstate <s*1> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <cmd>)
    (<r*1> ^failure <t>)
    (<cmd> ^query <query>)
    (<s*1> ^operator <so>)
    (<o*1>
          ^name { << smem-construction-retrieval smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <opname> })
    -->
    (<s> ^failed-retrieval <query> + ^failed-operator <opname> +)
    (<cmd> ^query <query> - ^depth 9 -)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^prior-item <p-item> ^failed-retrieval <fr> ^current-item <c-item>
          ^comprehension-structure <cs> ^segment <seg>)
   -{ (<p-item> ^current-word <c*1>)
      (<c*1> ^first-word true)}
    (<fr> ^prior-word-first false ^prior-word <pick-type>
          ^current-word <up-type>)
    (<p-item> ^structure-type <pick-type>)
    (<c-item> ^structure-type <up-type>)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehend-word*apply*smem-construction-retrieval*failure-complete2
    (state <s> ^name comprehend-construction -^retrieved-lexical-item <r*1>
          ^failed-retrieval <fr> ^current-item <c-item> ^prior-item <p-item>
          ^comprehension-structure <cs> ^segment <seg>)
    (<fr> ^prior-word-first true ^current-word <up-type>
          ^prior-word <pick-type>)
    (<c-item> ^structure-type <up-type>)
    (<p-item> ^structure-type <pick-type> ^current-word <c*1>)
    (<c*1> ^first-word true)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cs> ^processed true + ^failed true +)
}

sp {comprehension*propose*comprehend-word
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^current-word <cw>)
    (<cw> -^processed true)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name comprehend-word + ^current-word <cw> +)
}

sp {apply*comprehend-word*skip-*
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name comprehend-word)
    (<seg> ^current-word <cw>)
    (<cw> ^spelling *)
    -->
    (<seg> ^comprehension-structure <cs> +)
    (<cw> ^processed true +)
    (<cs> ^processed true +)
}

sp {comprehend-word*elaborate*substate
    (state <s> ^name comprehend-word -^name comprehend-construction
          ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name comprehend-word ^current-word <cw>)
    -->
    (<s> ^current-word <cw> + ^created-assigners 0 + ^retrievals 0 +)
}

sp {comprehend-word*elaborate*substate2
    (state <s> ^name comprehend-word -^name comprehend-construction)
    -->
    (<s> ^comprehension-structure <cs> +)
    (<cs> ^type word +)
}

sp {comprehend-word*expand-structure*retrieved-lexical-item
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^retrieved-lexical-item <x>)
    -->
    (<s> ^retrieved-lexical-item <x> +)
}

sp {comprehend-word*propose*create-assigner
    (state <s> ^retrieved-lexical-item <a-lt> ^current-word <cw>
          ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<a-lt> -^super-type <s*1> ^assigners <id>)
    (<id> ^structure-type <stype>)
    (<c*1> ^not-merged-receiver <r-item>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^not-merged-assigner <item>)
      (<item> ^current-word <cw> ^parent-receiver <r-item> ^lt <id>)}
    (<r-item> ^current-word <cw> ^lt <a-lt>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-assigner + ^lt <id> + ^parent-receiver <r-item> +)
}

sp {comprehend-word*propose*create-assigner*super-type
    (state <s> ^retrieved-lexical-item <r*1> ^current-word <cw>
          ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<r*1> ^super-type <super-t>)
    (<super-t> ^assigners <id>)
    (<id> ^structure-type <stype>)
    (<c*1> ^not-merged-receiver <r-item>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^not-merged-assigner <item>)
      (<item> ^current-word <cw> ^parent-receiver <r-item> ^lt <id>)}
    (<r-item> ^super-type <super-t> ^current-word <cw>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-assigner + ^lt <id> + ^parent-receiver <r-item> +)
}

sp {apply*create-assigner*create-item
    (state <s> ^created-assigners <cax> -^name comprehend-construction
          ^operator <op> ^current-word <cw> ^comprehension-structure <cs>)
    (<op> ^name create-assigner ^parent-receiver <r-item> ^lt <lt>)
    (<lt> ^structure-type <stype>)
    -->
    (<s> ^created-assigners <cax> - ^created-assigners (+ 1 <cax>) +)
    (<cs> ^not-merged-assigner <new-assigner> +)
    (<new-assigner> ^current-word <cw> + ^lt <lt> +
           ^parent-receiver <r-item> + ^structure-type <stype> +)
}

sp {apply*create-assigner*create-item*no-remove
    (state <s> ^name comprehend-construction ^comprehension-structure <cs>
          ^operator <op> ^created-assigners <cax> ^current-word <cw>)
    (<cs> -^remove-assigner <r*1>)
    (<op> ^name create-assigner ^parent-receiver <r-item> ^lt <lt>)
    (<lt> ^structure-type <stype>)
    -->
    (<s> ^created-assigners <cax> - ^created-assigners (+ 1 <cax>) +)
    (<cs> ^not-merged-assigner <new-assigner> +)
    (<new-assigner> ^current-word <cw> + ^lt <lt> +
           ^parent-receiver <r-item> + ^structure-type <stype> +)
}

sp {comprehend-word*propose*create-receiver
    (state <s> ^retrieved-lexical-item <id> ^current-word <cw>
          ^superstate <ss>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<id> -^alternative-structure <a*1>)
   -{ (<s> ^receiver-created <uri> ^comprehension-structure <c*1>)
      (<uri> ^current-word <cw>)
      (<c*1> ^not-merged-receiver <uri>)}
    (<ss> -^retry <r*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-receiver + ^item <item> +)
}

sp {comprehend-word*propose*create-receiver*alternative-structure
    (<ss> -^retry <r*1>)
    (state <s> ^quiescence t ^current-word <cw> ^retrieved-lexical-item <id>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^receiver-created <uri> ^comprehension-structure <c*1>)
      (<uri> ^current-word <cw>)
      (<c*1> ^not-merged-receiver <uri>)}
    (<id> ^alternative-structure <a*1>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name create-receiver + ^item <item> +)
}

sp {comprehend-word*compare*create-receiver2
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name create-receiver)
    (<op2> ^name { << remove-stale-receiver >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {apply*create-receiver*create-item
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^current-word <cw> ^comprehension-structure <cs>)
    (<id> -^super-type <s*1>)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> + ^semantics <sem> +)
}

sp {apply*create-receiver*create-item*super-type
    (state <s> ^retrieved-lexical-item <id> -^name comprehend-construction
          ^operator <op> ^current-word <cw> ^comprehension-structure <cs>)
    (<op> ^name create-receiver ^item <item>)
    (<id> ^super-type <st> ^spelling <spell>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^original-id <id> + ^super-type <st> +
           ^proto-lt <proto-lt> + ^semantics <sem> +)
    (<proto-lt> ^spelling <spell> +)
}

sp {apply*create-receiver*create-item*super-type*copy-lt
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^super-type <st> ^proto-lt <plt>)
    (<st> ^<att> <val>)
    -->
    (<plt> ^<att> <val> + ^copied yes +)
}

sp {apply*create-receiver*create-item*super-type*copy-can-be-part-of
    (state <s> ^operator <op> ^retrieved-lexical-item <id>
          ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^proto-lt <proto>)
    (<id>
          ^{ << attachment can-be-part-of constraint relation referent referent2 quantity semantic-structure semantic-structure2 directional directional-maybe alternative-structure number tense possessive specifier >> <att> } <cbpo>)
    -->
    (<proto> ^<att> <cbpo> +)
}

sp {apply*create-receiver*create-item*super-type*finish
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^proto-lt <plt> ^super-type <st>)
    (<plt> ^copied yes)
    -->
    (<item> ^lt <plt> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^referent <ref>)
    -->
    (<item> ^lt-referent <nref> +)
}

sp {apply*create-receiver*create-item*copy-lt*referent*substructure
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt-referent <ref2> ^lt <l*1>)
    (<l*1> ^referent <ref>)
    (<ref> ^<att> <value>)
    -->
    (<ref2> ^<att> <value> +)
}

sp {apply*create-receiver*create-item*construction
    (state <s> ^name comprehend-construction ^comprehension-structure <cs>
          ^operator <op> ^retrieved-lexical-item <id> ^current-word <cw>)
    (<cs> -^remove-receiver <r*1>)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> +)
}

sp {apply*create-receiver*create-item*construction*none
    (state <s> ^name comprehend-construction ^operator <op>
          ^retrieved-lexical-item <id> ^current-word <cw>
          ^comprehension-structure <cs>)
    (<op> ^name create-receiver ^item <item>)
    (<cs> ^remove-receiver <r*1>)
    (<r*1> ^decision-count <dc>)
   -{ (<cs> ^remove-receiver <r*2>)
      (<r*2> ^decision-count { < <dc> <d*1> })}
    -->
    (<s> ^created-receiver true +)
    (<cs> ^not-merged-receiver <item> +)
    (<item> ^current-word <cw> + ^lt <id> + ^decision-count <dc> +)
}

sp {apply*create-receiver*copy-structure-type
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^structure-type <stype>)
    -->
    (<item> ^structure-type <stype> +)
}

sp {apply*create-receiver*copy-constraint
    (state <s> ^comprehension-structure <c*1>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <l*1>)
    (<l*1> ^constraint <stype>)
    -->
    (<item> ^constraint <stype> +)
}

sp {apply*create-receiver*copy*first-word-true
    (state <s> ^current-word <c*1> -^name comprehend-construction
          ^operator <op>)
    (<c*1> ^first-word true)
    (<op> ^name create-receiver ^item <item>)
    -->
    (<item> ^first-word true +)
}

sp {apply*create-receiver*create-item*finish*no-referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt <lt>)
    (<lt> -^referent <r*1>)
    -->
    (<s> ^receiver-created <item> +)
}

sp {apply*create-receiver*create-item*finish*referent
    (state <s> ^operator <op> ^comprehension-structure <c*1>)
    (<op> ^name create-receiver ^item <item>)
    (<c*1> ^not-merged-receiver <item>)
    (<item> ^lt-referent <l*1>)
    -->
    (<s> ^receiver-created <item> +)
}

sp {comprehend-word*propose*finish-comprehend*success
    (state <s> ^created-receiver true ^created-assigners <n> ^retrievals <m>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name finish-comprehend +)
}

sp {comprehend-word*propose*finish-comprehend*new-word
    (state <s> ^new-word true
          ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name finish-comprehend +)
}

sp {comprehend-word*compare*finish-comprehend
    (state <s> ^operator <op1> +
          ^name { << comprehend-word comprehend-construction >> <n*1> }
          ^operator <op2> +)
    (<op1> ^name finish-comprehend)
    (<op2>
          ^name { << remove-stale-receiver process-new-word create-assigner create-receiver remove-stale-assigner >> <n*2> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {apply*finish-comprehend
    (state <s> ^created-receiver true ^name comprehend-word ^operator <op>
          ^current-word <cw> ^comprehension-structure <cs> ^segment <ss>)
    (<op> ^name finish-comprehend)
    -->
    (<ss> ^comprehension-structure <cs> +)
    (<cs> ^processed true +)
    (<cw> ^processed true +)
}

sp {apply*finish-comprehend*construction
    (state <s> ^created-receiver true ^name comprehend-construction
          ^operator <op> ^current-item <c-item> ^prior-item <p-item>
          ^comprehension-structure <cs> ^segment <ss>)
    (<op> ^name finish-comprehend)
    (<cs> ^retrieved-lexical-item <cw>)
    -->
    (<ss> ^comprehension-structure <cs> + ^construction-comprehended <cc> +)
    (<cc> ^current-item <c-item> + ^prior-item <p-item> +)
    (<cs> ^processed true +)
    (<cw> ^processed true +)
}

sp {comprehend-word*propose*process-new-word*multiple-non-U-primitive-assigner*fail
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>)
   -{ (<seg> ^not-merged-assigner <n*1>)
      (<n*1> ^structure-type U)}
    (<seg> ^current-word <cw> ^not-merged-assigner <ass>
          ^not-merged-assigner { < <ass> <ass2> })
    (<cw> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    (<ass> ^structure-type { << V ADJ N ADV PN >> <s*1> })
    (<ass2> ^structure-type { << V ADJ N ADV PN >> <s*2> })
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name process-new-word + ^spell <spell> + ^fail true +
           ^handle (make-constant-symbol <spell>) +)
}

sp {comprehend-word*propose*process-new-word*U
    (state <s> ^failed-retrieval true -^failed-new-word true
          ^name comprehend-word ^quiescence t ^segment <seg>)
    (<seg> ^not-merged-assigner <ass> ^current-word <cw>)
    (<ass> ^structure-type U)
    (<cw> ^spelling <spell>)
   -{ (<s> ^retrieved-lexical-item <r*1>)
      (<r*1> ^spelling <spell>)}
    -->
    (<s> ^operator <op> +)
    (<op> ^name process-new-word + ^type U + ^spell <spell> +
           ^handle (make-constant-symbol <spell>) +)
}

sp {apply*process-new-word*assign*U
    (state <s> ^operator <op> ^comprehension-structure <cs> ^smem <s*1>)
    (<op> ^name process-new-word ^type U ^spell <spell> ^handle <name>)
    (<s*1> ^command <cmd>)
    -->
    (<cs> ^retrieved-lexical-item <nw> +)
    (<s> ^store-concept <nw> + ^store-concept <ref> + ^new-word true +
           ^retrieved-lexical-item <nw> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
}

sp {apply*process-new-word*failure*internal
    (state <s> ^top-state <ts> ^operator <op> ^segment <seg>)
    (<ts> ^world-usage internal)
    (<op> ^fail true ^name process-new-word ^spell <spell> ^handle <name>)
    (<seg> ^semantics <sem> ^original-sentence <cs> ^current-word <cw>)
    -->
    (<s> ^store-concept <nw> + ^store-concept <ref> +)
    (<nw> ^spelling <spell> + ^referent <ref> +)
    (<ref> ^handle <name> + ^word-structure <nw> +)
    (<cw> ^processed true +)
    (<sem> ^interaction-status <i*1> +)
    (<i*1> ^new-message <is> +)
    (<is> ^type unknown-word + ^word <spell> +)
    (<cs> ^processing-result failure +)
}

sp {apply*process-new-word*mark-on-segment
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name process-new-word ^spell <spell> ^handle <name>)
    (<seg> ^current-word <cw>)
    -->
    (<seg> ^unknown-word <spell> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval
    (state <s> ^current-word <cw> -^retrieved-lexical-item <r*1>
          -^failed-retrieval true ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*3>)}
   -{ (<seg> ^prior-word <p*1>)
      (<p*1> ^spelling *)
      (<cw> ^next <n*2>)
      (<n*2> ^spelling |.|)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval + ^word <cw> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval2
    (state <s> ^current-word <cw>
          -^failed-operator smem-lexical-retrieval-cw-pw-type
          -^retrieved-lexical-item <r*1> -^failed-retrieval true
          ^segment <seg>
          ^name { << comprehend-word comprehend-construction >> <n*1> })
   -{ (<s> ^comprehension-structure <c*1>)
      (<c*1> ^retrieved-lexical-item <r*2>)}
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*3>)}
   -{ (<s> ^retrieved-stack <r*4>)
      (<r*4> ^item <i*1>)
      (<i*1> ^lt <l*1>)
      (<l*1> ^structure-type <pick-type>)}
   -{ (<seg> ^prior-word <p*1>)
      (<p*1> ^spelling *)
      (<cw> ^next <n*2>)
      (<n*2> ^spelling |.|)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval + ^word <cw> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*not-first-word
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-lexical-retrieval ^word <word>)
    (<word> -^first-word true ^spelling <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling <x> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*first-word
    (state <s> ^operator <o> ^smem <s*1>)
    (<o> ^name smem-lexical-retrieval ^word <word>)
    (<word> ^first-word true ^spelling <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling <x> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*success
    (state <s> ^comprehension-structure <cs> ^smem <smem> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^spelling <x>)
    (<c> ^query <q>)
    (<q> ^spelling <x>)
    (<o*1>
          ^name { << smem-lexical-retrieval smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval*fail
    (state <s> ^operator <o*1> ^smem <smem> ^superstate <s*1>)
    (<o*1> ^name smem-lexical-retrieval)
    (<smem> ^result <r*1>)
    (<r*1> ^failure <t>)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-retrieval true +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^current-word <c*1> ^segment <seg>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
    (<c*1> ^spelling <up>)
    (<seg> ^prior-word <p*1>)
    (<p*1> ^spelling <pick>)
   -{ (<seg> ^retrieved-stack <r*4>)
      (<r*4> ^item <i*1>)
      (<i*1> ^lt <l*1>)
      (<l*1> ^spelling <pick>)}
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw + ^current-word <up> +
           ^prior-word <pick> + ^prior-word-stale true +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw2
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^current-word <c*1> ^segment <seg>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
    (<c*1> ^spelling <up>)
    (<seg> ^retrieved-stack <r*4>)
    (<r*4> ^item <item>)
    (<item> -^merged-with true ^lt <l*1>)
    (<l*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw + ^current-word <up> +
           ^prior-word <pick> + ^prior-word-stale true +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw*reject
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^operator <o> + ^failed-retrieval <fr> ^current-word <c*1>
          ^segment <seg>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
    (<o> ^prior-word-stale true ^name smem-lexical-retrieval-cw-pw
          ^prior-word <pick> ^current-word <up>)
    (<fr> ^prior-word <pick> ^current-word <up>)
    (<c*1> ^spelling <up>)
    (<seg> ^prior-word <p*1>)
    (<p*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw*reject2
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^operator <o> + ^failed-retrieval <fr> ^current-word <c*1>
          ^segment <seg>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^retry <r*2>)}
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*3>)}
    (<o> ^prior-word-stale true ^name smem-lexical-retrieval-cw-pw
          ^prior-word <pick> ^current-word <up>)
    (<fr> ^prior-word <pick> ^current-word <up>)
    (<c*1> ^spelling <up>)
    (<seg> ^retrieved-stack <r*4>)
    (<r*4> ^item <i*1>)
    (<i*1> ^lt <l*1>)
    (<l*1> ^spelling <pick>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw-type
    (state <s> ^failed-operator smem-lexical-retrieval-cw-pw
          -^retrieved-lexical-item <r*1> ^name comprehend-word ^segment <seg>
          ^current-word <c*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*2>)}
    (<seg> -^retry <r*4> ^retrieved-stack <r*3>)
    (<c*1> ^spelling <up>)
    (<r*3> ^item <i*1>)
    (<i*1> ^lt <lt>)
    (<lt> ^structure-type <pick-type>)
    -->
    (<s> ^operator <o> + ^operator <o> =)
    (<o> ^name smem-lexical-retrieval-cw-pw-type + ^current-word <up> +
           ^prior-word <pick-type> +)
}

sp {comprehend-word*propose*smem-lexical-retrieval-cw-pw-type*reject
    (state <s> ^name comprehend-word -^retrieved-lexical-item <r*1>
          ^segment <seg> ^operator <o> + ^failed-retrieval <fr>
          ^current-word <c*1>)
   -{ (<s> ^comprehension-structure <c*2>)
      (<c*2> ^retrieved-lexical-item <r*2>)}
    (<seg> -^retry <r*4> ^retrieved-stack <r*3>)
    (<o> ^name smem-lexical-retrieval-cw-pw-type ^prior-word <pick-type>
          ^current-word <up>)
    (<fr> ^prior-word <pick-type> ^current-word <up>)
    (<c*1> ^spelling <up>)
    (<r*3> ^item <i*1>)
    (<i*1> ^lt <l*1>)
    (<l*1> ^structure-type <pick-type>)
    -->
    (<s> ^operator <o> -)
}

sp {comprehend-word*compare*smem-lexical-retrieval-cw-pw*smem-lexical-retrieval
    (state <s> ^name comprehend-word ^operator <op2> + ^operator <op1> +)
    (<op2> ^name smem-lexical-retrieval)
    (<op1>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-word*compare*smem-lexical-retrieval-cw-pw*smem-lexical-retrieval-cw-pw-type
    (state <s> ^name comprehend-word ^operator <op1> + ^operator <op2> +)
    (<op1> ^name smem-lexical-retrieval-cw-pw)
    (<op2> ^name smem-lexical-retrieval-cw-pw-type)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend-construction*apply*smem-lexical-retrieval-cw-pw
    (state <s> ^smem <s*1> ^operator <o>)
    (<s*1> ^command <cmd>)
    (<o> ^prior-word <pick> ^current-word <up>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<cmd> ^query <x> + ^depth 9 +)
    (<x> ^current-word <up> + ^prior-word <pick> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-cw-pw*success
    (state <s> ^comprehension-structure <cs> ^smem <smem> ^operator <o*1>)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^prior-word <pw> ^current-word <cw>)
    (<c> ^query <q>)
    (<q> ^prior-word <pw> ^current-word <cw>)
    (<o*1>
          ^name { << smem-lexical-retrieval-cw-pw smem-lexical-retrieval-cw-pw-type >> <n*1> })
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehend-word*apply*smem-lexical-retrieval-assigner-prior-word-stale
    (state <s> ^operator <o> ^comprehension-structure <cs> ^segment <seg>
          ^smem <s*1>)
    (<o> ^prior-word-stale true ^prior-word <pw>)
    (<seg> ^retrieved-stack <r*2> ^not-merged-assigner <uai>)
    (<uai> ^current-word <c*1> ^parent-receiver <prior-receiver> ^lt <lt>)
    (<c*1> ^spelling <pw>)
    (<r*2> ^item <prior-receiver>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <rli>)
    (<rli> -^consumes-prior-word false ^prior-word <pw>)
    -->
    (<seg> ^not-merged-assigner <uai> -)
}

sp {comprehend-word*apply*smem-lexical-retrieval-receiver-prior-word-stale
    (state <s> ^operator <o> ^comprehension-structure <cs> ^segment <seg>
          ^smem <s*1>)
    (<o> ^prior-word-stale true ^prior-word <pw>)
    (<seg> ^retrieved-stack <r*2> ^not-merged-receiver <uai>)
    (<r*2> ^item <uai>)
    (<uai> ^lt <lt>)
    (<s*1> ^result <r*1>)
    (<r*1> ^retrieved <rli>)
    (<rli> -^consumes-prior-word false ^prior-word <pw>)
    -->
    (<cs> ^remove-receiver <uai> +)
}

sp {comprehend-word*elaborate*single-wordx
    (state <s> ^name comprehend-word ^segment <seg>)
    (<seg> ^prior-word <p*1> ^current-word <cw>)
    (<p*1> ^spelling *)
    (<cw> ^next <n*1> ^spelling <spell>)
    (<n*1> ^spelling |.|)
    -->
    (<s> ^single-word true +)
}

sp {comprehend-word*propose*process-single-wordx
    (state <s> ^single-word true -^retrieved-lexical-item <r*1>
          -^failed-single-word-retrieval true ^name comprehend-word
          ^segment <seg>)
    (<seg> ^current-word <cw>)
    (<cw> ^spelling <spell>)
    -->
    (<s> ^operator <op> + ^operator <op> > ^operator <op> =)
    (<op> ^name process-single-word + ^spell <spell> + ^current-word <cw> +)
}

sp {comprehend-word*apply*process-single-word
    (state <s> ^operator <o> ^smem <s*1>)
   -{ (<o> ^current-word <c*1>)
      (<c*1> ^quoted true)}
    (<o> ^name process-single-word ^spell <x>)
    (<s*1> ^command <cmd>)
    -->
    (<cmd> ^query <q> + ^depth 9 +)
    (<q> ^spelling-single-word <x> +)
}

sp {comprehend-word*apply*process-single-word*success
    (state <s> ^operator <o*1> ^comprehension-structure <cs> ^smem <smem>)
    (<o*1> ^name process-single-word)
    (<smem> ^result <r*1> ^command <c>)
    (<r*1> ^retrieved <rli>)
    (<rli> ^spelling-single-word <x>)
    (<c> ^query <q>)
    (<q> ^spelling-single-word <x>)
    -->
    (<c> ^query <q> - ^depth 9 -)
    (<cs> ^retrieved-lexical-item <rli> +)
}

sp {comprehension*propose*ground-referent
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^receiver <r1> ^assigner <as>)
   -{ (<r1> ^lt-referent <l*2>)
      (<l*2> ^property <p*1>)
      (<p*1> ^type conceptual)}
   -{ (<as> ^lt <l*1>)
      (<l*1> ^referent-type literal)}
    (<as> ^parent-receiver { <> <r1> <a1> } ^structure-type <s*2>)
    (<a1> -^ground-tested <r1> -^ground-tested <a1> ^structure-type DP)
   -{ (<a1> ^constraint <c*1>)
      (<c*1> ^property <p*2>)
      (<p*2> ^type conceptual)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <a1> + ^parameter <r1> +)
}

sp {comprehension*propose*ground-referent*push*head
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <as> ^receiver <r1>)
   -{ (<as> ^lt <l*1>)
      (<l*1> ^referent-type literal)}
    (<as> ^parent-receiver <a1> ^structure-type <s*2>)
    (<a1> ^head <head> -^ground-tested <head>)
   -{ (<head> ^constraint <c*1>)
      (<c*1> ^property <p*1>)
      (<p*1> ^type conceptual)}
    (<head> -^ground-tested <g*1> ^structure-type <st>)
    (<r1> -^ground-tested <head> ^structure-type { << THIS THAT DP >> <st> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name ground-referent + ^constraints <head> + ^parameter <head> +)
}

sp {comprehension*elaborate-operator*ground-referent*lt
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con>)
    (<con> ^lt <l*1>)
    (<l*1> ^constraint <x>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*elaborate-operator*ground-referent*parameter-constraint
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con> ^parameter <p*1>)
    (<p*1> ^constraint <x>)
    (<x> ^relation <r*1>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*elaborate-operator*ground-referent*parameter-complement
    (state <s> ^name comprehension ^operator <o> +)
    (<o> ^name ground-referent ^constraints <con> ^parameter <p*1>)
    (<p*1> ^complement <c*1>)
    (<c*1> ^constraint <x>)
    -->
    (<con> ^constraint <x> +)
}

sp {comprehension*compare*ground-referent
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name ground-referent)
    (<op2> ^name process-phrase-end)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*ground-referent*merge*literal
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^structure-type DP)
    (<op2> ^name merge ^assigner <ass>)
    (<ass> ^structure-type DP ^lt <l*1>)
    (<l*1> ^referent-type literal)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*ground-referent*merge*not
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^structure-type DP)
    (<op2> ^name merge ^assigner <ass>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*ground-referent*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name ground-referent)
    (<op2> ^name { << ground-new-constraint process-semantics >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*elaborate*ground-referent*count-constraints*0
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> -^constraint <c*1>)
    -->
    (<op1> ^constraint-count 0 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*1
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c1> -^constraint { <> <c1> <c*1> })
    -->
    (<op1> ^constraint-count 1 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*2
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c1> ^constraint { > <c1> <c2> }
          -^constraint { <> <c1> <> <c2> <c*1> })
    -->
    (<op1> ^constraint-count 2 +)
}

sp {comprehension*elaborate*ground-referent*count-constraints*3
    (state <s> ^name comprehension ^operator <op1> +)
    (<op1> ^name ground-referent ^constraints <con>)
    (<con> ^constraint <c1> ^constraint { > <c1> <c2> }
          ^constraint { > <c2> > <c1> <c3> }
          -^constraint { <> <c1> <> <c2> <> <c3> <c*1> })
    -->
    (<op1> ^constraint-count 3 +)
}

sp {ground-referent*elaborate*substate*count
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraint-count <cc>)
    -->
    (<s> ^constraint-count <cc> + ^candidate-set <cs> +)
}

sp {ground-referent*elaborate*substate*constraints
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraints <cons>)
    -->
    (<s> ^constraints <cons> +)
}

sp {ground-referent*constraint-lt
    (state <s> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^lt <x>)
    -->
    (<s> ^constraint-lt <x> +)
}

sp {ground-referent*elaborate*substate*constraint
    (state <s> ^name ground-referent ^superstate <s*1>)
    (<s*1> ^operator <so>)
    (<so> ^name ground-referent ^constraints <c*1>)
    (<c*1> ^constraint <con>)
    -->
    (<s> ^constraint <con> +)
}

sp {ground-referent*elaborate*substate2
    (state <s> ^name ground-referent ^constraint <con>)
    (<con> ^handle <value> ^property <prop>)
    (<prop> ^{ << name handle >> <a*1> } <property>)
    -->
    (<s> ^property-constraint <pc> +)
    (<pc> ^property <property> + ^value <value> +)
}

sp {ground-referent*elaborate*substate2*subcategory
    (state <s> ^name ground-referent ^property-constraint <pc>
          ^constraint <con>)
    (<con> ^handle <value> ^subcategory <s*1> ^property <prop>)
    (<pc> ^value <value> ^property <property>)
    (<s*1> ^handle <x>)
    (<prop> ^{ << name handle >> <a*1> } <property>)
    -->
    (<pc> ^value <x> +)
}

sp {ground-referent*elaborate*constraint-processing-finished
    (state <s> ^name ground-referent ^candidate-set <c*1>)
    (<c*1> ^proto-referent <p*1>)
    (<p*1> ^constraint-count 0)
    -->
    (<s> ^constraint-processing-finished true +)
}

sp {ground-referent*elaborate*proto-referents*none
    (state <s> ^name ground-referent ^candidate-set <cs>)
   -{ (<cs> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)}
    (<cs> ^generated-candidates true)
    -->
    (<s> ^proto-referents none +)
}

sp {ground-referent*elaborate*no-proto-referents*one
    (state <s> ^name ground-referent ^candidate-set <cs>)
    (<cs> ^generated-candidates true ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
   -{ (<cs> ^proto-referent <p*2>)
      (<p*2> ^object { <> <obj> <o*1> })}
    -->
    (<s> ^proto-referents one +)
}

sp {ground-referent*elaborate*no-proto-referents*multiple
    (state <s> ^name ground-referent -^proto-referents none
          ^candidate-set <cs>)
   -{ (<cs> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)
     -{ (<cs> ^proto-referent <p*2>)
        (<p*2> ^object { <> <obj> <o*1> })}}
    (<cs> ^generated-candidates true)
    -->
    (<s> ^proto-referents multiple +)
}

sp {ground-referent*propose*index-object-properties
    (state <s> ^name ground-referent ^property-constraint <pc>
          ^candidate-set <cs>)
    (<pc> -^property grammatical-property)
    (<cs> -^satisfied-property <pc> ^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-object-properties + ^property-constraint <pc> +)
}

sp {ground-referent*compare*index-object-properties2
    (state <s> ^name ground-referent ^operator <op1> + ^operator <op2> +)
    (<op1> ^name index-object-properties ^property-constraint <p*1>)
    (<op2> ^name index-object-properties ^property-constraint <p*2>)
    (<p*1> ^value <pc>)
    (<p*2> ^value { < <pc> <v*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*apply*index-object-properties*violates
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pc> ^value <prop-val> ^property { <> generic <prop-name> })
    (<pr> ^object <obj>)
    (<obj> -^handle <prop-val> ^predicates <preds>)
    (<preds> -^<prop-name> <prop-val>)
   -{ (<pc> ^value <p-value>)
      (<preds> ^<prop-name> <p-value>)}
    -->
    (<pr> ^violates <pc> +)
    (<cs> ^fail-tested <pc> +)
}

sp {ground-referent*apply*index-object-properties*passes
    (state <s> ^operator <o> ^candidate-set <cs>)
    (<o> ^name index-object-properties ^property-constraint <pc>)
    (<cs> ^proto-referent <pr>)
    (<pc> ^value <prop-val> ^property <prop-name>)
    (<pr> ^object <o*1>)
    (<o*1> ^predicates <p*1>)
    (<p*1> ^<prop-name> <prop-val>)
    -->
    (<pr> ^passes <pc> +)
    (<cs> ^success-tested <pc> +)
}

sp {ground-referent*apply*index-object-properties*mark*checked
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^success-tested <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {ground-referent*apply*index-object-properties*mark*checked*failed
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^fail-tested <pc> -^success-tested <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^satisfied-property <pc> +)
}

sp {ground-referent*apply*index-object-properties*mark*satisfied
    (state <s> ^candidate-set <c*1> ^operator <o>)
    (<c*1> ^proto-referent <pr>)
    (<pr> ^constraint-count <cc> ^passes <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<pr> ^constraint-count <cc> - ^constraint-count (- <cc> 1) +)
}

sp {ground-referent*apply*index-object-properties*remove-violated
    (state <s> ^candidate-set <cs> ^operator <o>)
    (<cs> ^proto-referent <pr>)
    (<pr> ^violates <pc>)
    (<o> ^property-constraint <pc>
          ^name { << index-object-properties index-dialog-properties >> <n*1> })
    -->
    (<cs> ^proto-referent <pr> -)
}

sp {ground-referent*propose*index-scene-relation
    (state <s> ^name ground-referent ^candidate-set <cs> ^constraint <c*1>)
    (<cs> ^generated-candidates true -^satisfied-property <r>)
    (<c*1> ^relation <r>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-object-scene-relation + ^relation-constraint <r> +)
}

sp {ground-referent*propose*index-scene-object
    (state <s> ^name ground-referent ^constraint-lt <lli>
          ^candidate-set <cand>)
    (<lli> -^demonstrative true ^specifier <specifier>)
    (<cand> -^generated-candidates true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name index-scene-objects + ^specifier <specifier> +)
}

sp {ground-referent*propose*index-scene-object*multiple
    (state <s> ^name ground-referent ^constraint <c*1> ^operator <op> +)
    (<c*1> ^multiple true)
    (<op> ^name index-scene-objects)
    -->
    (<op> ^multiple true +)
}

sp {ground-referent*apply*index-scene-objects*personal*create*robot
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^top-state <t*1>)
    (<o> ^specifier personal ^name index-scene-objects)
    (<t*1> ^world <w*1>)
    (<w*1> ^robot <obj>)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>
          ^top-state <t*1>)
    (<o> -^specifier distinct -^possessive true ^name index-scene-objects
          ^specifier { << definite universal >> <s*1> })
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <o*1>)
    (<o*1> ^object <obj>)
    (<obj> -^dialog-ignore true)
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^number singular)
      (<obj> ^predicates <p*1>)
      (<p*1> ^multiple true)}
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*it-arg1
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^merged-assigner <ma>)
    (<ma> ^parent-receiver <p*1>)
    (<p*1> ^semantics <s*1>)
    (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*2>)
      (<p*2> ^semantics <s*2>)
      (<s*2> ^{ << arg1 agent >> <a*2> } <obj>)}
    (<obj> ^predicates <p*3>)
    (<p*3> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*subclause-it-arg1
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^merged-assigner <ma>)
    (<ma> ^parent-receiver <p*2>)
    (<p*2> ^semantics <s*2>)
    (<s*2> ^if-subclause <i*1>)
    (<i*1> ^{ << arg1 agent >> <a*2> } <obj>)
   -{ (<ma> ^parent-receiver <p*1>)
      (<p*1> ^semantics <s*1>)
      (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)}
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*3>)
      (<p*3> ^semantics <s*3>)
      (<s*3> ^{ << arg1 agent >> <a*3> } <obj>)}
    (<obj> ^predicates <p*4>)
    (<p*4> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*it-agent-subclause
    (state <s> ^name ground-referent ^segment <seg>)
    (<seg> ^not-merged-assigner <ma>)
    (<ma> ^parent-receiver <p*1>)
    (<p*1> ^semantics <s*1>)
    (<s*1> ^{ << arg1 agent >> <a*1> } <obj>)
   -{ (<seg> ^merged-assigner { < <ma> <ma2> })
      (<ma2> ^parent-receiver <p*2>)
      (<p*2> ^semantics <s*2>)
      (<s*2> ^{ << arg1 agent >> <a*2> } <obj>)}
    (<obj> ^predicates <p*3>)
    (<p*3> ^category <c*1>)
    -->
    (<s> ^possible-it <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*dialog*it*arg1
    (state <s> ^operator <o> ^possible-it <obj> ^constraint-count <cc>
          ^candidate-set <cand>)
    (<o> ^specifier it ^name index-scene-objects)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> + ^object <obj> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidate*indefinite
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>)
    (<o> ^specifier indefinite ^name index-scene-objects)
    -->
    (<cand> ^proto-referent <pr> +)
    (<pr> ^constraint-count <cc> +)
}

sp {ground-referent*apply*index-scene-objects*create*candidates*parallel
    (state <s> ^operator <o> ^constraint-count <cc> ^candidate-set <cand>)
    (<o> ^name index-scene-objects)
    -->
    (<cand> ^generated-candidates true +)
}

sp {ground-referent*propose*tested-referent
    (state <s> ^name ground-referent ^candidate-set <c*1>)
    (<c*1> ^proto-referent <p>)
    (<p> ^constraint-count 0 ^object <r>)
   -{ (<s> ^constraints <c*2>)
      (<c*2> ^referent <r>)}
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name tested-referent + ^proto-referent <p> +)
}

sp {apply*tested-referent*monitor
    (state <s> ^operator <o>)
    (<o> ^name tested-referent ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
    (<obj> ^handle <id>)
    -->
    
}

sp {apply*tested-referent*copy-proto-referent*no-multiple
    (state <s> ^operator <o> ^constraints <cons>)
    (<o> ^name tested-referent ^proto-referent <p*1>)
    (<p*1> ^object <obj>)
    -->
    (<cons> ^referent <obj> +)
}

sp {ground-referent*propose*failed-grounding
    (state <s> ^proto-referents none ^name ground-referent)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-grounding +)
}

sp {ground-referent*apply*failed-grounding*category
    (state <s> ^constraint <con> ^operator <o*1> ^top-state <t*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
   -{ (<s> ^constraint-lt <c*1>)
      (<c*1> ^specifier indefinite)}
    (<o*1> ^name failed-grounding)
    (<con> ^handle <cat> ^property <p*1>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type <cat> +)
    (<pred> ^visibility not-visible + ^dialog-object true + ^category <cat> +)
}

sp {ground-referent*apply*failed-grounding*indefinite*category
    (state <s> ^constraint-lt <c*1> ^operator <o*1> ^top-state <t*1>
          ^superstate <s*2>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier indefinite)
    (<o*1> ^name failed-grounding)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <con>)
    (<con> ^handle <obj-type> ^property <p*1>)
    (<p*1> ^handle category)
    -->
    (<s> ^proto-referent <pr> +)
    (<pr> ^predicates <pred> + ^handle (make-constant-symbol new-object-id) +
           ^item-type <obj-type> +)
    (<pred> ^visibility unknown-visible + ^dialog-object true +
           ^category <obj-type> +)
}

sp {ground-referent*apply*failed-grounding*property
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<pr> ^predicates <pred> -^{ << handle name category >> <a*3> } <value>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> ^handle <value> ^property <p*1>)
    (<p*1> ^{ << name handle >> <a*2> } { <> category <prop> })
    (<pred> -^<prop> <p*2>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^<prop> <value> +)
}

sp {ground-referent*apply*failed-grounding*property17
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<pr> ^predicates <pred>)
    (<pred> ^category <value>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint>
          -^{ << movable category number quantity type multiple >> <a*2> } <x>
          -^item-type { << predicate property >> <i*1> } ^handle <value>)
   -{ (<constraint> ^property <p*1>)
      (<p*1> ^handle { << property >> <h*1> })}
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property2
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<pr> ^predicates <pred>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <c*1>)
    (<c*1>
          ^{ << movable category number quantity type multiple >> <prop> } <value>)
    -->
    (<pr> ^predicates-copied true +)
    (<pred> ^<prop> <value> +)
}

sp {ground-referent*apply*failed-grounding*property3
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
   -{ (<constraint> ^referent <r*1> ^property <p*1>)
      (<r*1> ^handle <value>)
      (<p*1> ^{ << name handle >> <a*2> } <prop>)}
    (<constraint>
          -^{ << movable category type number quantity multiple handle >> <a*3> } <v*2>)
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*property4
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
   -{ (<constraint> ^referent <r*1> ^property <p*1>)
      (<r*1> ^handle <value>)
      (<p*1> ^{ << name handle >> <a*2> } <prop>)}
   -{ (<pr> ^predicates <p*2>)
      (<constraint>
            ^{ << movable category number quantity type multiple >> <prop> } <value>)}
   -{ (<constraint> ^handle <value> ^property <p*3>)
      (<p*3> ^{ << name handle >> <a*3> } { <> category <prop> })}
   -{ (<s> ^constraints <c*1>)
      (<c*1> ^quantifier <q*1>)
      (<q*1> ^lt-referent <constraint>)}
    (<constraint> ^handle <h*1>)
    -->
    (<pr> ^predicates-copied true +)
}

sp {ground-referent*apply*failed-grounding*relation
    (state <s> ^proto-referent <pr> ^superstate <s*2> ^operator <o*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding index-semantic-memory >> <n*1> })
    (<s*2> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <v*1>)
    (<v*1> ^constraint <constraint>)
    (<constraint> -^handle <h*1> ^relation <value>)
    -->
    (<pr> ^predicates-copied true + ^relation <value> +)
}

sp {ground-referent*apply*failed-grounding*finish
    (state <s> ^quiescence t ^proto-referent <ref> ^superstate <s*1>
          ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    (<s*1> ^operator <o*2>)
    (<o*2> ^{ << double-constraints constraints >> <a*1> } <c>)
    -->
    (<c> ^ground-tested <c> + ^referent <ref> +)
}

sp {ground-referent*apply*failed-grounding*finish2
    (state <s> ^quiescence t ^proto-referent <ref> ^top-state <ts>
          ^top-state <t*1> ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<ts> ^dialog-object-list <dol>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list <ndol> +)
    (<objs> ^object <ref> +)
    (<ndol> ^referent <ref> + ^next <dol> +)
}

sp {ground-referent*apply*failed-grounding*finish3
    (state <s> ^quiescence t ^proto-referent <ref> ^segment <ss>
          ^top-state <t*1> ^operator <o*1>)
    (<ref> ^predicates-copied true)
    (<ss> ^dialog-object-list-access <dol>)
    (<t*1> ^dialog-world <d*1>)
    (<d*1> ^objects <objs>)
    (<o*1>
          ^name { << create-hypothetical quantifier failed-grounding >> <n*1> })
    -->
    (<ss> ^dialog-object-list-access <dol> -
           ^dialog-object-list-access <ndol> +)
    (<objs> ^object <ref> +)
    (<ndol> ^referent <ref> + ^next <dol> +)
}

sp {ground-referent*propose*index-semantic-memory
    (state <s> ^proto-referents none -^indexed-semantic-memory true
          ^name ground-referent ^quiescence t ^constraint-lt <c*1>)
   -{ (<s> ^superstate <s*1>)
      (<s*1> ^name evaluate-operator)}
    (<c*1> ^specifier definite)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name index-semantic-memory +)
}

sp {ground-referent*compare*index-semantic-memory
    (state <s> ^name ground-referent ^operator <op1> + ^operator <op2> +)
    (<op1> ^name index-semantic-memory)
    (<op2> ^name failed-grounding)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {ground-referent*apply*index-semantic-memory*smem*fail*no-change
    (state <ss> ^impasse no-change ^superstate <s>)
    (<s> ^operator <o*1> ^superstate <s*1>)
    (<o*1> ^name index-semantic-memory)
    (<s*1> ^operator <so>)
    -->
    (<s> ^failed-semantic-retrieval true + ^indexed-semantic-memory true +)
}

sp {propose*finish-ground-referent
    (state <s> ^name ground-referent)
   -{ (<s> ^candidate-set <c*1>)
      (<c*1> ^proto-referent <p*1>)
      (<p*1> ^object <obj>)
     -{ (<s> ^constraints <c*2>)
        (<c*2> ^referent <obj>)}}
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name finish-ground-referent +)
}

sp {ground-referent*apply*finish-ground-referent
    (state <s> ^quiescence t ^operator <op> ^segment <s*1> ^superstate <s*2>)
    (<op> ^name finish-ground-referent)
    (<s*1> ^last-merge <l*1>)
    (<l*1> ^assigner <a*1>)
    (<a*1> ^parent-receiver <as>)
    (<s*2> ^operator <so>)
    (<so> ^parameter <p> ^{ << double-constraints constraints >> <a*2> } <c>)
    -->
    (<as> ^ground-tested <p> +)
}

sp {comprehension*propose*termination-processing
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> -^processed-terminator <p*1> -^parse-failed-receiver <p*2>
          -^parse-failed-assigner <p*3> ^not-merged-receiver <ua>)
    (<ua> ^terminator <term>)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name termination-processing +)
}

sp {apply*termination-processing*semantics
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^semantics <sem> ^not-merged-receiver <uri>)
    (<uri> ^lt <l*1> ^semantics <sem2>)
    (<l*1> ^structure-type S)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
}

sp {apply*termination-processing*semantics*sentence
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^semantics <sem> ^not-merged-receiver <uri>)
    (<uri> ^lt <l*1> ^sentence <s*1>)
    (<l*1> ^structure-type S)
    (<s*1> ^semantics <sem2>)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
}

sp {apply*termination-processing*message-type*st
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name termination-processing)
    (<seg> ^not-merged-receiver <rec> ^semantics <sem>)
    (<rec> ^structure-type S ^message-type <ms-type>)
    -->
    (<sem> ^message-type <ms-type> +)
}

sp {termination-processing*propose*check-failure
    (state <s> ^checked-not-merged-receivers true
          ^checked-not-merged-assigners true ^name termination-processing
          ^superstate <s*1>)
    (<s*1> ^segment <seg>)
    (<seg> -^parse-failed-receiver <p*1> -^parse-failed-assigner <p*2>
          -^processed-terminator true)
   -{ (<seg> ^original-sentence <o*1>)
      (<o*1> ^processed-sentence true)}
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-failure +)
}

sp {apply*check-failure*monitor
    (state <s> ^name termination-processing ^operator <o*1> ^segment <seg>
          ^top-state <t*1>)
    (<o*1> ^name check-failure)
    (<seg> ^semantics <sem> ^original-sentence <o*2>)
    (<o*2> ^complete-sentence <os>)
    (<t*1> ^current-sentence-number <csn>)
    -->
    
}

sp {apply*check-failure*monitor*no-number
    (state <s> ^name termination-processing ^operator <o*1> ^segment <seg>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^current-sentence-number <csn>)}
    (<o*1> ^name check-failure)
    (<seg> ^semantics <sem> ^original-sentence <o*2>)
    (<o*2> ^complete-sentence <os>)
    -->
    
}

sp {apply*check-failure*success
    (state <s> ^segment <sp> -^failed-receiver <f*1> -^failed-assigner <f*2>
          ^operator <o*1> ^top-state <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^parser-testing true)}
    (<o*1> ^name check-failure)
    (<sp> ^semantics <s*1> ^original-sentence <cs>)
    (<s*1> ^message-type <mt>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^performed <p*1> +)
    (<p*1> ^dialog-event <de> +)
    (<de> ^type process-sentence + ^originator agent +)
    (<sp> ^processed-terminator true +)
    (<cs> ^processed-sentence true + ^processing-result success +)
}

sp {apply*check-failure*new-message
    (state <s> ^segment <s*1> -^failed-receiver <f*1> -^failed-assigner <f*2>
          ^operator <o*1> ^top-state <t*2>)
   -{ (<s> ^top-state <t*1>)
      (<t*1> ^parser-testing true)}
    (<o*1> ^name check-failure)
    (<s*1> ^semantics <sem>)
    (<sem> ^message-type <ms-type>)
    (<t*2> ^interaction <i*1>)
    (<i*1> ^status <status>)
    -->
    (<status> ^new-message <sem> +)
}

sp {termination-processing*propose*check-not-merged-assigners
    (state <s> ^name termination-processing
          -^checked-not-merged-assigners true)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-not-merged-assigners +)
}

sp {apply*check-not-merged-assigners
    (state <s> ^segment <ss> ^operator <op>)
    (<ss> -^not-merged-assigner <item>)
    (<op> ^name check-not-merged-assigners)
    -->
    (<s> ^checked-not-merged-assigners true +)
}

sp {termination-processing*propose*check-not-merged-receivers
    (state <s> ^checked-not-merged-assigners true
          -^checked-not-merged-receivers true ^name termination-processing)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name check-not-merged-receivers +)
}

sp {apply*check-not-merged-receivers
    (state <s> ^operator <o*1>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^not-merged-receiver <n*1>)
      (<n*1> ^lt <l*1>)
      (<l*1> ^structure-type { <> CP <> C <> S <s*2> })}
    (<o*1> ^name check-not-merged-receivers)
    -->
    (<s> ^checked-not-merged-receivers true +)
}

sp {comprehension*propose*clean-up-retrieved-stack
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^retrieved-stack <rs>)
    (<rs> ^prior <p*1> ^item <x>)
    (<p*1> ^item <x>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name clean-up-retrieved-stack +)
}

sp {comprehension*apply*clean-up-retrieved-stack
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name clean-up-retrieved-stack)
    (<seg> ^retrieved-stack <rs>)
    (<rs> ^prior <p> ^item <x>)
    (<p> ^item <x>)
    -->
    (<seg> ^retrieved-stack <rs> - ^retrieved-stack <p> +)
}

sp {comprehension*propose*failed-comprehension
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^original-sentence <is>)
    (<is> -^processed-sentence true ^processing-result failure)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name failed-comprehension +)
}

sp {comprehension*apply*failed-comprehension*no-new-word
    (state <s> ^name comprehension ^operator <op> ^segment <seg>)
    (<op> ^name failed-comprehension)
    (<seg> ^semantics <sem> ^original-sentence <is>)
    (<sem> ^interaction-status <status>)
   -{ (<status> ^failure <f*1>)
      (<f*1> ^type unknown-word)}
    -->
    (<sem> ^message-type failed-comprehension +)
    (<status> ^failure <f*2> +)
    (<f*2> ^type unknown-word +)
}

sp {apply*failed-comprehension*external
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name failed-comprehension)
    (<seg> ^original-sentence <os>)
    -->
    (<os> ^processed-sentence true + ^processing-result failure +)
}

sp {apply*failed-comprehension-interaction-status
    (state <s> ^operator <o*1> ^segment <s*1> ^top-state <t*1>)
    (<o*1> ^name failed-comprehension)
    (<s*1> ^semantics <sem>)
    (<sem> ^interaction-status <i*2>)
    (<t*1> ^interaction <i*1>)
    (<i*1> ^status <status>)
    (<i*2> ^<att> <value>)
    -->
    (<status> ^<att> <value> +)
}

sp {comprehension*elaborate*possible-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
    (<assigner> -^dont-merge true -^parent-receiver <receiver>
          ^structure-type <stype> ^lt <lt>)
   -{ (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<l*3> ^after <after>)}
    (<receiver> -^dont-merge true ^structure-type <stype>)
   -{ (<assigner> ^lt <l*4> ^decision-count { < <d*1> <dl-dc> })
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count <d*1>)}
   -{ (<assigner> ^lt <l*5> ^decision-count { > <d*2> <dl-dc2> })
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count <d*2>)}
   -{ (<assigner> ^lt <l*6>)
      (<l*6> ^directional <x>)
      (<receiver> ^lt <l*7>)
      (<l*7> ^directional { <> <x> <d*3> })}
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-merge*unknown
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<assigner> ^parent-receiver <pr> ^lt <l*3>)
      (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <after>)
      (<l*3> ^after <after>)}
    (<assigner> ^structure-type U -^parent-receiver <receiver>)
    (<receiver> -^structure-type <s*1> -^dont-merge true)
   -{ (<assigner> ^lt <l*4> ^decision-count { < <d*1> <dl-dc> })
      (<l*4> ^relative-position before)
      (<receiver> ^decision-count <d*1>)}
   -{ (<assigner> ^lt <l*5> ^decision-count { > <d*2> <dl-dc2> })
      (<l*5> ^relative-position after)
      (<receiver> ^decision-count <d*2>)}
    -->
    (<s> ^possible-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*propose*merge
    (state <s> ^name comprehension ^possible-merge <pm>)
    (<pm> ^receiver <receiver> ^assigner <assigner> ^type <type>)
    -->
    (<s> ^operator <op> +)
    (<op> ^name merge + ^receiver <receiver> + ^assigner <assigner> +
           ^type <type> +)
}

sp {comprehension*reject*possible-merge*exclusive-earlier
    (state <s> ^name comprehension ^operator <op1> +
          ^possible-future-merge <pm>)
    (<op1> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*1>)
      (<l*1> ^attachment immediate)}
    (<pm> ^receiver <receiver2> ^assigner { <> <assigner> <assigner2> })
   -{ (<s> ^possible-future-merge { <> <pm> <pfm> })
      (<pfm> ^receiver <receiver2>)}
    (<receiver> ^decision-count <dc>)
    (<receiver2> ^decision-count { < <dc> <d*1> })
    (<assigner> ^parent-receiver <pr> ^lt <l*2>)
    (<assigner2> ^parent-receiver <pr> ^lt <lt2>)
    (<l*2> ^exclusive <lt2>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*merge*terminate*next-word
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge)
    (<op2>
          ^name { << next-word next-retrieved-stack termination-processing >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*indifferent-different-receiver
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <receiver>)
    (<op2> ^name merge ^receiver { <> <receiver> <r*1> })
    -->
    (<s> ^operator <op1> = <op2>)
}

sp {comprehension*compare*merge*prefer*first*same-receiver
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<ass1> ^parent-receiver <ps> ^lt <l*1>)
    (<ass2> ^parent-receiver <ps> ^structure-type <bt> ^lt <ltass2>)
    (<l*1> ^before <ltass2>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*same-parent-receiver
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<op2> ^name merge ^receiver { <> <rec> <r*1> } ^assigner <ass2>)
    (<ass1> ^parent-receiver <ps> ^lt <l*1>)
    (<ass2> ^parent-receiver <ps> ^structure-type <bt> ^lt <ltass2>)
    (<l*1> ^before <ltass2>)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp2
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<rec> -^structure-type PP)
   -{ (<rec> ^lt <l*1>)
      (<l*1> ^attachment immediate)}
    (<op2> ^receiver <rec> ^name merge ^assigner <ass2>)
    (<ass1> ^decision-count <dc> ^lt <lt1>)
    (<ass2> ^lt <ltass2> ^decision-count { > <dc> <d*1> })
    (<lt1> -^before <ltass2>)
    -->
    (<s> ^operator <op1> -)
}

sp {comprehension*compare*merge*prefer*most-recent*PP-shared-parent-receiver
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<rec> ^structure-type PP)
    (<op2> ^receiver <rec> ^name merge ^assigner <ass2>)
    (<ass1> ^decision-count <dc> ^parent-receiver <pr> ^lt <lt1>)
    (<ass2> ^decision-count <dc> ^parent-receiver <pr> ^lt <ltass2>)
    (<lt1> -^{ << after before >> <a*1> } <ltass2>)
    (<ltass2> -^{ << after before >> <a*2> } <lt1>)
    -->
    (<s> ^operator <op2> = <op1>)
}

sp {comprehension*compare*merge*prefer*most-recent*attachment-immediate
    (state <s> ^name comprehension ^operator <op1> +
          ^operator { <> <op1> <op2> } +)
    (<op1> ^name merge ^assigner <ass1> ^receiver <rec>)
   -{ (<ass1> ^lt <l*1>)
      (<l*1> ^required true)}
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<rec> ^lt <l*2>)
    (<l*2> ^attachment immediate)
    (<ass1> ^decision-count <dc>)
    (<ass2> ^decision-count { > <dc> <d*1> })
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*prefer*attachment-immediate*follow
    (state <s> ^name comprehension ^operator <op1> +
          ^operator { <> <op1> <op2> } +)
    (<op1> ^name merge ^receiver <rec> ^assigner <ass1>)
    (<op2> ^name merge ^receiver <rec> ^assigner <ass2>)
    (<ass1> ^lt <l*1> ^decision-count <dc>)
    (<l*1> ^attachment immediately-follow)
    (<ass2> ^decision-count { < <dc> <d*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*first-word*prefer
    (state <s> ^name comprehension ^operator <op1> +
          ^operator { <> <op1> <op2> } +)
    (<op1> ^name merge ^receiver <r*1>)
   -{ (<op2> ^receiver <r*2>)
      (<r*2> ^current-word <c*2>)
      (<c*2> ^first-word true)}
    (<op2> ^name merge)
    (<r*1> ^current-word <c*1>)
    (<c*1> ^first-word true)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*next-word
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^current-word <cw> ^input-sentence <sent>)
    (<cw> ^processed true)
    (<sent> -^processing-result failure ^spelling <s*1>)
    -->
    (<s> ^operator <o> + ^operator <o> = ^operator <o> <)
    (<o> ^name next-word +)
}

sp {comprehension*apply*next-word*decision-count-threshold*initial
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^decision-count-threshold <d*1>)
    (<o*1> ^name next-word)
    -->
    (<seg> ^decision-count-threshold (+ 300 (dc)) +)
}

sp {comprehension*apply*next-word*decision-count-threshold
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^decision-count-threshold <dct>)
    -->
    (<seg> ^decision-count-threshold <dct> -
           ^decision-count-threshold (+ 300 (dc)) +)
}

sp {comprehension*apply*next-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^prior-word <pw> ^current-word <old-w> ^input-sentence <i>)
    (<i> ^next { <> nil <n> })
    -->
    (<seg> ^input-sentence <i> - ^input-sentence <n> + ^current-word <n> +
           ^current-word <old-w> - ^prior-word <pw> - ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word*no-prior
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> -^prior-word <pw> ^current-word <old-w> ^input-sentence <i>)
    (<o*1> ^name next-word)
    (<i> ^next <n>)
    -->
    (<seg> ^input-sentence <i> - ^input-sentence <n> + ^current-word <n> +
           ^current-word <old-w> - ^prior-word <old-w> +)
}

sp {comprehension*apply*next-word*mark-first-word
    (state <s> ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^current-word <c*1> ^input-sentence <i*1>)
    (<c*1> ^spelling *)
    (<i*1> ^next <n>)
    -->
    (<n> ^first-word true +)
}

sp {comprehension*apply*next-word*clean-up-failure
    (state <s> ^segment <seg> ^operator <o*1>)
    (<seg> ^failed-construction true)
    (<o*1> ^name next-word)
    -->
    (<seg> ^failed-construction true -)
}

sp {comprehension*propose*process-missing-assigner*before
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass1>)
    (<ass1> -^failed merge ^structure-type <stype> ^parent-receiver <pr>
          ^lt <l*1>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <stype>)}
    (<l*1> ^before <ass-before>)
   -{ (<seg> ^not-merged-assigner <nma>)
      (<nma> ^parent-receiver <pr> ^lt <ass-before>)}
    (<ass-before> -^optional true)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*before-already-merged
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass1> ^merged-assigner <nma>)
    (<ass1> -^failed merge ^parent-receiver <pr> ^structure-type <stype>
          ^lt <l*1>)
    (<nma> ^parent-receiver <pr> ^lt <ass-before>)
    (<l*1> ^before <ass-before>)
    -->
    (<seg> ^not-merged-assigner <ass1> -)
}

sp {comprehension*propose*process-missing-assigner*before*x
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass2>
          ^not-merged-assigner { <> <ass2> <ass1> } ^not-merged-receiver <nmr>)
   -{ (<ass2> ^lt <l*3>)
      (<l*3> ^required true)}
    (<ass2> ^parent-receiver <pr> ^lt <l*2>
          ^structure-type { <> <until-pp> <> CP <> IF-CLAUSE <stype> }
          -^decision-count { > <dc> <d*2> })
    (<ass1> ^parent-receiver <pr> ^structure-type <until-pp> ^lt <ass-before>
          ^decision-count <d*1>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <until-pp>)}
   -{ (<seg> ^not-merged-assigner { <> <ass1> <> <ass2> <ass3> })
      (<ass3> ^parent-receiver <pr> ^structure-type <until-pp> ^lt <l*4>)
      (<l*4> ^before <ass-before>)}
    (<l*2> ^before <ass-before>)
    (<nmr> ^decision-count { > <d*1> <dc> } ^lt <l*1>)
    (<l*1> ^converts-to <until-pp>)
    -->
    (<seg> ^not-merged-assigner <ass2> -)
}

sp {comprehension*propose*process-missing-assigner*new
    (state <s> ^name comprehension ^operator <o*1> ^segment <seg>)
    (<o*1> ^name next-word)
    (<seg> ^not-merged-assigner <ass2> ^not-merged-receiver <nmr>
          ^not-merged-assigner { <> <ass2> <ass1> })
   -{ (<ass2> ^lt <l*1>)
      (<l*1> ^required true)}
   -{ (<s> ^possible-future-merge <pm> ^possible-future-merge <pm2>)
      (<pm> ^receiver <nmr> ^assigner <a*1>)
      (<pm2> ^assigner <ass2> ^receiver <rec2>)
      (<a*1> ^parent-receiver <rec2>)}
    (<nmr> ^lt <lt> ^decision-count <d*1>)
    (<lt> ^attachment immediate ^converts-to <new-type>)
   -{ (<seg> ^not-merged-receiver <n*1>)
      (<n*1> ^structure-type <new-type>)}
    (<ass2> ^decision-count <dc2> ^parent-receiver <pr>
          ^structure-type <stype>)
   -{ (<s> ^possible-future-merge <pfm4>)
      (<pfm4> ^receiver <nmr> ^assigner <ass4>)
      (<ass4> ^structure-type <new-type> ^decision-count { > <dc2> <d*2> })}
    (<ass1> ^structure-type <new-type> ^parent-receiver <pr>
          ^decision-count { >= <dc2> < <d*1> <dc> })
    -->
    (<seg> ^not-merged-assigner <ass2> -)
}

sp {comprehension*elaborate*detect*prefered*verb-PP-directional-merge*so*no*DP-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner1> ^not-merged-assigner <assigner2>
          ^not-merged-receiver <receiver>)
    (<assigner1> ^parent-receiver <pr> ^lt <l*3> ^decision-count <da-dc>)
    (<pr> ^structure-type V ^lt <l*4>)
    (<l*3> ^structure-type PP)
    (<l*4> ^directional { << true >> <d*2> })
    (<assigner2> ^lt <l*5> ^decision-count { > <da-dc> <d*3> })
    (<l*5> ^structure-type PP)
    (<receiver> ^lt <l*1> ^lt <l*2>)
    (<l*1> ^converts-to PP)
    (<l*2> ^directional { << true >> <d*1> })
    -->
    (<seg> ^not-possible-merge <npm> +)
    (<npm> ^receiver <receiver> + ^assigner <assigner2> +)
}

sp {comprehension*elaborate*detect*prefered*verb-PP-directional-merge*so*probable*DP-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner1> ^not-merged-receiver <receiver>)
    (<assigner1> ^parent-receiver <pr> ^lt <l*3> ^decision-count <da-dc>)
    (<pr> ^structure-type V ^lt <l*4>)
    (<l*3> ^structure-type PP)
    (<l*4> ^directional { << maybe true >> <d*3> })
    (<receiver> ^lt <l*1> ^decision-count { > <da-dc> <d*1> } ^lt <l*2>)
    (<l*1> ^converts-to PP)
    (<l*2> ^directional { << maybe true >> <d*2> })
    -->
    (<seg> ^probable-merge <npm> +)
    (<npm> ^receiver <receiver> + ^assigner <assigner1> +)
}

sp {comprehension*elaborate*possible-future-merge
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<seg> ^merged-assigner <ass3>)
      (<assigner> ^parent-receiver <pr> ^lt <after>)
      (<ass3> ^parent-receiver <pr> ^lt <l*4>)
      (<l*4> ^after <after>)}
   -{ (<s> ^possible-future-merge <p*1>)
      (<seg> ^not-merged-assigner <ass2>)
      (<p*1> ^assigner <ass2>)
      (<assigner> ^parent-receiver <pr> ^lt <before>)
      (<ass2> ^parent-receiver <pr> ^lt <l*5>)
      (<l*5> ^before <before>)}
    (<assigner> -^parent-receiver <receiver> ^decision-count <da-dc>
          ^structure-type <stype>)
   -{ (<assigner> ^lt <l*6> ^decision-count { < <d*2> <dl-dc> })
      (<l*6> ^relative-position before)
      (<receiver> ^decision-count <d*2>)}
   -{ (<assigner> ^lt <l*7> ^decision-count { > <d*3> <dl-dc2> })
      (<l*7> ^relative-position after)
      (<receiver> ^decision-count <d*3>)}
   -{ (<assigner> ^lt <l*8>)
      (<l*8> ^directional <x>)
      (<receiver> ^lt <l*9>)
      (<l*9> ^directional { <> <x> <d*4> })}
   -{ (<seg> ^not-possible-merge <npm>)
      (<npm> ^receiver <receiver> ^assigner <assigner>)}
    (<receiver> ^decision-count { > <da-dc> <d*1> } ^lt <l*3>)
    (<l*3> ^converts-to <stype>)
    -->
    (<s> ^possible-future-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*elaborate*possible-future-merge*super-converts
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^lexical-item-spelling <l*2>)}
   -{ (<seg> ^merged-assigner <ass3>)
      (<assigner> ^parent-receiver <pr> ^lt <after>)
      (<ass3> ^parent-receiver <pr> ^lt <l*4>)
      (<l*4> ^after <after>)}
   -{ (<s> ^possible-future-merge <p*1>)
      (<seg> ^not-merged-assigner <ass2>)
      (<p*1> ^assigner <ass2>)
      (<assigner> ^parent-receiver <pr> ^lt <before>)
      (<ass2> ^parent-receiver <pr> ^lt <l*5>)
      (<l*5> ^before <before>)}
    (<assigner> -^parent-receiver <receiver> ^decision-count <da-dc>
          ^structure-type <stype>)
   -{ (<assigner> ^lt <l*6> ^decision-count { < <d*2> <dl-dc> })
      (<l*6> ^relative-position before)
      (<receiver> ^decision-count <d*2>)}
   -{ (<assigner> ^lt <l*7> ^decision-count { > <d*3> <dl-dc2> })
      (<l*7> ^relative-position after)
      (<receiver> ^decision-count <d*3>)}
   -{ (<assigner> ^lt <l*8>)
      (<l*8> ^directional <x>)
      (<receiver> ^lt <l*9>)
      (<l*9> ^directional { <> <x> <d*4> })}
   -{ (<seg> ^not-possible-merge <npm>)
      (<npm> ^receiver <receiver> ^assigner <assigner>)}
    (<receiver> ^decision-count { > <da-dc> <d*1> } ^lt <l*3>)
    (<l*3> ^super-converts-to <stype>)
    -->
    (<s> ^possible-future-merge <pm> +)
    (<pm> ^receiver <receiver> + ^assigner <assigner> + ^type normal +)
}

sp {comprehension*propose*process-phrase-end
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^merged-assigner <p> ^retrieved-stack <r*1>)
    (<p> ^parent-receiver <ps> ^merged-receiver <m*1>)
   -{ (<seg> ^not-merged-assigner <uai>)
      (<uai> ^parent-receiver <ps> ^lt <l*2>)
      (<l*2> ^required true)}
   -{ (<s> ^possible-merge <pm>)
      (<pm> ^assigner <a*1> ^receiver { <> <ps> <nmr> })
      (<a*1> ^parent-receiver <ps>)}
   -{ (<s> ^possible-future-merge <pm2>)
      (<pm2> ^assigner <a*2> ^receiver { <> <ps> <nmr> })
      (<a*2> ^parent-receiver <ps>)}
    (<ps> ^lt <l*1> -^structure-type <nstruct>)
    (<l*1> ^converts-to <nstruct>)
    (<r*1> ^item { <> <ps> <> <m*1> <item> })
    (<item> ^structure-type <s-type>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-phrase-end + ^assigner-parent <ps> +)
}

sp {comprehension*propose*process-phrase-end2
    (state <s> ^name comprehension ^segment <seg>)
    (<seg> ^not-merged-receiver <ps> ^retrieved-stack <r*1>)
   -{ (<seg> ^not-merged-assigner <uai>)
      (<uai> ^parent-receiver <ps> ^lt <l*2>)
      (<l*2> ^required true)}
   -{ (<s> ^possible-merge <pm>)
      (<pm> ^assigner <a*1> ^receiver { <> <ps> <nmr> })
      (<a*1> ^parent-receiver <ps>)}
   -{ (<s> ^possible-future-merge <pm2>)
      (<pm2> ^assigner <a*2> ^receiver { <> <ps> <nmr> })
      (<a*2> ^parent-receiver <ps>)}
    (<ps> ^lt <l*1> -^structure-type <nstruct>)
    (<l*1> ^converts-to <nstruct>)
    (<r*1> ^item { <> <ps> <item> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-phrase-end + ^assigner-parent <ps> +)
}

sp {apply*process-phrase-end
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name process-phrase-end ^assigner-parent <ps>)
    (<ps> ^structure-type <oldstruct> ^lt <l*1>)
    (<l*1> ^converts-to { <> <oldstruct> <nstruct> })
    -->
    (<ps> ^structure-type <nstruct> + ^structure-type <oldstruct> -)
    (<seg> ^not-merged-receiver <ps> +)
}

sp {comprehension*compare*process-phrase-end*prefer-merge-before-process-end2
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-phrase-end ^assigner-parent <ap>)
    (<op2> ^name merge ^assigner <a*2>)
   -{ (<op2> ^assigner <a*1>)
      (<a*1> ^parent-receiver <ap>)}
    (<a*2> ^lt <l*1>)
    (<l*1> ^required true)
    -->
    (<s> ^operator <op1> < <op2>)
}

sp {elaborate*assigner
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^merged-assigner <ass>)
    -->
    (<s> ^assigner <ass> +)
}

sp {propose*process-semantics*referent
    (state <s> ^name comprehension -^deep-complement true ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> -^processed-semantics <sg> ^lt <l*1>)
    (<m*1> ^referent <sg>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*no-local-referent*lt-referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <sg> ^lt <l*1>)
    (<mre> -^referent <r*1> ^lt-referent <sg>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*no-referent*head
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^constraint <con> -^lt-referent <l*2> -^referent <r*1> ^head <h*1>)
    (<h*1> ^referent <head>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <head> +)
}

sp {propose*process-semantics*referent-nil*deeper*constraint
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <con> ^lt <l*1>)
    (<mre> -^referent <r*1> -^lt-referent <l*3> ^constraint <con> ^head <h*1>)
   -{ (<mre> ^complement <c*1>)
      (<c*1> ^head <h*2>)
      (<h*2> ^head <h*3>)
      (<h*3> ^lt-referent <l*4>)}
    (<con> -^referent <r*2>)
   -{ (<con> ^property <p*1>)
      (<p*1> ^handle possessive)}
    (<h*1> ^lt-referent <l*2>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <con> +)
}

sp {propose*process-semantics*receiver
    (state <s> ^name comprehension ^assigner <ass>)
   -{ (<ass> ^lt <l*1>)
      (<l*1> ^semantic-structure *embed*)}
    (<ass> ^merged-receiver <mr> -^processed-semantics <sg>)
    (<mr> ^lt-referent <sg> ^lt <l*2>)
    (<l*2> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^value <sg> +)
}

sp {propose*process-semantics*receiver*embed
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^lt <lt> ^merged-receiver <mr> ^parent-receiver <p*1>)
    (<lt> ^semantic-structure *embed* ^embed-structure <es>)
    (<mr> ^lt-referent <sg> -^processed-semantics <sg> ^semantics <embed>
          ^lt <l*1>)
    (<p*1> ^semantics <s*1>)
    (<s*1> ^<es> <embed>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^receiver <mr> + ^embed <embed> +
           ^attribute <ss> + ^value <sg> +)
}

sp {propose*process-semantics*preposition-relation*head*referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> ^merged-receiver <mre> -^processed-semantics <sg> ^lt <l*1>)
   -{ (<mre> ^lt <l*3>)
      (<l*3> ^relation-type ternary)}
    (<mre> ^head <h*1> ^lt <l*2>)
    (<h*1> ^referent <sg>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle <spr>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sp-x> +)
    (<sp-x> ^handle <spr> + ^2 <sg> +)
}

sp {propose*process-semantics*DP-with-of-DP
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> ^structure-type DP ^complement <c*1> ^complement <c*2> ^head <h*1>)
    (<c*2> ^head <h1>)
    (<h1> -^referent <r*2> ^head <h*2>)
    (<h*1> ^lt-referent <l*3>)
    (<h*2> ^lt-referent <game>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<c*1> ^lt <l*2>)
    (<l*3> ^handle <name>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sr> + ^value <xx> +)
    (<sr> ^handle of1 + ^2 <xx> +)
    (<xx> ^handle <name> + ^2 <game> +)
}

sp {propose*process-semantics*DP-with-of-DP*referent
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics <sg> ^merged-receiver <mre> ^lt <l*1>)
    (<mre> -^referent <r*1> ^structure-type DP ^complement <c*1>
          ^complement <c*2> ^head <h*1>)
    (<h*1> ^lt-referent <l*3>)
    (<c*2> ^head <head>)
    (<head> ^referent <ref>)
    (<l*1> ^semantic-structure { <> *copy* <> *embed* <ss> })
    (<c*1> ^lt <l*2>)
    (<l*3> ^handle <name>)
    (<l*2> ^relation <r*2>)
    (<r*2> ^handle of1)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^assigner <ass> + ^attribute <ss> +
           ^relation <sr> + ^value <xx> +)
    (<sr> ^handle of1 + ^2 <xx> +)
    (<xx> ^handle <name> + ^2 <ref> +)
}

sp {propose*process-semantics*copy
    (state <s> ^name comprehension ^assigner <ass>)
   -{ (<ass> ^lt <l*2>)
      (<l*2> ^copy-structure <c*1>)}
    (<ass> ^lt <l*1> ^merged-receiver <m*1> -^processed-semantics <sg>)
    (<l*1> ^semantic-structure *copy*)
    (<m*1> ^semantics <sg>)
   -{ (<sg> -^<att> <a*1>)
      (<ass> ^merged-receiver <m*2>)
      (<m*2> ^semantics <sg>)}
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^copy-semantics <sg> + ^assigner <ass> +)
}

sp {propose*process-semantics*embed
    (state <s> ^name comprehension ^assigner <ass>)
    (<ass> -^processed-semantics *embed* ^lt <lt> ^merged-receiver <m*1>)
    (<lt> ^semantic-structure *embed* ^embed-structure <embed>)
    (<m*1> ^semantics <sg>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-semantics + ^embed-semantics true +
           ^embed-structure <embed> + ^assigner <ass> +)
}

sp {comprehension*compare*process-semantics
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-semantics)
    (<op2>
          ^name { << process-phrase-end failed-referent-grounding process-missing-assigner merge comprehend-word >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*process-semantics*prefer-specific
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-semantics ^relation <r*1>)
    (<op2> -^relation <r*2> ^name process-semantics)
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*process-semantics*process-semantics-copy
    (state <s> ^operator <o>)
    (<o> -^copy-structure <c*1> ^name process-semantics ^copy-semantics <sem2>
          ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> ^parent-receiver <p*1>)
    (<m*1> ^semantics <sem2>)
    (<p*1> ^semantics <sem>)
    (<sem2> ^<att> <val>)
    -->
    (<sem> ^<att> <val> +)
    (<ass> ^processed-semantics <sem2> +)
}

sp {apply*process-semantics*process-semantics-embed
    (state <s> ^operator <o>)
    (<o> ^embed-semantics true ^name process-semantics
          ^embed-structure <embed> ^assigner <ass>)
    (<ass> ^merged-receiver <m*1> ^parent-receiver <p*1>)
    (<m*1> ^semantics <sem2>)
    (<p*1> ^semantics <sem>)
    -->
    (<sem> ^<embed> <sem2> +)
    (<ass> ^processed-semantics *embed* +)
}

sp {apply*process-semantics*process-semantics-embed*receiver
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^embed <embed> ^receiver <mr> ^value <value>
          ^attribute <att>)
    -->
    (<embed> ^<att> <value> +)
    (<mr> ^processed-semantics <value> +)
}

sp {apply*process-semantics*create-empty*semantics
    (state <s> ^operator <o>)
    (<o> ^name process-semantics ^assigner <a*1>)
    (<a*1> ^parent-receiver <rec>)
    (<rec> -^semantics <sem>)
    -->
    (<rec> ^semantics <sem> +)
}

sp {apply*process-semantics*simple
    (state <s> ^operator <op>)
    (<op> -^extra-attribute <of> -^relation <sr> ^name process-semantics
          ^assigner <ass> ^value <value> ^attribute { <> relation <att> })
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    -->
    (<sem> ^<att> <value> +)
    (<ass> ^processed-semantics <value> +)
}

sp {apply*process-semantics*relation
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> ^name process-semantics ^attribute relation ^assigner <ass>
          ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> -^3 <v*1> ^handle <sp> ^2 <sg>)
    -->
    (<sem> ^predicate <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^value <v*1> ^name process-semantics ^assigner <ass>
          ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sr> ^2 <sg> ^handle <sp>)
   -{ (<sg> ^handle <sghandle> ^2 <sg2>)}
    -->
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sg> + ^item-type predicate +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*relation*other*deep
    (state <s> ^operator <op> ^assigner <ass>)
    (<op> -^relation2 <r*1> ^name process-semantics ^assigner <ass>
          ^value <sg> ^attribute { <> relation <att> } ^relation <sr>)
    (<ass> ^parent-receiver <p*1>)
    (<p*1> ^semantics <sem>)
    (<sg> ^handle <sghandle> ^2 <sg2>)
    (<sr> ^2 <sg> ^handle <sp>)
    -->
    (<sem> ^<att> <sr2> +)
    (<sr2> ^handle <sp> + ^2 <sgx> + ^item-type predicate +)
    (<sgx> ^handle <sghandle> + ^2 <sg2> +)
    (<ass> ^processed-semantics <sg> +)
}

sp {apply*process-semantics*simple*item-type*predicate
    (state <s> ^operator <op>)
    (<op> -^extra-attribute <of> ^name process-semantics ^attribute predicate
          ^value <value>)
    (<value> -^item-type <i*1>)
    -->
    (<value> ^item-type predicate +)
}

sp {apply*process-semantics*simple*item-type*action
    (state <s> ^operator <op>)
    (<op> ^name process-semantics ^attribute action ^value <value>)
    (<value> -^item-type <i*1>)
    -->
    (<value> ^item-type action +)
}

sp {apply*initialize-rosie*sentence-number
    (state <s> ^name rosie ^operator <o*1>)
    (<o*1> ^name initialize-rosie)
    -->
    (<s> ^current-sentence-number 1 + ^max-sentence-number 13 +
           ^game-scripting true +)
}

sp {elaborate*state*sentence-1*the-name-of-the-puzzle-is-eight-puzzle
    (state <s> ^current-sentence-number 1 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the name of the puzzle is eight-puzzle.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling name + ^next <w2> +)
    (<w2> ^spelling of + ^next <w3> +)
    (<w3> ^spelling the + ^next <w4> +)
    (<w4> ^spelling puzzle + ^next <w5> +)
    (<w5> ^spelling is + ^next <w6> +)
    (<w6> ^spelling eight-puzzle + ^next <w7> +)
    (<w7> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-2*init-8puzzle
    (state <s> ^current-sentence-number 2 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |init-8puzzle.| +)
    (<w0> ^spelling init-8puzzle + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-3*ok
    (state <s> ^current-sentence-number 3 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-4*if-a-block-is-on-a-location-that-is-adjacent-to-a-clear-location-then-you-can-move-the-block-onto-the-clear-location
    (state <s> ^current-sentence-number 4 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a block is on a location that is adjacent to a clear location then you can move the block onto the clear location.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling block + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling on + ^next <w5> +)
    (<w5> ^spelling a + ^next <w6> +)
    (<w6> ^spelling location + ^next <w7> +)
    (<w7> ^spelling that + ^next <w8> +)
    (<w8> ^spelling is + ^next <w9> +)
    (<w9> ^spelling adjacent + ^next <w10> +)
    (<w10> ^spelling to + ^next <w11> +)
    (<w11> ^spelling a + ^next <w12> +)
    (<w12> ^spelling clear + ^next <w13> +)
    (<w13> ^spelling location + ^next <w14> +)
    (<w14> ^spelling then + ^next <w15> +)
    (<w15> ^spelling you + ^next <w16> +)
    (<w16> ^spelling can + ^next <w17> +)
    (<w17> ^spelling move + ^next <w18> +)
    (<w18> ^spelling the + ^next <w19> +)
    (<w19> ^spelling block + ^next <w20> +)
    (<w20> ^spelling onto + ^next <w21> +)
    (<w21> ^spelling the + ^next <w22> +)
    (<w22> ^spelling clear + ^next <w23> +)
    (<w23> ^spelling location + ^next <w24> +)
    (<w24> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-5*if-a-location-is-next-to-an-object-but-it-is-not-diagonal-with-the-object-then-it-is-adjacent-to-the-object
    (state <s> ^current-sentence-number 5 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is next to an object but it is not diagonal with the object then it is adjacent to the object.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling next + ^next <w5> +)
    (<w5> ^spelling to + ^next <w6> +)
    (<w6> ^spelling an + ^next <w7> +)
    (<w7> ^spelling object + ^next <w8> +)
    (<w8> ^spelling but + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling not + ^next <w12> +)
    (<w12> ^spelling diagonal + ^next <w13> +)
    (<w13> ^spelling with + ^next <w14> +)
    (<w14> ^spelling the + ^next <w15> +)
    (<w15> ^spelling object + ^next <w16> +)
    (<w16> ^spelling then + ^next <w17> +)
    (<w17> ^spelling it + ^next <w18> +)
    (<w18> ^spelling is + ^next <w19> +)
    (<w19> ^spelling adjacent + ^next <w20> +)
    (<w20> ^spelling to + ^next <w21> +)
    (<w21> ^spelling the + ^next <w22> +)
    (<w22> ^spelling object + ^next <w23> +)
    (<w23> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-6*if-a-location-is-not-below-an-object-then-it-is-clear
    (state <s> ^current-sentence-number 6 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if a location is not below an object then it is clear.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling a + ^next <w2> +)
    (<w2> ^spelling location + ^next <w3> +)
    (<w3> ^spelling is + ^next <w4> +)
    (<w4> ^spelling not + ^next <w5> +)
    (<w5> ^spelling below + ^next <w6> +)
    (<w6> ^spelling an + ^next <w7> +)
    (<w7> ^spelling object + ^next <w8> +)
    (<w8> ^spelling then + ^next <w9> +)
    (<w9> ^spelling it + ^next <w10> +)
    (<w10> ^spelling is + ^next <w11> +)
    (<w11> ^spelling clear + ^next <w12> +)
    (<w12> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-7*final-8puzzle
    (state <s> ^current-sentence-number 7 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |final-8puzzle.| +)
    (<w0> ^spelling final-8puzzle + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-8*the-goal-is-that-there-are-eight-matched-locations
    (state <s> ^current-sentence-number 8 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |the goal is that there are eight matched locations.| +)
    (<w0> ^spelling the + ^next <w1> +)
    (<w1> ^spelling goal + ^next <w2> +)
    (<w2> ^spelling is + ^next <w3> +)
    (<w3> ^spelling that + ^next <w4> +)
    (<w4> ^spelling there + ^next <w5> +)
    (<w5> ^spelling are + ^next <w6> +)
    (<w6> ^spelling eight + ^next <w7> +)
    (<w7> ^spelling matched + ^next <w8> +)
    (<w8> ^spelling locations + ^next <w9> +)
    (<w9> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-9*if-the-color-of-a-location-is-the-color-of-the-block-that-is-on-the-location-then-the-location-is-matched
    (state <s> ^current-sentence-number 9 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> +
           ^complete-sentence |if the color of a location is the color of the block that is on the location then the location is matched.| +)
    (<w0> ^spelling if + ^next <w1> +)
    (<w1> ^spelling the + ^next <w2> +)
    (<w2> ^spelling color + ^next <w3> +)
    (<w3> ^spelling of + ^next <w4> +)
    (<w4> ^spelling a + ^next <w5> +)
    (<w5> ^spelling location + ^next <w6> +)
    (<w6> ^spelling is + ^next <w7> +)
    (<w7> ^spelling the + ^next <w8> +)
    (<w8> ^spelling color + ^next <w9> +)
    (<w9> ^spelling of + ^next <w10> +)
    (<w10> ^spelling the + ^next <w11> +)
    (<w11> ^spelling block + ^next <w12> +)
    (<w12> ^spelling that + ^next <w13> +)
    (<w13> ^spelling is + ^next <w14> +)
    (<w14> ^spelling on + ^next <w15> +)
    (<w15> ^spelling the + ^next <w16> +)
    (<w16> ^spelling location + ^next <w17> +)
    (<w17> ^spelling then + ^next <w18> +)
    (<w18> ^spelling the + ^next <w19> +)
    (<w19> ^spelling location + ^next <w20> +)
    (<w20> ^spelling is + ^next <w21> +)
    (<w21> ^spelling matched + ^next <w22> +)
    (<w22> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-10*ok
    (state <s> ^current-sentence-number 10 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |ok.| +)
    (<w0> ^spelling ok + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-11*done
    (state <s> ^current-sentence-number 11 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |done.| +)
    (<w0> ^spelling done + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-12*init-8puzzle
    (state <s> ^current-sentence-number 12 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |init-8puzzle.| +)
    (<w0> ^spelling init-8puzzle + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {elaborate*state*sentence-13*yes
    (state <s> ^current-sentence-number 13 ^name rosie)
    -->
    (<s> ^current-sentence <seg> +)
    (<seg> ^input-sentence <first> + ^current-word <first> +
           ^original-sentence <first> + ^expected nil +)
    (<first> ^spelling * + ^next <w0> + ^complete-sentence |yes.| +)
    (<w0> ^spelling yes + ^next <w1> +)
    (<w1> ^spelling |.| + ^next nil +)
}

sp {comprehension*propose*record-decision-counts
    (state <s> ^name comprehension ^segment <cs>)
    (<cs> ^not-merged-assigner <na>)
    (<na> -^decision-count <d*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name record-decision-counts + ^not-merged <na> +)
}

sp {comprehension*propose*record-decision-counts*receiver
    (state <s> ^name comprehension ^segment <cs>)
    (<cs> ^not-merged-receiver <na>)
    (<na> -^decision-count <d*1>)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name record-decision-counts + ^not-merged <na> +)
}

sp {comprehension*compare*record-decision-counts
    (state <s> ^name comprehension ^operator <op2> + ^operator <op1> +)
    (<op2> ^name record-decision-counts)
    (<op1> ^name { << comprehend-word comprehend-construction >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehension*propose*record-decision-counts*rule
    :o-support
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^{ << not-merged-receiver not-merged-assigner >> <a*1> } <nm>)
    (<nm> -^decision-count <d*1>)
    -->
    (<nm> ^decision-count (dc) +)
}

sp {apply*merge
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^repeatable true)}
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    (<assigner> ^parent-receiver <pword> ^lt <l*2>)
    (<l*2>
          ^syntactic-structure { <> nil <> reverse-merge <> conj-predicate <stype> })
    -->
    (<seg> ^not-merged-receiver <receiver> - ^not-merged-assigner <assigner> -
           ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
    (<pword> ^<stype> <receiver> +)
}

sp {apply*merge*filler-word
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
   -{ (<assigner> ^lt <l*1>)
      (<l*1> ^repeatable true)}
    (<assigner> ^lt <l*2>)
    (<l*2> ^syntactic-structure nil)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    -->
    (<seg> ^not-merged-receiver <receiver> - ^not-merged-assigner <assigner> -
           ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
}

sp {apply*merge*repeatable
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>)
    (<assigner> ^lt <lt> ^parent-receiver <pword>)
    (<lt> ^repeatable true ^syntactic-structure { <> nil <stype> })
    -->
    (<seg> ^not-merged-receiver <receiver> - ^merged-assigner <assigner> +)
    (<assigner> ^merged-receiver <receiver> +)
    (<pword> ^<stype> <receiver> +)
}

sp {apply*merge*remove-unfilled-assigner
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver>)
    (<seg> ^not-merged-receiver <receiver> ^not-merged-assigner <assigner>)
    (<assigner> ^parent-receiver <receiver>)
    -->
    (<seg> ^not-merged-assigner <assigner> -)
}

sp {apply*merge*last-merge
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<seg> ^not-merged-assigner <assigner> ^not-merged-receiver <receiver>
          ^last-merge <lm>)
    (<assigner> ^lt <l*1>)
    (<l*1> ^syntactic-structure <stype>)
    -->
    (<seg> ^last-merge <nm> + ^last-merge <lm> -)
    (<nm> ^assigner <assigner> + ^receiver <receiver> +
           ^structure-type <stype> +)
}

sp {apply*merge*copy-message-type
    (state <s> ^operator <op>)
    (<op> ^name merge ^receiver <r*1> ^assigner <a*1>)
    (<r*1> ^lt <l*1>)
    (<l*1> ^message-type <ms-type>)
    (<a*1> ^parent-receiver <pword>)
    (<pword> ^lt <l*2>)
    (<l*2> ^structure-type S)
    -->
    (<pword> ^message-type <ms-type> +)
}

sp {apply*merge*copy-first-word
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^assigner <assigner> ^receiver <receiver>)
    (<s*1> ^not-merged-assigner <assigner>)
    (<assigner> ^parent-receiver <pword>)
   -{ (<pword> ^constraint <c*2>)
      (<c*2> ^<att> <val>)}
    (<pword> ^current-word <wd>)
    (<receiver> ^current-word <c*1>)
    (<c*1> ^first-word true)
    -->
    (<pword> ^first-word true +)
    (<wd> ^first-word true +)
}

sp {apply*merge*push-constraint*receiver-assigner*RCP-D
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <a*1>)
    (<receiver> ^structure-type RCP ^constraint <con>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<a*1> ^parent-receiver <pr>)
    (<pr> -^constraint <con> ^structure-type { << CN D QUANT >> <s*2> })
   -{ (<pr> ^constraint <c*1>)
      (<con> ^handle <handle>)
      (<c*1> ^handle <handle>)}
    -->
    (<pr> ^constraint <con> +)
}

sp {apply*merge*constraint*features*name
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<receiver> ^lt-referent <id>)
    (<id> -^property <p*1> ^{ << handle name >> <a*1> } <handle>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> -^constraint <id>)
    -->
    (<pword> ^constraint <id> +)
}

sp {apply*merge*constraint*features2
    (state <s> ^operator <op> ^segment <s*1>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<s*1> ^not-merged-receiver <receiver>)
    (<receiver> ^lt-referent <id>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> -^constraint <id>)
    (<id> ^{ << handle name >> <a*1> } { <> category <value> } ^property <pf>)
    (<pf> -^value <v*1> ^{ << handle name >> <a*2> } <name>)
    -->
    (<pword> ^constraint <id> +)
}

sp {apply*merge*constraint*preposition-noun
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^lt <l*2>)
      (<l*2> ^relation-type ternary)}
   -{ (<receiver> ^lt <l*3>)
      (<l*3> ^directional true)}
    (<receiver> ^head <head> ^structure-type { << PP CONJP C-ADJ-P >> <s*3> }
          ^lt <l*4>)
    (<head> ^referent <obj>)
    (<assigner> ^parent-receiver <pword>
          ^structure-type { << PP CONJP C-ADJ-P >> <s*1> })
   -{ (<pword> ^head <h*1>)
      (<h*1> ^lt <l*1>)
      (<l*1> ^semantic-structure relation)}
    (<pword> ^structure-type { << D DP CN RC >> <s*2> })
    (<l*4> ^relation <r*1>)
    (<r*1> ^handle { <> of1 <sr> })
    -->
    (<seg> ^new-constraint <nc> +)
    (<nc> ^object <pword> + ^constraint <c> +)
    (<pword> ^constraint <c> +)
    (<c> ^relation <srx> +)
    (<srx> ^2 <obj> + ^handle <sr> +)
}

sp {apply*merge*constraint*PP*merge*of
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
   -{ (<receiver> ^head <h*4>)
      (<h*4> ^referent <r*2>)}
    (<receiver> ^structure-type PP ^head <h*2> ^lt <l*1>)
    (<h*2> ^head <h*3>)
    (<h*3> ^lt-referent <ref>)
    (<assigner> ^parent-receiver <pword>)
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref1>)
    (<l*1> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<ref1> ^relation <srx> +)
    (<srx> ^2 <ref> + ^handle of1 +)
}

sp {apply*merge*constraint*PP*merge*of*referent
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> ^structure-type PP ^head <h*4> ^lt <l*2>)
    (<h*4> ^referent <ref>)
    (<assigner> ^parent-receiver <pword>)
   -{ (<pword> ^head <h*2>)
      (<h*2> ^lt <l*1>)
      (<l*1> ^spelling { << left-noun right-noun >> <s*2> })}
   -{ (<pword> ^head <h*3>)
      (<h*3> ^lt <lt>)
      (<lt> ^structure-type N ^spelling { << right left >> <s*3> })}
    (<pword> ^head <h*1> ^structure-type { << D CN >> <s*1> })
    (<h*1> ^lt-referent <ref1>)
    (<l*2> ^relation <r*1>)
    (<r*1> ^handle of1)
    -->
    (<ref1> ^relation <srx> +)
    (<srx> ^2 <ref> + ^handle of1 +)
}

sp {apply*merge*clear-new-word
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <receiver> ^assigner <a*1>)
    (<seg> ^unknown-word <uw>)
    (<receiver> ^lt <l*1>)
    (<l*1> ^spelling <uw>)
    (<a*1> ^lt <lla>)
    (<lla> ^structure-type U)
    -->
    (<seg> ^unknown-word <uw> -)
}

sp {apply*merge*clean-up-retrieved-stack1
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <uri> ^assigner <uai>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^item <uri>)
    (<uai> ^parent-receiver <ps>)
   -{ (<rs> ^prior <p*1>)
      (<p*1> ^item <ps>)}
    -->
    (<rs> ^item <uri> - ^item <ps> +)
}

sp {apply*merge*clean-up-retrieved-stack1-2
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <uri> ^assigner <uai>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^item <uri> ^prior <prior>)
    (<uai> ^parent-receiver <ps>)
    (<prior> ^item <ps>)
    -->
    (<seg> ^retrieved-stack <rs> - ^retrieved-stack <prior> +)
    (<ps> ^merged-with true +)
}

sp {apply*merge*clean-up-retrieved-stack2
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <uri> ^assigner <uai>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^prior <p> -^item <ps>)
    (<p> ^item <uri>)
    (<uai> ^parent-receiver <ps>)
   -{ (<p> ^prior <p*1>)
      (<p*1> ^item <ps>)}
    -->
    (<p> ^item <uri> - ^item <ps> +)
}

sp {apply*merge*clean-up-retrieved-stack2-5
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <uri> ^assigner <uai>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^prior <p> -^item <ps>)
    (<p> ^item <uri> ^prior <p2>)
    (<p2> ^item <ps>)
    (<uai> ^parent-receiver <ps>)
    -->
    (<rs> ^prior <p> - ^prior <p2> +)
}

sp {apply*merge*clean-up-retrieved-stack2*duplicate
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^receiver <uri> ^assigner <uai>)
    (<seg> ^not-merged-receiver <uri> ^retrieved-stack <rs>)
    (<rs> ^prior <p> ^item <ps>)
    (<p> ^item <uri> ^prior <ppp>)
    (<uai> ^parent-receiver <ps>)
    -->
    (<rs> ^prior <p> - ^prior <ppp> +)
}

sp {apply*merge*remove-exclusive-assigner
    (state <s> ^operator <op> ^segment <seg>)
    (<op> ^name merge ^assigner <assigner>)
    (<seg> ^not-merged-assigner <uai>)
    (<uai> ^parent-receiver <pr> ^lt <x-ass>)
    (<assigner> ^parent-receiver <pr> ^lt <l*1>)
    (<l*1> ^exclusive <x-ass>)
    -->
    (<seg> ^not-merged-assigner <uai> -)
}

sp {apply*merge*monitor
    (state <s> ^operator <op>)
    (<op> ^name merge ^receiver <receiver> ^assigner <assigner>)
    (<receiver> ^lt <l*1>)
    (<assigner> ^parent-receiver <wws> ^structure-type <stype> ^lt <l*2>)
    (<wws> ^current-word <c*1>)
    (<l*2> ^syntactic-structure <ss>)
    (<l*1> ^{ << construction spelling >> <a*1> } <word2>)
    (<c*1> ^{ << construction spelling >> <a*2> } <word1>)
    -->
    
}

sp {comprehension*elaborate*possible-referent*assigner
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a*1>)
    (<a*1> ^parent-receiver <rh>)
    (<rh> ^ground-tested <g*1> ^referent <r*1>)
    -->
    (<s> ^referent-home <rh> +)
}

sp {comprehension*elaborate*possible-referent*head
    (state <s> ^name comprehension ^segment <s*1>)
    (<s*1> ^last-merge <lm>)
    (<lm> ^assigner <a*1>)
    (<a*1> ^parent-receiver <pr>)
    (<pr> ^ground-tested <g*1>
          ^{ << complement complement2 head >> <a*2> } <rh>)
    (<rh> ^referent <r*1>)
    -->
    (<s> ^referent-home <rh> +)
}

sp {comprehension*propose*dialog-object-list-update
    (state <s> ^name comprehension -^name evaluate-operator
          ^referent-home <r*1> ^top-state <t*1>)
    (<r*1> ^referent <obj>)
   -{ (<s> ^referent-home <r*2>)
      (<r*2> ^referent { <> <obj> <r*3> })}
    (<t*1> ^dialog-object-list <dol>)
    (<dol> -^referent <obj>)
    -->
    (<s> ^operator <op> + ^operator <op> >)
    (<op> ^name dialog-object-list-update + ^referent <obj> +)
}

sp {comprehension*compare*dialog-object-list-update
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name dialog-object-list-update)
    (<op2>
          ^name { << process-phrase-end process-semantics merge process-missing-assigner ground-referent ground-new-constraint clean-up-retrieved-stack >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {apply*tested-referent*add-referent-dialog-object-list
    (state <s> ^operator <op> ^top-state <ts>)
    (<op> ^name dialog-object-list-update ^referent <obj>)
    (<ts> ^dialog-object-list <dol>)
    -->
    (<ts> ^dialog-object-list <dol> - ^dialog-object-list <ndol> +)
    (<ndol> ^referent <obj> + ^next <dol> +)
}

sp {process-multiple-groundings*elaborate-state*substate
    (state <s> ^name process-multiple-groundings ^superstate <s*1>)
    (<s*1> ^referent-home <r*1>)
    (<r*1> ^referent <obj>)
    -->
    (<s> ^object <obj> +)
}

sp {process-multiple-groundings*elaborate-state*substate2
    (state <s> ^name process-multiple-groundings ^segment <s*1>)
    (<s*1> ^dialog-object-list-access <dola>)
    -->
    (<s> ^dialog-object-list <dola> +)
}

sp {process-multiple-groundings*propose*detect-match
    (state <s> ^name process-multiple-groundings ^dialog-object-list <d*1>
          ^object <obj>)
   -{ (<s> ^segment <s*1>)
      (<s*1> ^last-merge <l*1>)
      (<l*1> ^assigner <a*1>)
      (<a*1> ^parent-receiver <p*1>)
      (<p*1> ^constraint <c*1>)
      (<c*1> ^handle { << original former >> <h*1> })}
    (<d*1> ^referent <obj>)
    (<obj> -^specifier distinct)
    -->
    (<s> ^operator <op> + ^operator <op> =)
    (<op> ^name detect-match + ^object <obj> +)
}

sp {process-multiple-groundings*apply*detect-match
    (state <s> ^operator <op> ^superstate <ss>)
    (<op> ^name detect-match ^object { <> <obj> <o*1> })
    (<ss> ^referent-home <pr> ^operator <o>)
    (<pr> ^referent <obj>)
    -->
    (<pr> ^referent <obj> -)
}

sp {process-multiple-groundings*propose*next-list-item
    (state <s> ^name process-multiple-groundings
          ^dialog-object-list { <> nil <dol> })
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> <)
    (<op> ^name next-list-item + ^item <dol> +)
}

sp {comprehension*elaborate-operator*process-multiple-groundings
    (state <s> ^name comprehension ^referent-home <r*1>)
   -{ (<s> ^referent-home <r*3>)
      (<r*3> ^constraint <c*1>)
      (<c*1> ^multiple true)}
    (<r*1> ^referent <obj> ^referent { <> <obj> <r*2> })
    -->
    (<s> ^multiple-referents true +)
}

sp {comprehend*propose*process-multiple-groundings
    (state <s> ^multiple-referents true -^processed-multiple true
          ^name comprehension)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> >)
    (<op> ^name process-multiple-groundings +)
}

sp {comprehension*compare*process-multiple-groundings
    (state <s> ^name comprehension ^operator <op1> + ^operator <op2> +)
    (<op1> ^name process-multiple-groundings)
    (<op2>
          ^name { << process-phrase-end process-semantics merge process-missing-assigner clean-up-retrieved-stack comprehend-construction comprehend-word >> <n*1> })
    -->
    (<s> ^operator <op1> > <op2>)
}

sp {comprehend*apply*process-multiple-groundings*not
    (state <s> ^referent-home <pr> ^operator <op>)
   -{ (<pr> ^referent <pr-g> ^referent { <> <pr-g> <pr-d> })
      (<pr-g> ^predicates <p*1>)
      (<p*1> ^status live)
      (<pr-d> ^predicates <p*2>)
      (<p*2> ^visible { << false unknown >> <v*1> })}
    (<op> ^name process-multiple-groundings)
    -->
    (<op> ^not-live-available-with-not-visible true +)
}

sp {comprehend*apply*non-process-multiple*remove-referent-home
    (state <s> ^operator <op> ^referent-home <pr>)
    (<op>
          -^name { << process-multiple-groundings dialog-object-list-update >> <n*1> })
    -->
    (<s> ^referent-home <pr> -)
}

sp {language-comprehension*propose*initialize-rosie
    (state <s> ^name rosie -^world <w*1> ^top-state <t*1>)
    (<t*1> ^world-usage internal)
    -->
    (<s> ^operator <op> + ^operator <op> = ^operator <op> !)
    (<op> ^name initialize-rosie +)
}

sp {apply*interpet-message*remove*current-sentence-number
    (state <s> ^top-state <ts> ^operator <o*1>)
    (<ts> ^game-scripting true ^current-sentence-number <csn>)
    (<o*1> ^name interpret-message)
    -->
    (<ts> ^n-sentence-number (+ <csn> 1) + ^current-sentence-number <csn> -)
}

sp {apply*wait-for-response*add*next-sentence-number
    (state <s> ^top-state <ts> ^operator <o*1>)
    (<ts> ^game-scripting true ^n-sentence-number <csn>)
    (<o*1> ^name wait-for-response)
    -->
    (<ts> ^n-sentence-number <csn> - ^current-sentence-number <csn> +)
}

sp {apply*initialize-rosie*initialize-world*othello
    (state <s> ^top-state <t*1> ^operator <o*1>)
    (<t*1> ^world-usage internal)
    (<o*1> ^name initialize-rosie)
    -->
    (<s> ^world <world> +)
    (<world> ^objects <objects> + ^predicates <predicates> + ^robot <robot> +)
    (<robot> ^handle rosie + ^current-location <loc> + ^item-type object +
           ^arm <a*1> + ^predicates <p*1> +)
    (<a*1> ^action wait +)
    (<p*1> ^handle rosie +)
    (<objects> ^object <obj0> + ^object <obj1> + ^object <obj2> +
           ^object <obj3> + ^object <obj4> + ^object <obj5> + ^object <obj6> +
           ^object <obj7> + ^object <loc> + ^object <loc1> + ^object <loc2> +
           ^object <loc3> + ^object <loc4> + ^object <loc5> + ^object <loc6> +
           ^object <loc7> + ^object <loc8> + ^object <loc9> +
           ^object <loc10> + ^object <loc11> + ^object <loc12> +
           ^object <loc13> + ^object <loc14> + ^object <loc15> +)
    (<loc> ^handle |\|B0\|| + ^item-type object + ^predicates <ploc> +)
    (<ploc> ^x 1 + ^y 1 + ^category location + ^visible true +)
    (<loc1> ^handle |\|B1\|| + ^item-type object + ^predicates <ploc1> +)
    (<ploc1> ^x 2 + ^y 1 + ^category location + ^visible true +)
    (<loc2> ^handle |\|B2\|| + ^item-type object + ^predicates <ploc2> +)
    (<ploc2> ^x 3 + ^y 1 + ^category location + ^visible true +)
    (<loc3> ^handle |\|B3\|| + ^item-type object + ^predicates <ploc3> +)
    (<ploc3> ^x 4 + ^y 1 + ^category location + ^visible true +)
    (<loc4> ^handle |\|B4\|| + ^item-type object + ^predicates <ploc4> +)
    (<ploc4> ^x 1 + ^y 2 + ^category location + ^visible true +)
    (<loc5> ^handle |\|B5\|| + ^item-type object + ^predicates <ploc5> +)
    (<ploc5> ^x 2 + ^y 2 + ^category location + ^visible true +)
    (<loc6> ^handle |\|B6\|| + ^item-type object + ^predicates <ploc6> +)
    (<ploc6> ^x 3 + ^y 2 + ^category location + ^visible true +)
    (<loc7> ^handle |\|B7\|| + ^item-type object + ^predicates <ploc7> +)
    (<ploc7> ^x 4 + ^y 2 + ^category location + ^visible true +)
    (<loc8> ^handle |\|B8\|| + ^item-type object + ^predicates <ploc8> +)
    (<ploc8> ^x 1 + ^y 3 + ^category location + ^visible true +)
    (<loc9> ^handle |\|B9\|| + ^item-type object + ^predicates <ploc9> +)
    (<ploc9> ^x 2 + ^y 3 + ^category location + ^visible true +)
    (<loc10> ^handle |\|B10\|| + ^item-type object + ^predicates <ploc10> +)
    (<ploc10> ^x 3 + ^y 3 + ^category location + ^visible true +)
    (<loc11> ^handle |\|B11\|| + ^item-type object + ^predicates <ploc11> +)
    (<ploc11> ^x 4 + ^y 3 + ^category location + ^visible true +)
    (<loc12> ^handle |\|B12\|| + ^item-type object + ^predicates <ploc12> +)
    (<ploc12> ^x 1 + ^y 4 + ^category location + ^visible true +)
    (<loc13> ^handle |\|B13\|| + ^item-type object + ^predicates <ploc13> +)
    (<ploc13> ^x 2 + ^y 4 + ^category location + ^visible true +)
    (<loc14> ^handle |\|B14\|| + ^item-type object + ^predicates <ploc14> +)
    (<ploc14> ^x 3 + ^y 4 + ^category location + ^visible true +)
    (<loc15> ^handle |\|B15\|| + ^item-type object + ^predicates <ploc15> +)
    (<ploc15> ^x 4 + ^y 4 + ^category location + ^visible true +)
    (<obj0> ^type object + ^handle self + ^predicates <plot0> +)
    (<plot0> ^type object +)
    (<obj1> ^handle |\|L1\|| + ^predicates <plot1> + ^item-type object +)
    (<plot1> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj2> ^handle |\|L2\|| + ^item-type object + ^predicates <plot2> +)
    (<plot2> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj3> ^handle |\|L3\|| + ^item-type object + ^predicates <plot3> +)
    (<plot3> ^category block + ^color red1 + ^visible true + ^movable true +)
    (<obj4> ^handle |\|L4\|| + ^predicates <plot4> + ^item-type object +)
    (<plot4> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj5> ^handle |\|L5\|| + ^item-type object + ^predicates <plot5> +)
    (<plot5> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj6> ^handle |\|L6\|| + ^item-type object + ^predicates <plot6> +)
    (<plot6> ^category block + ^color blue1 + ^visible true + ^movable true +)
    (<obj7> ^handle |\|L7\|| + ^predicates <plot7> + ^item-type object +)
    (<plot7> ^category block + ^color red1 + ^visible true + ^movable true +
           ^indicated pointed +)
    (<predicates> ^predicate <on1> + ^predicate <below1> +)
    (<on1> ^handle on1 + ^item-type predicate + ^instance <on-1> +
           ^instance <on-2> + ^instance <on-3> + ^instance <on-4> +
           ^instance <on-5> + ^instance <on-6> +)
    (<on-1> ^1 <obj1> + ^2 <loc9> +)
    (<on-2> ^1 <obj2> + ^2 <loc7> +)
    (<on-3> ^1 <obj4> + ^2 <loc5> +)
    (<on-4> ^1 <obj5> + ^2 <loc6> +)
    (<on-5> ^1 <obj6> + ^2 <loc10> +)
    (<on-6> ^1 <obj3> + ^2 <loc2> +)
    (<below1> ^handle below1 + ^item-type predicate + ^instance <b-1> +
           ^instance <b-2> + ^instance <b-3> + ^instance <b-4> +
           ^instance <b-5> + ^instance <b-6> + ^instance <b-7> +
           ^instance <b-8> + ^instance <b-21> + ^instance <b-22> +
           ^instance <b-23> + ^instance <b-24> + ^instance <b-25> +
           ^instance <b-26> + ^instance <b-27> + ^instance <b-28> +)
    (<b-1> ^2 <obj1> + ^1 <loc1> +)
    (<b-2> ^2 <obj2> + ^1 <loc2> +)
    (<b-3> ^2 <obj4> + ^1 <loc3> +)
    (<b-4> ^2 <obj3> + ^1 <loc4> +)
    (<b-5> ^2 <obj5> + ^1 <loc5> +)
    (<b-6> ^2 <obj1> + ^1 <loc6> +)
    (<b-7> ^2 <obj2> + ^1 <loc7> +)
    (<b-8> ^2 <obj3> + ^1 <loc8> +)
    (<b-21> ^2 <obj1> + ^1 <loc11> +)
    (<b-22> ^2 <obj2> + ^1 <loc12> +)
    (<b-23> ^2 <obj4> + ^1 <loc13> +)
    (<b-24> ^2 <obj3> + ^1 <loc14> +)
    (<b-25> ^2 <obj5> + ^1 <loc15> +)
    (<b-26> ^2 <obj6> + ^1 <loc> +)
    (<b-27> ^2 <obj1> + ^1 <loc10> +)
    (<b-28> ^2 <obj2> + ^1 <loc9> +)
}

sp {top-state*apply*init-agent*create*perception-monitor*internal
    (state <s> ^world-usage internal ^top-state <s> ^operator <o*1>)
    (<o*1> ^name init-agent)
    -->
    (<s> ^perception-monitor <mon> +)
    (<mon> ^object-monitor <obj-mon> + ^predicate-monitor <pred-mon> +)
}

sp {top-state*world*object*predicates*elaborate*property*current
    (state <s> ^top-state <s> ^world <w*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^current-location <loc>)
    (<loc> ^predicates <preds>)
    -->
    (<preds> ^property current +)
}

sp {top-state*world*object*predicates*elaborate*arm-status*default*not-grabbed
    (state <s> ^superstate nil ^world <w*1>)
    (<w*1> ^objects <o*1>)
    (<o*1> ^object <o*2>)
    (<o*2> ^predicates <preds>)
    (<preds> -^arm-status { << moving grabbed >> <a*1> })
    -->
    (<preds> ^arm-status not-grabbed +)
}

sp {top-statel*elaborate*lti-store
    (state <s> ^superstate nil)
    -->
    (<s> ^lti-store <store> +)
    (<store> ^to-get <get> +)
}

sp {problem-space*world*copy-type*shallow*elaborate*world
    (state <s> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> -^copy-type deep ^copy-type shallow ^source <world>)
    -->
    (<s> ^world <world> +)
}

sp {problem-space*world*copy-type*deep*elaborate*world
    (state <s> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <world>)
    -->
    (<s> ^world <new-world> + ^copy-objects-map <objs-map> +
           ^copy-predicates-map <preds-map> +)
    (<new-world> ^objects <objs> + ^predicates <preds> + ^robot <robot> +)
    (<robot> ^arm <arm> +)
}

sp {problem-space*world*copy-type*deep*copy*robot*arm
    (state <s> ^world <w*1> ^problem-space <p*1>)
    (<w*1> ^robot <r*1>)
    (<r*1> ^arm <arm>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^robot <r*2>)
    (<r*2> ^arm <src-arm>)
    (<src-arm> ^<att-name> <att-val>)
    -->
    (<arm> ^<att-name> <att-val> +)
}

sp {problem-space*world*copy-type*deep*copy*object
    (state <s> ^copy-objects-map <map> ^world <w*1> ^problem-space <p*1>)
    (<w*1> ^objects <objs>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^objects <o*1>)
    (<o*1> ^object <src-obj>)
    (<src-obj> ^item-type <type>)
    -->
    (<objs> ^object <new-obj> +)
    (<new-obj> ^item-type <type> + ^predicates <preds> +)
    (<map> ^<src-obj> <new-obj> +)
}

sp {problem-space*world*copy-type*deep*copy*object*handle
    (state <s> ^copy-objects-map <c*1> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^objects <o*1>)
    (<c*1> ^<src-obj> <obj>)
    (<src-obj> ^handle <handle>)
    (<o*1> ^object <src-obj>)
    -->
    (<obj> ^handle <handle> +)
}

sp {problem-space*world*copy-type*deep*copy*object*predicates
    (state <s> ^copy-objects-map <c*1> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^objects <o*1>)
    (<c*1> ^<src-obj> <obj>)
    (<src-obj> ^predicates <src-preds>)
    (<obj> ^predicates <preds>)
    (<o*1> ^object <src-obj>)
    (<src-preds> ^<pred-name> <pred-val>)
    -->
    (<preds> ^<pred-name> <pred-val> +)
}

sp {problem-space*world*copy-type*deep*copy*predicate
    (state <s> ^copy-predicates-map <map> ^world <w*1> ^problem-space <p*1>)
    (<w*1> ^predicates <preds>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^predicates <p*2>)
    (<p*2> ^predicate <src-pred>)
    -->
    (<preds> ^predicate <new-pred> +)
    (<map> ^<src-pred> <new-pred> +)
}

sp {problem-space*world*copy-type*deep*copy*predicate*info
    (state <s> ^copy-predicates-map <c*1> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^predicates <p*2>)
    (<p*2> ^predicate <src-pred>)
    (<src-pred> ^handle <pred-handle>)
    (<c*1> ^<src-pred> <pred>)
    -->
    (<pred> ^handle <pred-handle> +)
}

sp {problem-space*world*elaborate*copy-set-map
    (state <s> ^problem-space <p*1>)
    (<p*1> ^world <w*1>)
    (<w*1> ^copy-type deep)
    -->
    (<s> ^copy-set-map <csm> +)
}

sp {problem-space*world*copy-type*deep*copy*predicate*instance*size*2
    (state <s> ^copy-predicates-map <c*1> ^copy-objects-map <c*2>
          ^copy-objects-map <c*3> ^problem-space <p*1>)
    (<p*1> ^world <w>)
    (<w> ^copy-type deep ^source <s*1>)
    (<s*1> ^predicates <p*2>)
    (<p*2> ^predicate <src-pred>)
    (<src-pred> ^instance <src-instance>)
    (<src-instance> -^3 <v*1> ^2 <src-obj2> ^1 <src-obj1>)
    (<c*1> ^<src-pred> <pred>)
    (<c*2> ^<src-obj1> <obj1>)
    (<c*3> ^<src-obj2> <obj2>)
    -->
    (<pred> ^instance <new-instance> +)
    (<new-instance> ^1 <obj1> + ^2 <obj2> +)
}

sp {games*selection*elaborate*evaluate-operator*default-desired-copy
    (state <s> ^problemspace games ^operator <o> +)
    (<o> ^name evaluate-operator)
    -->
    (<o> ^default-desired-copy yes + ^default-operator-copy yes +)
}

sp {action*state*no-change*propose*no-proposed-action
    (state <s> ^impasse no-change ^attribute state ^superstate <s*1>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    -->
    (<s> ^operator <o> + ^operator <o> <)
    (<o> ^name no-proposed-action +)
}

sp {action*state*no-change*elaborate*world
    (state <s> ^impasse no-change ^attribute state ^superstate <s*1>
          ^superstate <s*2>)
    (<s*1> ^problem-space <p*1>)
    (<p*1> ^name action)
    (<s*2> ^world <w>)
    -->
    (<s> ^world <w> +)
}

# Semantic Memory

smem --add {
(@1 ^arg1 @2 ^op_name initiate-put-down1)
(@4 ^arg1 @5 ^op_name initiate-pick-up1)
(@5 ^id @6 ^arg-type object ^arg-status real)
(@7 ^arg1 @8 ^op_name initiate-open1)
(@8 ^id @9 ^arg-type object ^arg-status real)
(@2 ^id @3 ^arg-type object ^arg-status real)
(@10 ^arg1 @11 ^op_name initiate-close1)
(@11 ^id @12 ^arg-type object ^arg-status real)
(@13 ^op_name initiate-wait1)
(@15 ^arg1 @16 ^arg2 @17 ^op_name op_move1)
(@28 ^arg1 @29 ^arg2 @30 ^op_name initiate-fetch1)
(@14 ^predicate @21)
(@21 ^type relation ^id @20 ^1 @18 ^2 @19)
(@22 ^arg1 @23 ^op_name initiate-turn-on1)
(@16 ^id @18 ^arg-type object)
(@17 ^id @20 ^2 @19 ^arg-type predicate)
(@26 ^id @27 ^arg-type object ^arg-status real)
(@25 ^arg1 @26 ^op_name initiate-turn-off1)
(@23 ^id @24 ^arg-type object ^arg-status real)
(@38 ^id @39 ^arg-type object)
(@40 ^arg1 @41 ^op_name initiate-throw1)
(@41 ^id @42 ^arg-type object)
(@29 ^id @31 ^arg-type object ^arg-status real)
(@34 ^arg1 @35 ^op_name initiate-ask1)
(@30 ^id @33 ^2 @32 ^arg-type predicate ^arg-status real)
(@35 ^id @36 ^arg-type object)
(@37 ^arg1 @38 ^op_name initiate-tell1)
(@43 ^arg1 @44 ^op_name initiate-turn1)
(@44 ^id @45 ^arg-type concept)
(@46 ^arg2 @47 ^op_name initiate-go-to-location1)
(@47 ^id @48 ^2 @49 ^arg-type predicate ^arg-status imagined)
(@50 ^arg1 @51 ^op_name initiate-follow-wall1)
(@66 ^id @68 ^arg-type object ^arg-status real)
(@65 ^arg1 @66 ^arg2 @67 ^op_name initiate-remember1)
(@53 ^op_name initiate-stop1)
(@54 ^arg1 @55 ^op_name initiate-orient1)
(@51 ^id @52 ^arg-type concept)
(@57 ^arg2 @58 ^op_name go-to-waypoint)
(@55 ^id @56 ^arg-type concept)
(@58 ^id @59 ^arg-type concept)
(@60 ^arg2 @61 ^op_name go-to-next-waypoint)
(@61 ^id @62 ^arg-type concept)
(@64 ^op_name initiate-sense1)
(@63 ^op_name initiate-explore1)
(@70 ^op_name initiate-check1)
(@72 ^op_name initiate-heard1)
(@73 ^op_name initiate-say1)
(@71 ^op_name initiate-recall1)
(@67 ^id @69 ^arg-type object ^arg-status imagined)
(@74 ^op_name initiate-attend1)
(@76 ^op_name initiate-has1)
(@77 ^op_name initiate-play1)
(@78 ^op_name initiate-win1)
(@79 ^op_name initiate-lose1)
(@80 ^op_name initiate-prefer1)
(@75 ^op_name initiate-ignore1)
(@81 ^op_name initiate-avoid1)
(@82 ^op_name op_scan1)
(@83 ^arg1 @84 ^arg2 @85 ^op_name op_give1)
(@89 ^op_name initiate-attack)
(@90 ^op_name initiate-load)
(@91 ^op_name initiate-consider1)
(@84 ^id @86 ^arg-type object ^arg-status visible)
(@88 ^op_name initiate-think1)
(@85 ^id @87 ^arg-type object ^arg-status visible)
(@92 ^type aligned ^count 0 ^sum 0.000000 ^axis x ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@93 ^type aligned ^count 0 ^sum 0.000000 ^axis y ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@101014 ^handle clean)
(@101015 ^handle turn-on1 ^item-type action ^procedural @22 ^action-type primitive)
(@101016 ^handle turn-off1 ^item-type action ^procedural @25 ^action-type primitive)
(@94 ^type greater ^count 3 ^sum 0.000000 ^axis z ^bottom 0.000001 ^top 0.040000 ^avg 0.005000 ^squaredsum 0.000000)
(@95 ^type aligned ^count 0 ^sum 0.000000 ^axis y ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@96 ^type aligned ^count 0 ^sum 0.000000 ^axis z ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@97 ^type aligned ^count 0 ^sum 0.000000 ^axis x ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@98 ^type aligned ^count 0 ^sum 0.000000 ^axis y ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@99 ^type greater ^count 1 ^sum 0.000000 ^axis x ^bottom 0.090000 ^top 0.170000 ^avg 0.100000 ^squaredsum 0.000000)
(@100 ^type aligned ^count 0 ^sum 0.000000 ^axis z ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@101 ^type aligned ^count 0 ^sum 0.000000 ^axis y ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@102 ^type less ^count 1 ^sum 0.000000 ^axis x ^bottom 0.090000 ^top 0.170000 ^avg 0.100000 ^squaredsum 0.000000)
(@103 ^type aligned ^count 0 ^sum 0.000000 ^axis z ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@104 ^type aligned ^count 0 ^sum 0.000000 ^axis y ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@105 ^type aligned ^count 0 ^sum 0.000000 ^axis x ^bottom 0.000000 ^top 0.000000 ^avg 0.000000 ^squaredsum 0.000000)
(@106 ^type less ^count 3 ^sum 0.000000 ^axis z ^bottom 0.000001 ^top 0.040000 ^avg 0.005000 ^squaredsum 0.000000)
(@107 ^type aligned greater less ^count 1 ^sum 0.000000 ^axis y ^bottom 0.000100 ^top 0.100000 ^avg 0.100000 ^squaredsum 0.000000)
(@108 ^type aligned greater less ^count 1 ^sum 0.000000 ^axis x ^bottom 0.000100 ^top 0.100000 ^avg 0.100000 ^squaredsum 0.000000)
(@109 ^type aligned ^count 1 ^sum 0.000000 ^axis z ^bottom 0.000100 ^top 0.000000 ^avg 0.100000 ^squaredsum 0.000000)
(@110 ^type greater less ^count 1 ^sum 0.000000 ^axis y ^bottom 0.000100 ^top 0.100000 ^avg 0.100000 ^squaredsum 0.000000)
(@111 ^type aligned ^count 1 ^sum 0.000000 ^axis z ^bottom 0.000100 ^top 0.000000 ^avg 0.100000 ^squaredsum 0.000000)
(@112 ^type greater less ^count 1 ^sum 0.000000 ^axis x ^bottom 0.000100 ^top 0.100000 ^avg 0.100000 ^squaredsum 0.000000)
(@113 ^name kitchen1 ^handle loc-kitchen1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@114 ^name soar1 ^handle loc-soar1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@115 ^name april1 ^handle loc-april1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@116 ^name main1 ^handle loc-main1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@117 ^name copy1 ^handle loc-copy1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@118 ^name copy1 ^handle loc-copy1 ^item-type location ^spatial-shape room1 ^object-instance true)
(@119 ^handle loc-alice-office1 ^item-type location ^spatial-shape room1 ^possessive alices1 ^object-instance true ^owner person-alice1)
(@120 ^handle loc-bob-office1 ^item-type location ^spatial-shape room1 ^possessive bobs1 ^object-instance true ^owner person-bob1)
(@121 ^handle loc-charlie-office1 ^item-type location ^spatial-shape room1 ^possessive charlies1 ^object-instance true ^owner person-charlie1)
(@122 ^handle obj-box1 ^item-type object ^color red1 ^shape box1 ^object-instance true)
(@123 ^handle obj-box2 ^item-type object ^color blue1 ^shape box1 ^object-instance true)
(@124 ^handle obj-book1 ^item-type object ^color black1 ^shape book1 ^object-instance true)
(@125 ^handle obj-stapler1 ^item-type object ^color white1 ^shape stapler1 ^object-instance true)
(@126 ^handle obj-soda1 ^item-type object ^color blue1 ^shape soda1 ^object-instance true)
(@127 ^name alice1 ^handle person-alice1 ^item-type person ^object-instance true)
(@128 ^name bob1 ^handle person-bob1 ^item-type person ^object-instance true)
(@129 ^name charlie1 ^handle person-charlie1 ^item-type person ^object-instance true)
(@901 ^spelling turn ^referent @101015 ^number singular ^structure-type V ^converts-to VP ^assigners @999587 @999588 @999589 ^semantic-structure action ^tense present)
(@903 ^relation @501031 ^spelling to ^super-type @609000 ^directional maybe)
(@902 ^spelling the ^number singular ^specifier definite ^super-type @991001)
(@905 ^relation @501000 ^spelling on ^structure-type P ^converts-to PP ^assigners @999419 ^relation-type binary)
(@9010 ^spelling is ^number singular ^structure-type IS-V ^tense present)
(@20999 ^number singular ^structure-type G ^converts-to GP ^assigners @1000130 @1000131 @1000132 ^semantic-structure action ^tense present)
(@60985 ^number singular ^structure-type V ^converts-to VP ^assigners @999668 @999669 @999670 @999671 @999672 @999673 @999674 ^semantic-structure action ^tense present)
(@60995 ^number singular ^structure-type V ^converts-to VP ^assigners @999618 @999619 @999620 @999621 @999622 @999623 ^semantic-structure action ^tense present)
(@60986 ^number singular ^structure-type V ^converts-to VP ^assigners @999664 @999665 @999666 @999667 ^semantic-structure action ^tense present)
(@60987 ^number singular ^structure-type V ^converts-to VP ^assigners @999656 @999657 @999658 @999659 @999660 @999661 @999662 @999663 ^semantic-structure action ^tense present)
(@60988 ^number singular ^structure-type V ^converts-to VP ^assigners @999651 @999652 @999653 @999654 @999655 ^semantic-structure action ^tense present)
(@60989 ^number singular ^structure-type V ^converts-to VP ^assigners @999646 @999647 @999648 @999649 @999650 ^semantic-structure action ^tense present)
(@60990 ^number singular ^structure-type V ^converts-to VP ^assigners @999643 @999644 @999645 ^semantic-structure action ^tense present)
(@60991 ^number singular ^structure-type V ^converts-to VP ^assigners @999639 @999640 @999641 @999642 ^semantic-structure action ^tense present)
(@60992 ^number singular ^structure-type V ^converts-to VP ^assigners @999633 @999634 @999635 @999636 @999637 ^semantic-structure action ^tense present)
(@60993 ^number singular ^structure-type V ^converts-to VP ^assigners @999627 @999628 @999629 @999630 @999631 @999632 ^semantic-structure action ^tense present)
(@60994 ^number singular ^structure-type V ^converts-to VP ^assigners @999624 @999625 @999626 ^semantic-structure action ^tense present)
(@60997 ^number singular ^structure-type V ^converts-to VP ^assigners @999605 @999606 @999607 @999608 @999609 @999610 @999611 ^semantic-structure action ^tense present)
(@60996 ^number singular ^structure-type V ^converts-to VP ^assigners @999612 @999613 @999614 @999615 @999616 @999617 ^semantic-structure action ^tense present)
(@101000 ^handle put-down1 ^item-type action ^procedural @1 ^action-type primitive)
(@60998 ^number singular ^structure-type V ^converts-to VP ^assigners @999600 @999601 @999602 @999603 @999604 ^semantic-structure action ^tense present)
(@60999 ^number singular ^structure-type V ^converts-to VP ^assigners @999592 @999593 @999594 @999595 @999596 @999597 @999598 @999599 ^semantic-structure action ^tense present)
(@101001 ^handle pick-up1 ^item-type action ^procedural @4 ^action-type primitive)
(@101002 ^handle point1)
(@101003 ^handle open1 ^item-type action ^procedural @7 ^action-type primitive)
(@101004 ^handle close1 ^item-type action ^procedural @10 ^action-type primitive)
(@101011 ^handle stack)
(@101007 ^handle wait1 ^item-type action ^procedural @13 ^action-type primitive)
(@101008 ^goal @14 ^handle move1 ^item-type action ^procedural @15 ^action-type composite)
(@101009 ^handle store1)
(@101010 ^handle discard)
(@101012 ^handle cook1)
(@101013 ^handle set1)
(@101019 ^handle fetch1 ^item-type action ^procedural @28 ^action-type composite)
(@101131 ^handle perform1)
(@101143 ^type action ^handle think ^procedural @88)
(@101130 ^handle bring1)
(@101018 ^handle deliver1)
(@101020 ^handle find1)
(@101030 ^handle ask1 ^item-type action ^procedural @34 ^action-type composite)
(@101031 ^handle tell1 ^item-type action ^procedural @37 ^action-type composite)
(@101129 ^handle serve1)
(@101032 ^handle throw1 ^item-type action ^procedural @40 ^action-type composite)
(@101100 ^handle turn1 ^item-type action ^procedural @43 ^action-type primitive)
(@101103 ^handle go-to-location1 ^item-type action ^procedural @46 ^action-type primitive)
(@101104 ^handle follow-wall1 ^item-type action ^procedural @50 ^action-type primitive)
(@101106 ^handle stop1 ^item-type action ^procedural @53 ^action-type primitive)
(@101107 ^handle orient1 ^item-type action ^procedural @54 ^action-type primitive)
(@101108 ^handle go-to-waypoint1 ^item-type action ^procedural @57 ^action-type composite)
(@101109 ^handle go-to-next-waypoint1 ^item-type action ^procedural @60 ^action-type composite)
(@101110 ^handle explore1 ^item-type action ^procedural @63)
(@101111 ^handle sense1 ^item-type action ^procedural @64)
(@101112 ^handle remember1 ^item-type action ^procedural @65 ^action-type primitive)
(@101113 ^handle check ^item-type action ^procedural @70)
(@101114 ^handle recall ^item-type action ^procedural @71)
(@101115 ^type action ^handle heard ^procedural @72)
(@101116 ^type action ^handle say ^procedural @73)
(@101117 ^type action ^handle attend ^procedural @74)
(@101118 ^type action ^handle ignore ^procedural @75)
(@101119 ^type action ^handle has ^procedural @76)
(@101120 ^type action ^handle play ^procedural @77)
(@101121 ^type action ^handle win ^procedural @78)
(@101122 ^type action ^handle lose ^procedural @79)
(@101123 ^type action ^handle prefer ^procedural @80)
(@101124 ^type action ^handle avoid ^procedural @81)
(@101125 ^type action ^handle scan1 ^procedural @82 ^action-type primitive)
(@101126 ^handle give1 ^item-type action ^procedural @83 ^action-type primitive)
(@101127 ^handle take1)
(@101128 ^handle guide1)
(@101145 ^type action ^handle load ^procedural @90)
(@101144 ^type action ^handle attack ^procedural @89)
(@101148 ^handle is1)
(@108009 ^handle organize)
(@202000 ^type visual ^handle property1 ^item-type property)
(@101149 ^handle covers1 ^tense past)
(@101146 ^type action ^handle consider ^procedural @91)
(@101147 ^handle matches1)
(@407005 ^multiple true ^property @407000 ^handle location)
(@501011 ^type relation ^relation @107 @108 @109 ^handle near1)
(@501012 ^type relation ^relation @110 @111 @112 ^handle diagonal-with1)
(@501017 ^handle holding1)
(@401000 ^type visual ^handle color ^item-type property)
(@401001 ^property @401000 ^handle red1 ^item-type predicate)
(@401002 ^property @401000 ^handle orange1 ^item-type predicate)
(@401003 ^property @401000 ^handle yellow1 ^item-type predicate)
(@401004 ^property @401000 ^handle green1 ^item-type predicate)
(@401005 ^property @401000 ^handle blue1 ^item-type predicate)
(@401006 ^property @401000 ^handle purple1 ^item-type predicate)
(@401007 ^property @401000 ^handle white1 ^item-type predicate)
(@401008 ^property @401000 ^handle black1 ^item-type predicate)
(@401009 ^property @401000 ^handle brown1 ^item-type predicate)
(@401010 ^property @401000 ^handle gray1 ^item-type predicate)
(@402000 ^type visual ^handle shape ^item-type property)
(@402001 ^property @402000 ^handle triangle1 ^item-type predicate)
(@402002 ^property @402000 ^handle arch1 ^item-type predicate)
(@402003 ^property @402000 ^handle square1 ^item-type predicate)
(@402004 ^property @402000 ^handle l-block1 ^item-type predicate)
(@402005 ^property @402000 ^handle t-block1 ^item-type predicate)
(@402006 ^property @402000 ^handle sphere1 ^item-type predicate)
(@402007 ^property @402000 ^handle chicken1 ^item-type predicate)
(@402008 ^property @402000 ^handle rectangle1 ^item-type predicate)
(@402010 ^property @402000 ^handle soda1 ^item-type predicate)
(@402011 ^property @402000 ^handle box1 ^item-type predicate)
(@402012 ^property @402000 ^handle steak1 ^item-type predicate)
(@402013 ^property @402000 ^handle lights1 ^item-type predicate)
(@402014 ^property @402000 ^handle package1 ^item-type predicate)
(@402015 ^property @402000 ^handle papers1 ^item-type predicate)
(@402016 ^property @402000 ^handle kinect1 ^item-type predicate)
(@402017 ^property @404000 ^handle trash1 ^item-type predicate)
(@402018 ^property @402000 ^handle line1 ^item-type predicate)
(@402019 ^multiple true ^property @402000 ^handle triangle1 ^item-type predicate)
(@402020 ^property @402000 ^handle stapler1 ^item-type predicate)
(@402021 ^property @402000 ^handle book1 ^item-type predicate)
(@403000 ^type visual ^handle size ^item-type property)
(@403001 ^property @403000 ^handle small1 ^item-type predicate)
(@403002 ^property @403000 ^handle medium1 ^item-type predicate)
(@403003 ^property @403000 ^handle large1 ^item-type predicate)
(@403004 ^property @403000 ^handle tiny1 ^item-type predicate)
(@403005 ^property @403000 ^handle giant1 ^item-type predicate)
(@404000 ^type visual ^handle name ^item-type property)
(@404001 ^property @404000 ^handle pantry ^item-type predicate)
(@404002 ^property @404000 ^handle garbage ^item-type predicate)
(@404003 ^property @404000 ^handle table ^item-type predicate)
(@404005 ^property @404000 ^handle dishwasher ^item-type predicate)
(@404006 ^property @404000 ^handle scale ^item-type predicate)
(@404007 ^property @404000 ^handle thermometer ^item-type predicate)
(@404008 ^property @404000 ^handle grid-red)
(@404009 ^property @404000 ^handle grid-orange)
(@404010 ^property @404000 ^handle grid-yellow)
(@404011 ^property @404000 ^handle grid-green)
(@404012 ^property @404000 ^handle grid-blue)
(@404013 ^property @404000 ^handle goal ^item-type predicate)
(@404014 ^property @404000 ^handle home ^item-type predicate)
(@404015 ^property @404000 ^handle bin-1)
(@404016 ^property @404000 ^handle bin-2)
(@404017 ^property @404000 ^handle bin-3)
(@404018 ^property @404000 ^handle bin-4)
(@404019 ^property @404000 ^handle bin-5)
(@404020 ^property @404000 ^handle bin-6)
(@404023 ^property @404000 ^handle stove)
(@404024 ^property @404000 ^handle answer ^item-type predicate)
(@404040 ^property @404000 ^handle alice1 ^item-type predicate)
(@404041 ^property @404000 ^handle bob1 ^item-type predicate)
(@404042 ^property @404000 ^handle charlie1 ^item-type predicate)
(@404043 ^property @404000 ^handle fridge1 ^item-type predicate)
(@404044 ^property @404000 ^handle faucet1 ^item-type predicate)
(@404045 ^property @404000 ^handle water1 ^item-type predicate)
(@404046 ^property @404000 ^handle cup1 ^item-type predicate)
(@405000 ^type measurable ^handle weight ^item-type property)
(@405001 ^property @405000 ^handle heavy1 ^item-type predicate)
(@405002 ^property @405000 ^handle light1 ^item-type predicate)
(@405003 ^property @405000 ^handle heaviest1 ^item-type predicate)
(@405004 ^property @405000 ^handle lightest1 ^item-type predicate)
(@406000 ^type measurable ^handle temperature ^item-type property)
(@406001 ^property @406000 ^handle hot1)
(@406002 ^property @406000 ^handle warm1)
(@406003 ^property @406000 ^handle cool1)
(@406004 ^property @406000 ^handle cold1)
(@406005 ^property @406000 ^handle hottest1)
(@406006 ^property @406000 ^handle coldest1)
(@407000 ^type visual ^handle category ^item-type property)
(@407001 ^property @407000 ^handle block)
(@407002 ^property @407000 ^handle location)
(@407003 ^property @407000 ^handle object ^subcategory @407001 @407002 @407006 @407008)
(@407004 ^multiple true ^property @407000 ^handle block)
(@407006 ^property @407000 ^handle piece)
(@501007 ^type relation ^handle linear-with1)
(@407007 ^multiple true ^property @407000 ^handle piece)
(@407008 ^property @407000 ^handle card)
(@407009 ^multiple true ^property @407000 ^handle card)
(@407010 ^property @407000 ^handle tile)
(@407011 ^multiple true ^property @407000 ^handle tile)
(@408000 ^handle cardinal-direction1 ^item-type property)
(@408001 ^property @408000 ^handle north1 ^item-type concept ^yaw 1.507000)
(@408002 ^property @408000 ^handle east1 ^item-type concept ^yaw 0.000000)
(@408003 ^property @408000 ^handle south1 ^item-type concept ^yaw -1.507000)
(@408004 ^property @408000 ^handle west1 ^item-type concept ^yaw 3.140000)
(@409000 ^handle relative-direction1 ^item-type property)
(@409001 ^property @409000 ^handle right1 ^item-type predicate ^side -1 ^yaw 1.100000)
(@409002 ^property @409000 ^handle left1 ^item-type predicate ^side 1 ^yaw 1.100000)
(@409003 ^property @409000 ^handle around1 ^item-type predicate ^side -1 ^yaw 2.700000)
(@501000 ^type relation ^relation @92 @93 @94 ^handle on1)
(@501001 ^type relation ^relation @95 @96 @97 ^handle in1)
(@501002 ^type relation ^relation @98 @99 @100 ^handle right-of1)
(@501003 ^type relation ^relation @101 @102 @103 ^handle left-of1)
(@501004 ^handle above1)
(@501005 ^type relation ^relation @104 @105 @106 ^handle below1)
(@501006 ^type relation ^handle smaller-than1)
(@501008 ^type relation ^handle next-to1)
(@501010 ^handle under1)
(@501009 ^handle aligned-with1)
(@501019 ^handle equal)
(@501021 ^handle named)
(@501023 ^handle as)
(@501022 ^handle between)
(@501013 ^handle diagonal-from1)
(@501014 ^handle behind1)
(@501015 ^type relation ^handle larger-than1)
(@501016 ^handle infront1)
(@501024 ^handle greater-than1)
(@501025 ^handle more-than1)
(@501028 ^handle worse)
(@501027 ^handle owned-by-you1)
(@501026 ^handle less-than1)
(@501029 ^handle better)
(@501033 ^handle by1)
(@501034 ^type temporal-relation ^handle during1)
(@501032 ^handle from1)
(@501031 ^handle to1)
(@501030 ^handle over)
(@501035 ^handle under1)
(@609000 ^structure-type P ^converts-to PP ^assigners @999386 ^relation-type binary)
(@609001 ^structure-type P ^converts-to PP ^assigners @999387 @999388 @999389 ^relation-type ternary)
(@999026 ^spelling enemy ^referent @999027 ^structure-type ADJ)
(@999105 ^spelling backward ^referent @999106 ^structure-type ADV)
(@999108 ^spelling around ^referent @999107 ^structure-type ADV)
(@609002 ^structure-type P ^converts-to PP ^assigners @999390 @999391 ^relation-type binary)
(@991001 ^structure-type D ^converts-to DP ^assigners @999187 @999188 @999189 @999190 ^super-converts-to CP)
(@999001 ^property @999002 ^handle latter)
(@991050 ^structure-type POS ^converts-to DP ^assigners @1000183 @1000184 @1000185 @1000186 ^super-converts-to CP)
(@999000 ^spelling latter ^referent @999001 ^structure-type ADJ ^attachment immediate)
(@999002 ^type grammatical ^handle grammatical-property)
(@999004 ^spelling former ^referent @999003 ^structure-type ADJ ^attachment immediate)
(@999003 ^property @999002 ^handle former)
(@999005 ^spelling red ^referent @401001 ^structure-type ADJ ^attachment immediate)
(@999006 ^spelling orange ^referent @401002 ^structure-type ADJ ^attachment immediate)
(@999007 ^spelling yellow ^referent @401003 ^structure-type ADJ ^attachment immediate)
(@999008 ^spelling green ^referent @401004 ^structure-type ADJ ^attachment immediate)
(@999009 ^spelling blue ^referent @401005 ^structure-type ADJ ^attachment immediate)
(@999010 ^spelling purple ^referent @401006 ^structure-type ADJ ^attachment immediate)
(@999011 ^spelling white ^referent @401007 ^structure-type ADJ ^attachment immediate)
(@999012 ^spelling black ^referent @401008 ^structure-type ADJ)
(@999013 ^spelling brown ^referent @401009 ^structure-type ADJ)
(@999014 ^spelling gray ^referent @401010 ^structure-type ADJ)
(@999015 ^spelling small ^referent @403001 ^structure-type ADJ ^attachment immediate)
(@999016 ^spelling tiny ^referent @403004 ^structure-type ADJ ^attachment immediate)
(@999017 ^spelling little ^referent @403001 ^structure-type ADJ ^attachment immediate)
(@999018 ^spelling medium ^referent @403002 ^structure-type ADJ ^attachment immediate)
(@999019 ^spelling large ^referent @403003 ^structure-type ADJ ^attachment immediate)
(@999020 ^spelling giant ^referent @403005 ^structure-type ADJ ^attachment immediate)
(@999021 ^spelling big ^referent @403003 ^structure-type ADJ ^attachment immediate)
(@999022 ^type visual ^handle property)
(@999023 ^spelling full ^referent @999024 ^structure-type ADJ)
(@999024 ^property @999025 ^handle full)
(@999025 ^type visual ^handle property)
(@999027 ^property @999022 ^handle enemy)
(@999028 ^spelling destination ^referent @999029 ^structure-type ADJ ^attachment immediate)
(@999029 ^property @404000 ^handle destination1 ^item-type predicate)
(@999030 ^spelling linear ^referent @999031 ^structure-type ADJ ^attachment immediate)
(@999031 ^property @999022 ^handle linear)
(@999032 ^spelling moved ^referent @999033 ^structure-type ADJ)
(@999033 ^property @999022 ^handle moved)
(@999034 ^spelling visible ^referent @999035 ^structure-type ADJ ^attachment immediate)
(@999035 ^property @999022 ^handle visible)
(@999036 ^spelling usual ^referent @999037 ^structure-type ADJ ^attachment immediate)
(@999037 ^property @999022 ^handle usual)
(@999038 ^spelling other ^referent @999039 ^structure-type ADJ ^attachment immediate)
(@999039 ^property @999022 ^handle other)
(@999040 ^spelling initial ^referent @999041 ^structure-type ADJ ^attachment immediate)
(@999041 ^property @999022 ^handle initial)
(@999042 ^spelling final ^referent @999043 ^structure-type ADJ ^attachment immediate)
(@999043 ^property @999022 ^handle final)
(@999044 ^spelling last last-moved ^referent @999045 @4014302 ^structure-type ADJ ^attachment immediate)
(@999045 ^property @999022 ^handle last)
(@999046 ^property @999002 ^handle original)
(@999047 ^spelling original ^referent @999046 ^structure-type ADJ ^attachment immediate)
(@999048 ^spelling empty ^referent @999049 ^structure-type ADJ ^attachment immediate)
(@999049 ^property @999022 ^handle empty)
(@999050 ^spelling same ^referent @999051 ^structure-type ADJ ^attachment immediate)
(@999051 ^property @999022 ^handle same)
(@999052 ^spelling no ^referent @999053 ^structure-type ADJ ^attachment immediate)
(@999053 ^property @999022 ^handle same)
(@999054 ^spelling closed ^referent @4014202 ^structure-type ADJ)
(@999055 ^spelling closed ^referent @999056 ^structure-type ADJ ^attachment immediate)
(@999056 ^property @999022 ^handle closed)
(@999057 ^property @999022 ^handle storage1)
(@999058 ^spelling storage ^referent @999057 ^structure-type ADJ ^attachment immediate)
(@999059 ^property @999061 ^handle starting ^item-type predicate)
(@999060 ^spelling starting ^referent @999059 ^structure-type ADJ ^attachment immediate)
(@999061 ^type visual ^handle property ^item-type property)
(@999062 ^spelling cooked ^referent @4014101 ^structure-type ADJ ^attachment immediate)
(@999063 ^spelling raw ^referent @4014102 ^structure-type ADJ)
(@999064 ^spelling open ^referent @4014201 ^structure-type ADJ)
(@999065 ^spelling wild ^referent @999066 ^structure-type ADJ ^attachment immediate)
(@999066 ^property @404000 ^handle wild)
(@999067 ^spelling top ^referent @999068 ^structure-type ADJ ^attachment immediate)
(@999068 ^property @404000 ^handle top)
(@999069 ^spelling conference ^referent @4013012 ^structure-type ADJ ^attachment immediate)
(@999070 ^spelling soar ^referent @4013007 ^structure-type ADJ ^attachment immediate)
(@999071 ^spelling robotics ^referent @4013014 ^structure-type ADJ ^attachment immediate)
(@999072 ^spelling april ^referent @4013008 ^structure-type ADJ ^attachment immediate)
(@999073 ^spelling main ^referent @4013009 ^structure-type ADJ ^attachment immediate)
(@999074 ^spelling copy ^referent @4013010 ^structure-type ADJ ^attachment immediate)
(@999075 ^spelling turned ^structure-type V ^can-be-part-of turned-on ^tense past)
(@999076 ^spelling turned-off ^referent @4014002 ^structure-type ADJ ^prior-word turned ^current-word off ^attachment immediate ^consumes-prior-word true)
(@999078 ^spelling turned-on ^referent @4014001 ^structure-type ADJ ^prior-word turned ^current-word on ^attachment immediate ^consumes-prior-word true)
(@999077 ^spelling off ^referent @4014002 ^structure-type ADJ ^attachment immediate)
(@999081 ^spelling next ^referent @999082 ^structure-type ADJ ^prior-word D ^attachment immediate)
(@999079 ^referent @4014001 ^structure-type ADJ ^alternative-structure P ^attachment immediate)
(@999080 ^spelling lit ^referent @4014001 ^structure-type ADJ ^attachment immediate)
(@999082 ^handle next1)
(@999083 ^spelling hot ^referent @406001 ^structure-type ADJ ^attachment immediate)
(@999084 ^spelling warm ^referent @406002 ^structure-type ADJ ^attachment immediate)
(@999085 ^spelling cool ^referent @406003 ^structure-type ADJ ^attachment immediate)
(@999086 ^spelling cold ^referent @406004 ^structure-type ADJ ^attachment immediate)
(@999087 ^spelling hottest ^referent @406005 ^structure-type ADJ ^attachment immediate)
(@999088 ^spelling coldest ^referent @406006 ^structure-type ADJ ^attachment immediate)
(@999089 ^spelling heavy ^referent @405001 ^structure-type ADJ ^attachment immediate)
(@999090 ^spelling light ^referent @405002 ^structure-type ADJ ^attachment immediate)
(@999091 ^spelling heaviest ^referent @405003 ^structure-type ADJ ^attachment immediate)
(@999092 ^spelling lightest ^referent @405004 ^structure-type ADJ ^attachment immediate)
(@999093 ^spelling done ^referent @4015001 ^structure-type ADJ)
(@999094 ^spelling finished ^referent @4015001 ^structure-type ADJ)
(@999095 ^spelling won ^referent @4015002 ^structure-type ADJ)
(@999096 ^spelling lost ^referent @4015003 ^structure-type ADJ)
(@999097 ^handle negation ^modifier true)
(@999098 ^spelling not ^referent @999097 ^structure-type ADV)
(@999099 ^spelling up ^referent @999100 ^structure-type ADV)
(@999100 ^handle upwards)
(@999101 ^spelling down ^referent @999102 ^structure-type ADV)
(@999102 ^handle down1)
(@999104 ^spelling forward ^referent @999103 ^structure-type ADV)
(@999103 ^handle forward)
(@999109 ^handle careful1)
(@999110 ^spelling carefully ^referent @999109 ^structure-type ADV)
(@999106 ^handle backward)
(@999107 ^handle around)
(@999111 ^spelling slowly ^referent @999112 ^structure-type ADV)
(@999112 ^handle slow1)
(@999113 ^handle away1)
(@999114 ^spelling away ^referent @999113 ^structure-type ADV)
(@999115 ^handle previously ^modifier true)
(@999116 ^spelling previously ^referent @999115 ^structure-type ADV)
(@999117 ^structure-type S ^prior-word CP ^current-word T ^assigners @999118 @999119 ^construction CP-T ^prior-word-first true false)
(@999120 ^message-type command ^structure-type S ^prior-word VP ^current-word T ^assigners @999121 @999122 ^construction *-VP-T ^prior-word-first true)
(@999354 ^spelling minutes ^referent @999355 ^number plural ^structure-type N)
(@999386 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999118 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *copy*)
(@999119 ^after @999118 ^structure-type T ^syntactic-structure terminator ^required true)
(@999121 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999123 ^message-type command ^structure-type C ^converts-to CP ^prior-word VP ^current-word T ^assigners @999124 ^construction VP-T ^prior-word-first false)
(@999122 ^after @999121 ^structure-type T ^syntactic-structure terminator ^required true)
(@999124 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999127 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999125 ^message-type command ^structure-type CP ^prior-word ROSIE ^current-word V ^assigners @999126 @999127 ^construction *-Rosie-VP ^prior-word-first true)
(@999126 ^before @999127 ^structure-type ROSIE ^syntactic-structure head ^required true ^semantic-structure agent)
(@999129 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999128 ^message-type object-definition ^structure-type S ^prior-word DP ^current-word T ^assigners @999129 @999130 ^construction *-DP-T ^prior-word-first true)
(@999130 ^after @999129 ^structure-type T ^syntactic-structure terminator ^required true)
(@999131 ^message-type object-action ^structure-type CP ^prior-word DP ^current-word V ^assigners @999132 @999133 ^construction *-DP-VP ^prior-word-first true)
(@999132 ^before @999133 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure agent)
(@999134 ^message-type object-action ^structure-type CP ^prior-word PN ^current-word V ^assigners @999135 @999136 ^construction *-PN-VP ^prior-word-first true)
(@999133 ^after @999132 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999137 ^structure-type C ^converts-to CP ^prior-word DP ^current-word V ^assigners @999138 @999139 ^construction DP-VP ^prior-word-first false)
(@999135 ^before @999136 ^structure-type NP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure agent)
(@999136 ^after @999135 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999139 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@999138 ^before @999139 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure agent)
(@999143 ^after @999141 @999142 ^structure-type T ^syntactic-structure terminator ^required true)
(@999140 ^message-type command ^structure-type S ^prior-word VPING ^current-word T ^assigners @999141 @999142 @999143 ^construction *-MV-VPING-T ^prior-word-first false)
(@999141 ^structure-type MV ^syntactic-structure action ^required true ^semantic-structure *copy*)
(@999142 ^after @999141 ^structure-type VPING ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure vping-clause)
(@999144 ^spelling stop ^referent @101106 ^number singular ^structure-type MV ^semantic-structure action ^tense present)
(@999146 ^spelling start ^referent @999145 ^number singular ^structure-type MV ^semantic-structure action ^tense present)
(@999145 ^handle start1 ^item-type action ^procedural @999147 ^action-type primitive)
(@999148 ^spelling following ^referent @999149 ^number singular ^structure-type VING ^converts-to VPING ^assigners @999150 @999151 @999152 @999153 @999154 @999155 ^semantic-structure action ^tense present)
(@999147 ^op_name initiate-start1)
(@999150 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999149 ^op_name follow)
(@999151 ^before @999152 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999153 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999152 ^after @999151 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999154 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999155 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999156 ^spelling leading ^referent @999159 ^number singular ^structure-type VING ^converts-to VPING ^assigners @999157 @999158 @999160 @999161 @999162 @999163 ^semantic-structure action ^tense present)
(@999157 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999160 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999158 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999159 ^op_name lead)
(@999161 ^before @999162 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999163 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999162 ^after @999161 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999164 ^message-type for-construct ^structure-type CP ^prior-word * ^current-word for ^assigners @999165 @999166 @999167 @999168 ^construction *-for-DP-semicolon-VP)
(@999167 ^before @999168 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure for-action-subclause)
(@999165 ^before @999166 @999167 @999168 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure for-condition)
(@999166 ^before @999167 @999168 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999169 ^optional true ^structure-type CP ^syntactic-structure nil ^semantic-structure *embed* ^embed-structure for-action-then-subclause)
(@999168 ^before @999169 ^optional true ^structure-type THEN ^syntactic-structure nil)
(@999170 ^message-type while-construct ^structure-type CP ^prior-word * ^current-word while ^assigners @999171 @999172 @999173 ^construction *-while-CP-semicolon-VP)
(@999171 ^before @999172 @999173 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure while-condition-subclause)
(@999172 ^before @999173 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999173 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure while-action-subclause)
(@999174 ^message-type otherwise-construct ^structure-type CP ^prior-word * ^current-word otherwise ^assigners @999175 @999176 ^construction *-otherwise-colon-VP)
(@999175 ^before @999176 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@999176 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *embed* ^embed-structure otherwise-action-subclause)
(@999177 ^spelling your ^referent @501027 ^number singular ^specifier definite ^super-type @991001 ^possessive true)
(@999178 ^spelling my ^number singular ^specifier definite ^super-type @991001 ^possessive true)
(@999179 ^spelling these ^number plural ^specifier definite ^super-type @991001)
(@999180 ^spelling |and that| ^number singular ^specifier definite ^prior-word and ^current-word that ^super-type @991001 ^attachment immediate ^consumes-prior-word false ^demonstrative true)
(@999181 ^spelling those ^number plural ^specifier definite ^super-type @991001)
(@999182 ^spelling their ^number plural ^specifier definite ^super-type @991001 ^possessive true)
(@999183 ^spelling a ^number singular ^specifier indefinite ^super-type @991001)
(@999184 ^spelling an ^number singular ^specifier indefinite ^super-type @991001)
(@999185 ^spelling any ^number singular ^specifier indefinite ^super-type @991001)
(@999186 ^spelling another ^number singular ^specifier indefinite distinct ^super-type @991001)
(@999187 ^before @999188 @999190 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999189 ^before @999187 @999188 @999190 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^repeatable true)
(@999188 ^before @999190 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999190 ^optional true ^structure-type RCP ^relative-position after ^syntactic-structure complement)
(@999191 ^spelling are ^number plural ^structure-type IS-V ^tense present)
(@999192 ^spelling was ^number singular ^structure-type IS-V ^tense past)
(@999193 ^spelling were ^number plural ^structure-type IS-V ^tense past)
(@999194 ^type conceptual ^handle concept)
(@999195 ^spelling game ^referent @999196 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999197 ^property @999194 ^handle time)
(@999196 ^property @999194 ^handle game1)
(@999198 ^spelling time ^referent @999197 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999201 ^spelling task ^referent @999202 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999199 ^spelling puzzle ^referent @999200 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999200 ^property @999194 ^handle puzzle1)
(@999202 ^property @999194 ^handle task1)
(@999203 ^spelling tour ^referent @999204 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999205 ^spelling name ^referent @999206 ^number singular ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999204 ^property @999194 ^handle tour1)
(@999206 ^property @999194 ^handle name1)
(@999207 ^property @999194 ^handle number1)
(@999208 ^spelling number ^referent @999207 ^number singular ^structure-type N ^syntactic-referent-type CN ^object-feature number)
(@999210 ^property @999194 ^handle goal)
(@999209 ^spelling goal ^referent @999210 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999211 ^property @999194 ^handle failure)
(@999212 ^spelling failure ^referent @999211 ^number singular ^structure-type N ^syntactic-referent-type DP ^object-feature handle)
(@999214 ^property @999215 ^handle action)
(@999213 ^spelling action ^referent @999214 ^number singular ^structure-type N ^syntactic-referent-type V ^object-feature handle)
(@999215 ^type action ^handle action)
(@999216 ^property @999194 ^handle relation)
(@999217 ^spelling relation ^referent @999216 ^number singular ^structure-type N ^syntactic-referent-type P)
(@999221 ^spelling last-name ^referent @999222 ^number singular ^structure-type N ^syntactic-referent-type ADJ)
(@999218 ^spelling relationship ^referent @999216 ^number singular ^structure-type N ^syntactic-referent-type P)
(@999219 ^spelling color ^referent @999220 ^number singular ^structure-type N ^syntactic-referent-type ADJ)
(@999220 ^property @999194 ^handle color)
(@999223 ^spelling value ^referent @999224 ^number singular ^structure-type N ^syntactic-referent-type N)
(@999222 ^property @999194 ^handle last-name)
(@999225 ^spelling location ^referent @407002 ^number singular ^structure-type N ^syntactic-referent-type DP)
(@999224 ^property @999194 ^handle value)
(@999228 ^spelling shape ^referent @999227 ^number singular ^structure-type N ^syntactic-referent-type N)
(@999226 ^spelling locations ^referent @407005 ^number plural ^structure-type N ^syntactic-referent-type DP)
(@999227 ^property @999194 ^handle shape)
(@999231 ^spelling answer ^referent @999232 ^number singular ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999229 ^spelling size ^referent @999230 ^number singular ^structure-type N ^syntactic-referent-type ADJ)
(@999230 ^property @999194 ^handle size)
(@999232 ^property @999194 ^handle answer1)
(@999233 ^spelling question ^referent @999234 ^number singular ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999235 ^spelling response ^referent @999236 ^number singular ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999234 ^property @999194 ^handle question)
(@999236 ^property @999194 ^handle response)
(@999237 ^property @999194 ^handle message)
(@999238 ^spelling message ^referent @999237 ^number singular ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999240 ^spelling steps ^referent @999239 ^number plural ^structure-type N ^syntactic-referent-type N ^object-feature handle)
(@999239 ^multiple true ^property @402000 ^handle steps1 ^item-type object)
(@999242 ^spelling state ^referent @999241 ^number singular ^structure-type N)
(@999241 ^property @404000 ^handle state1 ^item-type object)
(@999243 ^property @402000 ^handle drink1 ^item-type object)
(@999244 ^spelling drink ^referent @999243 ^number singular ^structure-type N)
(@999245 ^property @402000 ^handle soldier1 ^item-type object)
(@999246 ^spelling soldier ^referent @999245 ^number singular ^structure-type N)
(@999247 ^spelling man ^referent @999248 ^number singular ^structure-type N)
(@999248 ^property @402000 ^handle man1 ^item-type object)
(@999249 ^spelling woman ^referent @999250 ^number singular ^structure-type N)
(@999250 ^property @402000 ^handle woman1 ^item-type object)
(@999251 ^property @402000 ^handle adult1 ^item-type object)
(@999252 ^spelling adult ^referent @999251 ^number singular ^structure-type N)
(@999253 ^property @404000 ^handle solution1 ^item-type object)
(@999254 ^spelling solution ^referent @999253 ^number singular ^structure-type N)
(@999255 ^spelling child ^referent @999256 ^number singular ^structure-type N)
(@999256 ^property @402000 ^handle child1 ^item-type object)
(@999257 ^multiple true ^spelling missionaries ^referent @999258 ^number plural ^structure-type N)
(@999258 ^multiple true ^property @402000 ^handle missionary1 ^item-type object)
(@999259 ^property @402000 ^handle missionary1 ^item-type object ^number singular)
(@999260 ^spelling missionary ^referent @999259 ^number singular ^structure-type N)
(@999261 ^spelling cannibals ^referent @999262 ^number plural ^structure-type N)
(@999262 ^multiple true ^property @402000 ^handle cannibal1 ^item-type object)
(@999263 ^property @402000 ^handle cannibal1 ^item-type object ^number singular)
(@999264 ^spelling cannibal ^referent @999263 ^number singular ^structure-type N)
(@999265 ^spelling boat ^referent @999266 ^number singular ^structure-type N)
(@999266 ^property @402000 ^handle boat1 ^item-type object)
(@999267 ^property @402000 ^handle river1 ^item-type object)
(@999268 ^spelling river ^referent @999267 ^number singular ^structure-type N)
(@999269 ^spelling side ^referent @999270 ^number singular ^structure-type N)
(@999270 ^property @402000 ^handle side1 ^item-type object)
(@999271 ^spelling bank ^referent @999272 ^number singular ^structure-type N)
(@999272 ^property @402000 ^handle bank1 ^item-type object)
(@999273 ^spelling rank ^referent @999274 ^number singular ^structure-type N)
(@999274 ^property @999194 ^handle rank1)
(@999275 ^spelling suit ^referent @999276 ^number singular ^structure-type N)
(@999276 ^property @999194 ^handle suit1)
(@999277 ^property @402000 ^handle opponent1 ^item-type object)
(@999278 ^spelling opponent ^referent @999277 ^number singular ^structure-type N)
(@999279 ^spelling people ^referent @999280 ^number singular ^structure-type N)
(@999280 ^property @402000 ^handle people1 ^item-type object)
(@999281 ^spelling person ^referent @999282 ^number singular ^structure-type N)
(@999282 ^property @402000 ^handle person1 ^item-type object)
(@999283 ^spelling hand ^referent @999284 ^number singular ^structure-type N)
(@999284 ^property @402000 ^handle hand1 ^item-type object)
(@999285 ^spelling deck ^referent @999286 ^number singular ^structure-type N)
(@999286 ^property @402000 ^handle deck ^item-type object)
(@999287 ^spelling rectangle ^referent @402008 ^number signular ^structure-type N)
(@999288 ^spelling triangle ^referent @402001 ^number singular ^structure-type N)
(@999289 ^spelling triangles ^referent @402019 ^number plural ^structure-type N)
(@999290 ^spelling arch ^referent @402002 ^number signular ^structure-type N)
(@999291 ^spelling square ^referent @402003 ^number signular ^structure-type N)
(@999292 ^spelling line ^referent @402018 ^number singular ^structure-type N)
(@999293 ^spelling row ^referent @402018 ^number singular ^structure-type N)
(@999294 ^spelling block ^referent @407001 ^number singular ^structure-type N)
(@999295 ^spelling object ^referent @407003 ^number singular ^structure-type N)
(@999296 ^spelling blocks ^referent @407004 ^number plural ^structure-type N)
(@999297 ^spelling l-block ^referent @402004 ^number singular ^structure-type N)
(@999298 ^property @402004 ^spelling t-block ^referent @402005 ^number singular ^structure-type N)
(@999299 ^spelling sphere ^referent @402006 ^number singular ^structure-type N)
(@999300 ^spelling tile ^referent @407010 ^number singular ^structure-type N)
(@999301 ^spelling tiles ^referent @407011 ^number plural ^structure-type N)
(@999302 ^spelling piece ^referent @407006 ^number singular ^structure-type N)
(@999303 ^spelling pieces ^referent @407007 ^number plural ^structure-type N)
(@999304 ^spelling card ^referent @407008 ^number singular ^structure-type N)
(@999305 ^spelling cards ^referent @407009 ^number plural ^structure-type N)
(@999306 ^spelling fridge ^referent @404043 ^number singular ^structure-type N)
(@999307 ^spelling stove ^referent @404023 ^number singular ^structure-type N ^on-off-state-change true)
(@999311 ^spelling garbage ^referent @404002 ^number singular ^structure-type N)
(@999308 ^spelling faucet ^referent @404044 ^number singular ^structure-type N ^on-off-state-change true)
(@999309 ^spelling cup ^referent @404046 ^number singular ^structure-type N ^on-off-state-change true)
(@999310 ^spelling pantry ^referent @404001 ^number singular ^structure-type N)
(@999312 ^spelling table ^referent @404003 ^number singular ^structure-type N)
(@999313 ^spelling kitchen ^referent @4013001 ^number singular ^structure-type N)
(@999314 ^spelling office ^referent @4012011 ^number singular ^structure-type N)
(@999315 ^spelling lab ^referent @4013013 ^number singular ^structure-type N)
(@999316 ^spelling bedroom ^referent @4013003 ^number singular ^structure-type N)
(@999317 ^spelling bathroom ^referent @4013004 ^number singular ^structure-type N)
(@999318 ^spelling laundry ^referent @4013005 ^number singular ^structure-type N)
(@999319 ^spelling wp47 ^referent @4013047 ^number singular ^structure-type N)
(@999320 ^spelling wp48 ^referent @4013048 ^number singular ^structure-type N)
(@999321 ^spelling wp49 ^referent @4013049 ^number singular ^structure-type N)
(@999322 ^spelling wp50 ^referent @4013050 ^number singular ^structure-type N)
(@999323 ^spelling wp51 ^referent @4013051 ^number singular ^structure-type N)
(@999324 ^spelling wp52 ^referent @4013052 ^number singular ^structure-type N)
(@999325 ^spelling wp53 ^referent @4013053 ^number singular ^structure-type N)
(@999326 ^spelling chicken ^referent @402007 ^number singular ^structure-type N)
(@999327 ^spelling steak ^referent @402012 ^number singular ^structure-type N)
(@999328 ^spelling lights ^referent @402013 ^number singular ^structure-type N ^on-off-state-change true)
(@999331 ^spelling sodas ^referent @402010 ^number plural ^structure-type N)
(@999329 ^spelling light ^referent @402013 ^number singular ^structure-type N ^on-off-state-change true)
(@999330 ^spelling soda ^referent @402010 ^number singular ^structure-type N)
(@999332 ^spelling water ^referent @404045 ^number singular ^structure-type N ^syntactic-referent-type DP)
(@999334 ^spelling stapler ^referent @402020 ^number singular ^structure-type N)
(@999333 ^spelling trash ^referent @402017 ^number singular ^structure-type N)
(@999335 ^spelling box ^referent @402011 ^number singular ^structure-type N)
(@999336 ^spelling book ^referent @402021 ^number singular ^structure-type N)
(@999337 ^spelling package ^referent @402014 ^number singular ^structure-type N)
(@999338 ^spelling papers ^referent @402015 ^number plural ^structure-type N)
(@999339 ^spelling kinect ^referent @402016 ^number singular ^structure-type N)
(@999340 ^spelling meter ^referent @4010001 ^number singular ^structure-type N)
(@999341 ^spelling meters ^referent @4010001 ^number plural ^structure-type N)
(@999342 ^spelling foot ^referent @4010002 ^number singular ^structure-type N)
(@999343 ^spelling feet ^referent @4010002 ^number plural ^structure-type N)
(@999344 ^spelling inch ^referent @4010003 ^number singular ^structure-type N)
(@999345 ^spelling inches ^referent @4010003 ^number plural ^structure-type N)
(@999346 ^spelling centimeter ^referent @4010004 ^number singular ^structure-type N)
(@999347 ^spelling centimeters ^referent @4010004 ^number plural ^structure-type N)
(@999348 ^handle middle-of1)
(@999349 ^relation @999348 ^spelling middle-noun ^number singular ^structure-type N ^prior-word D ^current-word middle ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999350 ^relation @999351 ^spelling front-noun ^number singular ^structure-type DP ^prior-word P ^current-word front ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999352 ^handle back-of1)
(@999353 ^relation @999352 ^spelling back-noun ^number singular ^structure-type DP ^prior-word P ^current-word back ^semantic-structure predicate ^consumes-prior-word false ^semantic-entity-type relation)
(@999351 ^handle front-of1)
(@999387 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true)
(@999389 ^before @999387 @999388 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999355 ^property @4010000 ^handle minute)
(@999356 ^spelling minute ^referent @999355 ^number singular ^structure-type N)
(@999357 ^spelling wall ^referent @4012002 ^number singular ^structure-type N)
(@999358 ^spelling end ^referent @4012001 ^number singular ^structure-type N)
(@999359 ^spelling north ^referent @408001 ^number singular ^structure-type CARDINAL)
(@999360 ^spelling south ^referent @408003 ^number singular ^structure-type CARDINAL)
(@999361 ^spelling east ^referent @408002 ^number singular ^structure-type CARDINAL)
(@999362 ^spelling west ^referent @408004 ^number singular ^structure-type CARDINAL)
(@999363 ^spelling n ^referent @408001 ^number singular ^structure-type CARDINAL)
(@999364 ^spelling s ^referent @408003 ^number singular ^structure-type CARDINAL)
(@999365 ^spelling e ^referent @408002 ^number singular ^structure-type CARDINAL)
(@999366 ^spelling w ^referent @408004 ^number singular ^structure-type CARDINAL)
(@999367 ^spelling waypoint ^referent @4012009 ^number singular ^structure-type N)
(@999368 ^spelling hall ^referent @4012003 ^number singular ^structure-type N)
(@999369 ^spelling hallway ^referent @4012003 ^number singular ^structure-type N)
(@999370 ^spelling intersection ^referent @4012005 ^number singular ^structure-type N)
(@999371 ^spelling intersections ^referent @4012005 ^number plural ^structure-type N)
(@999372 ^spelling junction ^referent @4012005 ^number singular ^structure-type N)
(@999373 ^spelling door ^referent @4012004 ^number singular ^structure-type N)
(@999374 ^spelling doors ^referent @4012014 ^number plural ^structure-type N)
(@999375 ^spelling building ^referent @4013011 ^number singular ^structure-type N)
(@999376 ^spelling doorway ^referent @4012004 ^number singular ^structure-type N)
(@999377 ^spelling doorways ^referent @4012014 ^number plural ^structure-type N)
(@999378 ^spelling opening ^referent @4012006 ^number singular ^structure-type N)
(@999379 ^spelling t-intersection ^referent @4012007 ^number singular ^structure-type N)
(@999380 ^spelling room ^referent @4012008 ^number singular ^structure-type N)
(@999381 ^spelling where ^number singular ^structure-type QP ^question true)
(@999382 ^spelling what ^number singular ^structure-type QP ^question true)
(@999383 ^spelling there ^referent @999384 ^number singular ^structure-type DPX)
(@999384 ^property @999385 ^handle there)
(@999385 ^type visual ^handle handle)
(@999394 ^handle during1)
(@999396 ^relation @999397 ^spelling by ^super-type @609000 ^attachment immediate)
(@999401 ^relation @999400 ^spelling with ^super-type @609000 ^attachment immediate)
(@999395 ^relation @999394 ^spelling during ^super-type @609000 ^attachment immediate)
(@999388 ^before @999387 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@999391 ^optional true ^structure-type ANY ^relative-position after ^syntactic-structure head ^exclusive @999390 ^strip-assigners true)
(@999390 ^optional true ^structure-type U ^relative-position after ^syntactic-structure head ^exclusive @999391 ^strip-assigners true)
(@999392 ^relation @999393 ^spelling matched-by ^super-type @609000 ^attachment immediate)
(@999393 ^handle matched-by1)
(@999402 ^relation @999403 ^spelling about ^super-type @609000)
(@999405 ^relation @999404 ^spelling for ^super-type @609000)
(@999397 ^handle by1)
(@999398 ^handle of1)
(@999399 ^relation @999398 ^spelling of ^super-type @609000 ^attachment immediate)
(@999400 ^handle with1)
(@999406 ^relation @999407 ^spelling flank flanks ^super-type @609000 ^attachment immediate)
(@999403 ^handle about1)
(@999404 ^handle for1)
(@999409 ^handle hold1)
(@999410 ^relation @999411 ^spelling heard ^super-type @609000 ^attachment immediate)
(@999407 ^handle flank1)
(@999408 ^relation @999409 ^spelling hold ^super-type @609000 ^attachment immediate)
(@999411 ^handle heard1)
(@999412 ^relation @501002 ^spelling right-of ^structure-type P ^converts-to PP ^assigners @999413 ^relation-type binary)
(@999413 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head)
(@999421 ^relation @999420 ^alternative-structure ADJ ^super-type @609000)
(@999437 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure until-clause)
(@999448 ^relation @501026 ^spelling less-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word less ^current-word than ^assigners @999447)
(@999414 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head)
(@999415 ^relation @501003 ^spelling left-of ^structure-type P ^converts-to PP ^assigners @999414 ^relation-type binary)
(@999416 ^relation @501001 ^spelling at ^super-type @609000)
(@999417 ^relation @501032 ^spelling from ^super-type @609000 ^directional true)
(@999418 ^relation @501000 ^spelling ontop ^super-type @609000)
(@999419 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999436 ^relation @999435 ^spelling until ^structure-type P ^converts-to UNTIL-PP ^assigners @999437 ^attachment immediate)
(@999420 ^handle off1)
(@999422 ^relation @501001 ^spelling in ^super-type @609000)
(@999423 ^relation @501001 ^spelling inside ^super-type @609000)
(@999424 ^relation @501005 ^spelling below ^super-type @609000)
(@999425 ^relation @501035 ^spelling under ^super-type @609000 ^directional true)
(@999426 ^relation @501014 ^spelling behind ^super-type @609000)
(@999427 ^relation @501004 ^spelling above ^super-type @609000)
(@999428 ^relation @501001 ^spelling into ^super-type @609000 ^directional true)
(@999429 ^relation @501000 ^spelling onto ^super-type @609000 ^directional true)
(@999430 ^relation @501030 ^spelling over ^structure-type P)
(@999431 ^relation @501017 ^spelling holding ^super-type @609000 ^directional false)
(@999432 ^relation @501023 ^spelling as ^super-type @609000)
(@999433 ^relation @501021 ^spelling named ^super-type @609002 ^directional false)
(@999434 ^relation @501021 ^spelling called ^super-type @609002 ^directional false)
(@999435 ^handle until1)
(@999789 ^structure-type ROSIE ^syntactic-structure complement ^required true ^semantic-structure agent)
(@999438 ^relation @501006 ^spelling smaller ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999439 ^relation @501026 ^spelling less ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999440 ^relation @501015 ^spelling larger bigger ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999441 ^relation @501024 ^spelling greater ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999442 ^relation @501025 ^spelling more ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999443 ^relation @501028 ^spelling worse ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999444 ^relation @501029 ^spelling better ^structure-type C-ADJ ^converts-to C-ADJ-P)
(@999445 ^relation @501006 ^spelling smaller-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word smaller ^current-word than ^assigners @999446)
(@999446 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999451 ^relation @501015 ^spelling larger-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word larger bigger ^current-word than ^assigners @999452)
(@999447 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999449 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999454 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999450 ^relation @501028 ^spelling worse-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word worse ^current-word than ^assigners @999449)
(@999452 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999456 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999453 ^relation @501024 ^spelling greater-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word greater ^current-word than ^assigners @999454)
(@999458 ^relation @501029 ^spelling better-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word better ^current-word than ^assigners @999457)
(@999455 ^relation @501025 ^spelling more-than ^structure-type C-ADJ ^converts-to C-ADJ-P ^prior-word more ^current-word than ^assigners @999456)
(@999462 ^relation @501011 ^spelling near ^structure-type P ^converts-to PP)
(@999457 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999459 ^relation @501011 ^spelling next ^structure-type P ^converts-to PP)
(@999460 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999465 ^relation @501012 ^spelling diagonal ^structure-type P ^converts-to PP)
(@999461 ^relation @501011 ^spelling next-to ^structure-type P ^converts-to PP ^prior-word next ^current-word to ^assigners @999460)
(@999463 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999469 ^relation @501019 ^spelling equal-to ^structure-type P ^converts-to PP ^prior-word equal ^current-word to ^assigners @999470)
(@999464 ^relation @501011 ^spelling near ^structure-type P ^converts-to PP ^prior-word near ^assigners @999463)
(@999466 ^relation @501012 ^spelling diagonal ^structure-type P ^converts-to PP ^prior-word diagonal ^current-word with ^assigners @999467)
(@999467 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999472 ^spelling in-front ^structure-type in-front ^converts-to PP ^prior-word in ^current-word front ^can-be-part-of in-front-of)
(@999468 ^relation @501019 ^spelling equal ^structure-type P ^converts-to PP)
(@999470 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999475 ^relation @501022 ^spelling between ^super-type @609001 ^attachment immediate)
(@999471 ^relation @501016 ^spelling front ^structure-type FRONT ^converts-to PP)
(@999473 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999481 ^before @999480 @999482 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999474 ^relation @501016 ^spelling in-front-of ^structure-type P ^converts-to PP ^prior-word in-front ^current-word of ^assigners @999473)
(@999476 ^spelling |.| ^structure-type T ^delay-retry true)
(@999477 ^spelling |?| ^structure-type QT ^delay-retry true)
(@999478 ^spelling |!| ^structure-type T ^delay-retry true)
(@999479 ^spelling prefer ^referent @101123 ^number singular ^structure-type V ^converts-to VP ^assigners @999480 @999481 @999482 ^semantic-structure action ^tense present)
(@999787 ^handle rosie)
(@999788 ^spelling |rosie,| ^structure-type ROSIE ^prior-word ROSIE ^current-word |,| ^assigners @999789 ^consumes-prior-word true)
(@999480 ^optional true ^structure-type GP ^syntactic-structure complement2 ^semantic-structure *embed* ^embed-structure subclause2)
(@999484 ^optional true ^structure-type GP ^syntactic-structure complement2 ^semantic-structure *embed* ^embed-structure subclause2)
(@999489 ^before @999488 @999490 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999482 ^before @999480 ^optional true ^structure-type P ^syntactic-structure adjunct ^referent-type literal ^lexical-item-spelling over)
(@999483 ^spelling consider ^referent @101146 ^number singular ^structure-type V ^converts-to VP ^assigners @999484 @999485 @999486 ^semantic-structure action ^tense present)
(@999485 ^before @999484 @999486 ^structure-type GP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure *embed* ^embed-structure subclause1)
(@999537 ^spelling detect ^referent @101111 ^super-type @60997)
(@999486 ^before @999484 ^optional true ^structure-type P ^syntactic-structure adjunct ^referent-type literal ^lexical-item-spelling over)
(@999487 ^spelling avoid ^referent @101124 ^number singular ^structure-type V ^converts-to VP ^assigners @999488 @999489 @999490 ^semantic-structure action ^tense present)
(@999488 ^optional true ^structure-type GP ^semantic-structure *embed* ^embed-structure subclause2)
(@999492 ^spelling throw ^referent @101032 ^super-type @60998 ^directional true)
(@999490 ^before @999488 ^optional true ^structure-type P ^syntactic-structure adjunct ^semantic-structure on-off-state ^referent-type literal ^lexical-item-spelling over)
(@999491 ^spelling tell ^referent @101031 ^super-type @60991)
(@999493 ^spelling move ^referent @101008 ^super-type @60987 ^directional true ^tense present)
(@999494 ^spelling set ^referent @101013 ^super-type @60997 ^directional true)
(@999495 ^spelling place ^referent @101000 ^super-type @60999 ^directional true)
(@999496 ^spelling attack ^referent @101144 ^super-type @60997 @60999 ^directional true)
(@999497 ^spelling fill ^referent @101244 ^super-type @60999 ^directional true)
(@999498 ^spelling put ^referent @101000 ^super-type @60985 ^directional true)
(@999499 ^spelling said ^referent @101116 ^super-type @60999 ^tense past)
(@999500 ^spelling discard ^referent @101010 ^super-type @60998)
(@999501 ^spelling pick ^referent @101001 ^super-type @60998 ^can-be-part-of pick-up)
(@999502 ^spelling cook ^referent @101012 ^super-type @60998)
(@999503 ^spelling open ^referent @101003 ^super-type @60997 ^can-be-part-of open-up)
(@999504 ^spelling close ^referent @101004 ^converts-to VP ^super-type @60997)
(@999505 ^spelling organize ^referent @108009 ^super-type @60997)
(@999506 ^spelling clean ^referent @101014 ^super-type @60997)
(@999507 ^spelling activate ^referent @101005 ^super-type @60997)
(@999508 ^spelling store ^referent @101009 ^super-type @60996)
(@999509 ^spelling matches ^referent @101147 ^super-type @60987 ^directional true ^tense present)
(@999510 ^spelling point ^referent @101002 ^super-type @60995)
(@999511 ^spelling check ^referent @101113 ^super-type @60990)
(@999512 ^spelling test ^referent @101113 ^super-type @60990)
(@999513 ^spelling fetch ^referent @101019 ^super-type @60999 ^directional true)
(@999514 ^spelling has ^referent @101119 ^super-type @60989)
(@999515 ^spelling have ^referent @101119 ^super-type @60989)
(@999516 ^spelling play ^referent @101120 ^super-type @60999)
(@999517 ^spelling wins ^referent @101121 ^super-type @60993)
(@999518 ^spelling win ^referent @101121 ^super-type @60993)
(@999519 ^spelling lose ^referent @101122 ^super-type @60993)
(@999520 ^spelling ignore ^referent @101118 ^super-type @60988)
(@999521 ^spelling attend ^referent @101117 ^super-type @60988)
(@999522 ^spelling attend-to ^referent @101117 ^prior-word attend ^current-word to ^super-type @60998 ^consumes-prior-word true)
(@999523 ^spelling stop ^referent @101106 ^super-type @60995)
(@999524 ^message-type command ^referent @101106 ^structure-type CP ^semantic-structure action ^spelling-single-word stop)
(@999525 ^spelling deliver ^referent @101018 ^super-type @60999 ^directional true)
(@999526 ^spelling scan ^referent @101125 ^super-type @60992)
(@999527 ^spelling give ^referent @101126 ^super-type @60999 ^directional true)
(@999528 ^spelling take ^referent @101127 ^super-type @60999)
(@999529 ^spelling guide ^referent @101128 ^super-type @60999)
(@999530 ^spelling serve ^referent @101129 ^super-type @60999)
(@999531 ^spelling perform ^referent @101131 ^super-type @60998)
(@999532 ^spelling bring ^referent @101130 ^super-type @60999)
(@999533 ^message-type command ^spelling turn-left ^referent @101100 ^structure-type CP ^prior-word turn ^current-word left ^prior-word-first true ^referent2 @409002 ^semantic-structure action ^semantic-structure2 arg1)
(@999545 ^spelling go-down ^referent @101103 ^prior-word go ^current-word down ^prior-word-first true ^super-type @60993)
(@999534 ^message-type command ^spelling turn-right ^referent @101100 ^structure-type CP ^prior-word turn ^current-word right ^prior-word-first true ^referent2 @409001 ^semantic-structure action ^semantic-structure2 arg1)
(@999535 ^message-type command ^spelling turn-around ^referent @101100 ^structure-type CP ^prior-word turn ^current-word around ^prior-word-first true ^referent2 @409003 ^semantic-structure action ^semantic-structure2 arg1)
(@999536 ^spelling see ^referent @101111 ^super-type @60997)
(@999538 ^spelling sense ^referent @101111 ^super-type @60997)
(@999539 ^spelling encounter ^referent @101111 ^super-type @60997)
(@999540 ^spelling reach ^referent @101111 ^super-type @60997)
(@999541 ^spelling explore ^referent @101110 ^super-type @60992)
(@999542 ^spelling go ^referent @101103 ^super-type @60992)
(@999543 ^message-type command ^referent @101103 ^structure-type CP ^semantic-structure action ^spelling-single-word go)
(@999552 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999544 ^message-type command ^referent @101103 ^structure-type CP ^semantic-structure action ^spelling-single-word forward)
(@999546 ^spelling drive ^referent @101103 ^super-type @60992)
(@999547 ^message-type command ^referent @101103 ^structure-type CP ^semantic-structure action ^spelling-single-word drive)
(@999548 ^spelling drive-down ^referent @101103 ^prior-word drive ^current-word down ^prior-word-first true ^super-type @60993)
(@999549 ^spelling remember ^referent @101112 ^number singular ^structure-type V ^converts-to VP ^assigners @999550 @999551 @999552 ^semantic-structure action ^tense present)
(@999550 ^before @999552 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999573 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure complement ^exclusive @999572 ^semantic-structure arg1)
(@999551 ^structure-type P ^syntactic-structure nil ^required true ^lexical-item-spelling as)
(@999553 ^spelling remember-if ^referent @101112 ^number singular ^structure-type V ^converts-to VP ^prior-word remember ^current-word if ^assigners @999554 @999555 @999556 ^semantic-structure action ^tense present)
(@999554 ^before @999555 @999556 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure if-subclause)
(@999557 ^spelling heard ^referent @101115 ^number singular ^structure-type V ^converts-to VP ^assigners @999558 @999559 ^semantic-structure action ^tense present)
(@999555 ^before @999556 ^structure-type P ^syntactic-structure nil ^required true ^lexical-item-spelling as)
(@999556 ^structure-type DP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999560 ^spelling recall ^referent @101114 ^number singular ^structure-type V ^converts-to VP ^assigners @999561 @999562 ^semantic-structure action ^tense present)
(@999558 ^before @999559 ^structure-type PN ^relative-position before ^syntactic-structure head ^required true ^semantic-structure agent)
(@999559 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1)
(@999561 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999563 ^semantic-structure arg1)
(@999562 ^structure-type PP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure predicate)
(@999564 ^spelling think ^referent @101143 ^structure-type V ^converts-to VP ^assigners @999565 @999566 ^semantic-structure action ^tense present)
(@999565 ^before @999566 ^structure-type PP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@999566 ^structure-type PP ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg1)
(@999567 ^spelling ask ^referent @101030 ^number singular ^structure-type V ^converts-to VP ^assigners @999568 @999569 @999570 ^semantic-structure action ^tense present)
(@999568 ^optional true ^structure-type U ^relative-position after ^syntactic-structure complement ^exclusive @999569 ^semantic-structure arg1)
(@999569 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure complement ^exclusive @999568 ^semantic-structure arg1)
(@999570 ^before @999568 @999569 ^optional true ^structure-type PN ^relative-position after ^syntactic-structure head ^semantic-structure agent)
(@999571 ^spelling say ^referent @101116 ^number singular ^structure-type V ^converts-to VP ^assigners @999572 @999573 ^semantic-structure action ^tense present)
(@999577 ^spelling face ^referent @101107 ^number singular ^structure-type V ^converts-to VP ^assigners @999578 ^semantic-structure action ^tense present)
(@999572 ^optional true ^structure-type U ^relative-position after ^syntactic-structure complement ^exclusive @999573 ^semantic-structure arg1)
(@999574 ^spelling follow ^referent @101104 ^super-type @60993)
(@999575 ^spelling orient ^referent @101107 ^number singular ^structure-type V ^converts-to VP ^assigners @999576 ^semantic-structure action ^tense present)
(@999579 ^spelling load ^referent @101145 ^number singular ^structure-type V ^converts-to VP ^assigners @999580 ^semantic-structure action ^tense present)
(@999576 ^structure-type CARDINAL ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999597 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^exclusive @999593 ^semantic-structure arg2)
(@999578 ^structure-type CARDINAL ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999580 ^structure-type U ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999581 ^spelling stack ^referent @101011 ^number singular ^structure-type V ^converts-to VP ^assigners @999582 @999583 @999584 @999585 @999586 ^semantic-structure action ^tense present)
(@999582 ^before @999584 ^optional true ^structure-type DP ^syntactic-structure head ^semantic-structure arg2)
(@999583 ^optional true ^structure-type CONJ ^syntactic-structure nil)
(@999584 ^optional true ^structure-type DP ^syntactic-structure head ^semantic-structure arg3)
(@999585 ^before @999582 @999584 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999586 ^before @999583 ^optional true ^structure-type CONJ ^syntactic-structure nil)
(@999587 ^after @999588 ^structure-type ADJ ^relative-position after ^syntactic-structure adjunct ^required true ^exclusive @999589 ^semantic-structure on-off-state ^referent-type literal ^lexical-item-spelling off)
(@999592 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999588 ^before @999587 @999589 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1)
(@999589 ^after @999588 ^structure-type ADJ ^relative-position after ^syntactic-structure adjunct ^required true ^exclusive @999587 ^semantic-structure on-off-state ^referent-type literal ^lexical-item-spelling on)
(@999590 ^message-type wait ^structure-type CP ^spelling-single-word wait)
(@999591 ^spelling wait ^referent @101007 ^super-type @60993)
(@999593 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999596 @999597 ^semantic-structure arg2)
(@999594 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999595 ^before @999593 @999597 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999608 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999596 ^after @999595 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^exclusive @999593 ^semantic-structure *copy* ^repeatable true)
(@999598 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999599 ^optional true ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent)
(@999600 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999601 ^after @999600 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999602 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999603 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999604 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999605 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999606 ^before @999607 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999634 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure relation)
(@999607 ^after @999606 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999609 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999610 ^optional true ^structure-type DP ^relative-position before ^syntactic-structure nil ^semantic-structure agent)
(@999611 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999612 ^after @999617 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999613 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999614 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999615 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999616 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999617 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999618 ^after @999623 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999619 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999620 ^optional true ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999621 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999622 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999623 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1)
(@999624 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999625 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999626 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999627 ^optional true ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2)
(@999628 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1)
(@999629 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999630 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999631 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999632 ^before @999627 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^semantic-structure arg1)
(@999643 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999633 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999635 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999636 ^before @999634 @999637 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^semantic-structure arg1 ^referent-type literal)
(@999637 ^optional true ^structure-type UNTIL-PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2)
(@999638 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999639 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999640 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999641 ^before @999642 ^structure-type PN ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999647 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999649 @999650 ^semantic-structure predicate ^referent-type literal)
(@999642 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2 ^referent-type literal)
(@999644 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999645 ^structure-type IF-CLAUSE ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999659 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999646 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999648 ^optional true ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent)
(@999649 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999647 @999650 ^semantic-structure arg1)
(@999650 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999647 @999649 ^semantic-structure predicate)
(@999651 ^optional true ^structure-type P ^relative-position after ^syntactic-structure head ^exclusive @999655 ^semantic-structure arg1 ^referent-type literal ^strip-assigners true)
(@999652 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999653 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999654 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999655 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999651 ^semantic-structure arg1)
(@999656 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999657 ^after @999659 @999661 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg3)
(@999672 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@999658 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999660 ^after @999659 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999661 ^before @999657 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg2)
(@999662 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999663 ^optional true ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent)
(@999664 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999665 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999666 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999667 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^semantic-structure arg1)
(@999668 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999669 ^optional true ^structure-type V-AUX ^relative-position before ^syntactic-structure nil ^semantic-structure action-modifier)
(@999670 ^before @999672 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999681 ^message-type yes ^structure-type CP ^spelling-single-word yeah)
(@999671 ^after @999670 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999673 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@999674 ^optional true ^structure-type DP ^relative-position before ^syntactic-structure head ^semantic-structure agent)
(@999675 ^spelling turn-on ^referent @101015 ^prior-word turn ^current-word on ^prior-word-first true ^super-type @60997)
(@999676 ^spelling turn-off ^referent @101016 ^prior-word turn ^current-word off ^prior-word-first true ^super-type @60997 ^prior-word-lti @60001)
(@999677 ^spelling clean-up ^referent @1010014 ^prior-word clean ^current-word up ^prior-word-first true ^super-type @60997 ^prior-word-lti @60001)
(@999678 ^spelling open-up ^referent @101003 ^prior-word open ^current-word up ^prior-word-first true ^super-type @60997)
(@999679 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true)
(@999778 ^message-type second-tower3 ^structure-type CP ^spelling-single-word second-tower3)
(@999680 ^relation @501000 ^spelling on-to ^structure-type P ^converts-to PP ^prior-word on ^current-word to ^assigners @999679 ^directional true)
(@999698 ^message-type init-tower3 ^structure-type CP ^spelling-single-word init-tower3)
(@999682 ^message-type yes ^structure-type CP ^spelling-single-word ok)
(@999683 ^message-type yes ^structure-type CP ^spelling-single-word yes)
(@999684 ^message-type no ^structure-type CP ^spelling-single-word no)
(@999685 ^message-type no ^structure-type CP ^spelling-single-word nope)
(@999686 ^message-type finished ^structure-type CP ^spelling-single-word go)
(@999687 ^message-type finished ^structure-type CP ^spelling-single-word done)
(@999688 ^message-type finished ^structure-type CP ^spelling-single-word finished)
(@999689 ^message-type restart ^structure-type CP ^spelling-single-word restart)
(@999690 ^message-type hello ^structure-type CP ^spelling-single-word hi)
(@999691 ^message-type hello ^structure-type CP ^spelling-single-word hello)
(@999692 ^message-type bye ^structure-type CP ^spelling-single-word bye)
(@999693 ^message-type bye ^structure-type CP ^spelling-single-word goodbye)
(@999694 ^message-type init-3mens ^structure-type CP ^spelling-single-word init-3mens)
(@999695 ^message-type init-maze ^structure-type CP ^spelling-single-word init-maze)
(@999696 ^message-type final-maze ^structure-type CP ^spelling-single-word final-maze)
(@999697 ^message-type init-tictactoe ^structure-type CP ^spelling-single-word init-tictactoe)
(@999749 ^message-type init-blocksworld ^structure-type CP ^spelling-single-word init-blocksworld)
(@999699 ^message-type init-tower4 ^structure-type CP ^spelling-single-word init-tower4)
(@999700 ^message-type fail-tower4 ^structure-type CP ^spelling-single-word fail-tower4)
(@999701 ^message-type fail-tower3 ^structure-type CP ^spelling-single-word fail-tower3)
(@999702 ^message-type fail-tower5 ^structure-type CP ^spelling-single-word fail-tower5)
(@999703 ^message-type init-tower5 ^structure-type CP ^spelling-single-word init-tower5)
(@999704 ^message-type init-8puzzle4 ^structure-type CP ^spelling-single-word init-8puzzle4)
(@999705 ^message-type init-8puzzle5 ^structure-type CP ^spelling-single-word init-8puzzle5)
(@999706 ^message-type init-8puzzle6 ^structure-type CP ^spelling-single-word init-8puzzle6)
(@999707 ^message-type init-8puzzle6alt ^structure-type CP ^spelling-single-word init-8puzzle6alt)
(@999708 ^message-type init-8puzzle ^structure-type CP ^spelling-single-word init-8puzzle)
(@999709 ^message-type init-i8puzzle ^structure-type CP ^spelling-single-word init-i8puzzle)
(@999710 ^message-type init-i15puzzle ^structure-type CP ^spelling-single-word init-i15puzzle)
(@999711 ^message-type init-5puzzle ^structure-type CP ^spelling-single-word init-5puzzle)
(@999712 ^message-type init-i5puzzle ^structure-type CP ^spelling-single-word init-i5puzzle)
(@999713 ^message-type init-husbands ^structure-type CP ^spelling-single-word init-husbands)
(@999714 ^message-type final-husbands ^structure-type CP ^spelling-single-word final-husbands)
(@999715 ^message-type fail-husbands ^structure-type CP ^spelling-single-word fail-husbands)
(@999716 ^message-type init-othello ^structure-type CP ^spelling-single-word init-othello)
(@999717 ^message-type final-othello ^structure-type CP ^spelling-single-word final-othello)
(@999718 ^message-type fail-othello ^structure-type CP ^spelling-single-word fail-othello)
(@999719 ^message-type init-risk ^structure-type CP ^spelling-single-word init-risk)
(@999720 ^message-type final-risk ^structure-type CP ^spelling-single-word final-risk)
(@999721 ^message-type fail-risk ^structure-type CP ^spelling-single-word fail-risk)
(@999722 ^message-type init-frog ^structure-type CP ^spelling-single-word init-frog)
(@999723 ^message-type init-big-frog ^structure-type CP ^spelling-single-word init-big-frog)
(@999724 ^message-type second-frog ^structure-type CP ^spelling-single-word second-frog)
(@999725 ^message-type final-frog ^structure-type CP ^spelling-single-word final-frog)
(@999726 ^message-type final-3mens ^structure-type CP ^spelling-single-word final-3mens)
(@999727 ^message-type final-tictactoe ^structure-type CP ^spelling-single-word final-tictactoe)
(@999728 ^message-type final-tower3 ^structure-type CP ^spelling-single-word final-tower3)
(@999729 ^message-type final-tower4 ^structure-type CP ^spelling-single-word final-tower4)
(@999730 ^message-type final-tower5 ^structure-type CP ^spelling-single-word final-tower5)
(@999731 ^message-type final-8puzzle ^structure-type CP ^spelling-single-word final-8puzzle)
(@999732 ^message-type final-i8puzzle ^structure-type CP ^spelling-single-word final-i8puzzle)
(@999733 ^message-type final-5puzzle ^structure-type CP ^spelling-single-word final-5puzzle)
(@999734 ^message-type final-i5puzzle ^structure-type CP ^spelling-single-word final-i5puzzle)
(@999735 ^message-type final-i15puzzle ^structure-type CP ^spelling-single-word final-i15puzzle)
(@999736 ^message-type init-mac ^structure-type CP ^spelling-single-word init-mac)
(@999737 ^message-type final-mac ^structure-type CP ^spelling-single-word final-mac)
(@999738 ^message-type second-mac ^structure-type CP ^spelling-single-word second-mac)
(@999739 ^message-type third-mac ^structure-type CP ^spelling-single-word third-mac)
(@999740 ^message-type fail-mac ^structure-type CP ^spelling-single-word fail-mac)
(@999741 ^message-type fail-fox ^structure-type CP ^spelling-single-word fail-fox)
(@999742 ^message-type fail-fox2 ^structure-type CP ^spelling-single-word fail-fox2)
(@999743 ^message-type init-fox ^structure-type CP ^spelling-single-word init-fox)
(@999744 ^message-type second-fox ^structure-type CP ^spelling-single-word second-fox)
(@999745 ^message-type final-fox ^structure-type CP ^spelling-single-word final-fox)
(@999746 ^message-type final-mahjong ^structure-type CP ^spelling-single-word final-mahjong)
(@999747 ^message-type init-mahjong ^structure-type CP ^spelling-single-word init-mahjong)
(@999748 ^message-type final-blocksworld ^structure-type CP ^spelling-single-word final-blocksworld)
(@999766 ^message-type final-sudoku4 ^structure-type CP ^spelling-single-word final-sudoku4)
(@999750 ^message-type final-blocksworld2 ^structure-type CP ^spelling-single-word final-blocksworld2)
(@999751 ^message-type init-blocksworld2 ^structure-type CP ^spelling-single-word init-blocksworld2)
(@999752 ^message-type final-peg ^structure-type CP ^spelling-single-word final-peg)
(@999753 ^message-type init-peg ^structure-type CP ^spelling-single-word init-peg)
(@999754 ^message-type init-peg2 ^structure-type CP ^spelling-single-word init-peg2)
(@999755 ^message-type fail-3mens ^structure-type CP ^spelling-single-word fail-3mens)
(@999756 ^message-type fail-tictactoe ^structure-type CP ^spelling-single-word fail-tictactoe)
(@999757 ^message-type final-sokoban ^structure-type CP ^spelling-single-word final-sokoban)
(@999758 ^message-type init-sokoban ^structure-type CP ^spelling-single-word init-sokoban)
(@999759 ^message-type fail-sokoban ^structure-type CP ^spelling-single-word fail-sokoban)
(@999760 ^message-type final-connect-3 ^structure-type CP ^spelling-single-word final-connect-3)
(@999761 ^message-type init-connect-3 ^structure-type CP ^spelling-single-word init-connect-3)
(@999762 ^message-type fail-connect-3 ^structure-type CP ^spelling-single-word fail-connect-3)
(@999763 ^message-type final-connect-4 ^structure-type CP ^spelling-single-word final-connect-4)
(@999764 ^message-type init-connect-4 ^structure-type CP ^spelling-single-word init-connect-4)
(@999765 ^message-type fail-connect-4 ^structure-type CP ^spelling-single-word fail-connect-4)
(@999785 ^handle rosie)
(@999767 ^message-type init-sudoku4 ^structure-type CP ^spelling-single-word init-sudoku4)
(@999768 ^message-type fail-sudoku4 ^structure-type CP ^spelling-single-word fail-sudoku4)
(@999769 ^message-type final-pushmaze ^structure-type CP ^spelling-single-word final-pushmaze)
(@999770 ^message-type init-pushmaze ^structure-type CP ^spelling-single-word init-pushmaze)
(@999771 ^message-type final-6mens ^structure-type CP ^spelling-single-word final-6mens)
(@999772 ^message-type init-6mens ^structure-type CP ^spelling-single-word init-6mens)
(@999773 ^message-type fail-6mens ^structure-type CP ^spelling-single-word fail-6mens)
(@999774 ^message-type final-breakthrough ^structure-type CP ^spelling-single-word final-breakthrough)
(@999775 ^message-type init-breakthrough ^structure-type CP ^spelling-single-word init-breakthrough)
(@999776 ^message-type fail-breakthrough ^structure-type CP ^spelling-single-word fail-breakthrough)
(@999777 ^message-type second-breakthrough ^structure-type CP ^spelling-single-word second-breakthrough)
(@999779 ^message-type second-tower4 ^structure-type CP ^spelling-single-word second-tower4)
(@999786 ^spelling rosie ^referent @999787 ^number singular ^structure-type ROSIE)
(@999780 ^message-type second-tower5 ^structure-type CP ^spelling-single-word second-tower5)
(@999781 ^message-type final-familycross ^structure-type CP ^spelling-single-word final-familycross)
(@999782 ^message-type init-familycross ^structure-type CP ^spelling-single-word init-familycross)
(@999783 ^message-type fail-familycross ^structure-type CP ^spelling-single-word fail-familycross)
(@999784 ^spelling Rosie ^referent @999785 ^number singular ^structure-type ROSIE)
(@1000043 ^before @1000044 @1000045 ^optional true ^structure-type ADJ ^syntactic-structure adjoin ^repeatable true)
(@1000044 ^before @1000045 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@999791 ^property @999792 ^handle me ^item-type object)
(@999790 ^spelling me ^referent @999791 ^number singular ^structure-type PN)
(@999792 ^type person ^handle person1 ^item-type property)
(@999793 ^spelling alice ^referent @404040 ^number singular ^structure-type PN ^converts-to DP)
(@999794 ^spelling bob ^referent @404041 ^number singular ^structure-type PN ^converts-to DP)
(@999795 ^spelling charlie ^referent @404042 ^number singular ^structure-type PN ^converts-to DP)
(@999796 ^number singular ^structure-type *-V-ADJ ^converts-to DP ^prior-word V ^current-word ADJ ^assigners @999797 @999798 @999799 ^construction *-V-ADJ ^prior-word-first true)
(@999798 ^before @999799 ^structure-type N ^syntactic-structure head ^required true)
(@999797 ^before @999798 ^optional true ^structure-type ADJ ^syntactic-structure adjoin ^repeatable true)
(@999799 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999800 ^number singular ^structure-type V-ADJ ^converts-to DP ^prior-word V ^current-word ADJ ^assigners @999801 @999802 @999803 ^construction V-ADJ ^prior-word-first false)
(@999802 ^before @999803 ^structure-type N ^syntactic-structure head ^required true)
(@999801 ^before @999802 ^structure-type ADJ ^syntactic-structure adjoin ^required true ^repeatable true)
(@999803 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999804 ^number singular ^structure-type |N-X| ^converts-to DP ^prior-word V ^current-word N ^assigners @999805 @999806 ^construction *-V-N ^prior-word-first true)
(@999806 ^before @999805 ^structure-type N ^syntactic-structure head ^required true)
(@999805 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999807 ^number singular ^structure-type |N-X| ^converts-to DP ^prior-word V ^current-word N ^assigners @999808 @999809 ^construction |V-N| ^prior-word-first false)
(@999809 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999808 ^before @999809 ^structure-type N ^syntactic-structure head ^required true)
(@999810 ^number singular ^structure-type P-N-X ^converts-to DP ^prior-word P ^current-word N ^assigners @999811 @999812 ^construction |P-N| ^prior-word-first false)
(@999812 ^before @999811 ^structure-type N ^syntactic-structure head ^required true)
(@999811 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999813 ^number singular ^structure-type P-ADJ-X ^converts-to DP ^prior-word P ^current-word ADJ ^assigners @999814 @999815 @999816 ^construction P-ADJ ^prior-word-first false)
(@999815 ^before @999816 ^structure-type N ^syntactic-structure head ^required true)
(@999814 ^before @999815 ^structure-type ADJ ^syntactic-structure adjoin ^repeatable true)
(@999816 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999817 ^spelling is-that ^structure-type RPN ^converts-to RC ^prior-word is ^current-word that ^assigners @999818 ^attachment immediate ^consumes-prior-word false)
(@999818 ^structure-type CP ^relative-position after ^syntactic-structure head ^required true ^delay-merge true ^semantic-structure *copy*)
(@999819 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word D ^assigners @999820 @999821 @999822 ^construction *-U-D ^prior-word-first true)
(@999820 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999822 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999821 ^optional true ^structure-type PP ^syntactic-structure complement2 ^semantic-structure arg2)
(@999823 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word P ^assigners @999824 @999825 ^construction *-U-P ^prior-word-first true)
(@999824 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999825 ^optional true ^structure-type PP ^syntactic-structure complement2 ^semantic-structure arg2)
(@999826 ^message-type unknown-word ^structure-type S ^prior-word U ^current-word T ^assigners @999827 @999828 ^construction *-U-T ^prior-word-first true)
(@999827 ^structure-type T ^syntactic-structure terminator ^required true)
(@999828 ^structure-type U ^syntactic-structure head ^required true)
(@999829 ^message-type new-verb ^structure-type UV ^converts-to VP ^prior-word U ^current-word PN ^assigners @999830 @999831 ^construction *-U-PN ^prior-word-first true)
(@999830 ^structure-type PN ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999833 ^before @999834 ^structure-type U ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal ^predicted-structure-type ADJ N)
(@999836 ^optional true ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999835 ^semantic-structure property ^referent-type literal)
(@999831 ^structure-type U ^syntactic-structure action ^required true ^semantic-structure action ^referent-type literal ^predicted-structure-type V)
(@999832 ^message-type adjective-definition ^structure-type CP ^prior-word U ^current-word IS-V ^assigners @999833 @999834 @999835 @999836 ^construction *-U-is-DP ^prior-word-first true)
(@999834 ^before @999835 ^after @999833 ^structure-type IS-V ^syntactic-structure predicate ^required true ^lexical-item-spelling is)
(@999835 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999836 ^semantic-structure property ^referent-type literal)
(@999837 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word DP ^current-word IS-V ^assigners @999838 @999839 @999840 @999841 @999842 @999843 @999844 @999845 @999846 @999847 @999848 @999849 @999850 @999851 ^construction *-DP-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true)
(@999838 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999839 ^optional true ^structure-type V-AUX ^relative-position after ^syntactic-structure nil ^semantic-structure modifier)
(@999840 ^before @999841 ^after @999838 ^optional true ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999841 ^before @999849 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999842 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999843 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999844 @999845 @999846 @999847 @999848 @999849 @999851 ^semantic-structure predicate ^referent-type literal)
(@999844 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999845 @999846 @999847 @999848 @999849 @999851 ^semantic-structure predicate ^referent-type literal)
(@999845 ^optional true ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999844 @999846 @999847 @999848 @999849 @999851 ^semantic-structure predicate ^referent-type literal)
(@999846 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999843 @999844 @999845 @999847 @999848 @999849 @999851 ^semantic-structure relation)
(@999847 ^optional true ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999844 @999845 @999846 @999848 @999849 @999851 ^semantic-structure predicate ^referent-type literal ^predicted-structure-type ADJ)
(@999849 ^optional true ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999844 @999845 @999846 @999847 @999848 @999851 ^semantic-structure *embed* ^embed-structure subclause)
(@999848 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999844 @999845 @999846 @999847 @999849 @999851 ^semantic-structure predicate)
(@999850 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^repeatable true)
(@999851 ^optional true ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999843 @999844 @999845 @999846 @999848 @999849 ^semantic-structure predicate ^referent-type literal ^strip-assigners true)
(@999852 ^structure-type PN ^relative-position before ^syntactic-structure head ^required true ^exclusive @999852 ^semantic-structure arg1)
(@999853 ^optional true ^structure-type V-AUX ^relative-position after ^syntactic-structure nil ^semantic-structure modifier)
(@999854 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word PN ^current-word IS-V ^assigners @999852 @999853 @999855 @999856 @999857 @999858 @999859 @999860 @999861 @999862 @999863 @999864 @999865 @999866 ^construction *-PN-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true)
(@999855 ^before @999856 ^after @999852 ^optional true ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999856 ^before @999864 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999857 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999858 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999859 @999860 @999861 @999862 @999863 @999864 @999866 ^semantic-structure predicate ^referent-type literal)
(@999859 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999860 @999861 @999862 @999863 @999864 @999866 ^semantic-structure predicate ^referent-type literal)
(@999860 ^optional true ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999859 @999861 @999862 @999863 @999864 @999866 ^semantic-structure predicate ^referent-type literal)
(@999861 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999858 @999859 @999860 @999862 @999863 @999864 @999866 ^semantic-structure relation)
(@999862 ^optional true ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999859 @999860 @999861 @999863 @999864 @999866 ^semantic-structure predicate ^referent-type literal ^predicted-structure-type ADJ)
(@999864 ^optional true ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999859 @999860 @999861 @999862 @999863 @999866 ^semantic-structure *embed* ^embed-structure subclause)
(@999863 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999859 @999860 @999861 @999862 @999864 @999866 ^semantic-structure predicate)
(@999865 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^repeatable true)
(@999866 ^optional true ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999858 @999859 @999860 @999861 @999863 @999864 ^semantic-structure predicate ^referent-type literal ^strip-assigners true)
(@999867 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word CONJP ^current-word IS-V ^assigners @999868 @999869 @999870 @999871 @999872 @999873 @999874 @999875 @999876 @999877 @999878 @999879 @999880 ^construction CONJP-is-ADJ/DP/PP/CONJP/RC ^prior-word-first true false)
(@999868 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999869 ^before @999870 ^after @999868 ^optional true ^structure-type CONJP ^relative-position before ^syntactic-structure head ^copy-structure arg1 ^semantic-structure *copy* ^repeatable true)
(@999870 ^before @999878 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999871 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999872 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999873 @999874 @999875 @999876 @999877 @999878 @999880 ^semantic-structure predicate ^referent-type literal)
(@999873 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999874 @999875 @999876 @999877 @999878 @999880 ^semantic-structure predicate ^referent-type literal)
(@999874 ^optional true ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999873 @999875 @999876 @999877 @999878 @999880 ^semantic-structure predicate ^referent-type literal)
(@999875 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999872 @999873 @999874 @999876 @999877 @999878 @999880 ^semantic-structure relation)
(@999876 ^optional true ^structure-type U ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999873 @999874 @999875 @999877 @999878 @999880 ^semantic-structure predicate ^referent-type literal ^predicted-structure-type ADJ)
(@999877 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999873 @999874 @999875 @999876 @999878 @999880 ^semantic-structure predicate)
(@999878 ^optional true ^structure-type RC ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999873 @999874 @999875 @999876 @999877 @999880 ^semantic-structure *embed* ^embed-structure subclause)
(@999879 ^optional true ^structure-type CONJP ^syntactic-structure predicate ^copy-structure predicate ^semantic-structure *copy* ^repeatable true)
(@999880 ^optional true ^structure-type V ^relative-position after ^syntactic-structure predicate ^exclusive @999872 @999873 @999874 @999875 @999877 @999878 ^semantic-structure predicate ^referent-type literal ^strip-assigners true)
(@999881 ^structure-type DP ^relative-position before ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999882 ^message-type object-description ^referent @101148 ^structure-type C ^converts-to CP ^prior-word DP ^current-word IS-V ^assigners @999881 @999883 @999884 @999885 @999886 @999887 @999888 @999889 ^construction DP-is-ADJ/DP/PP/CONJP/RP ^prior-word-first false ^semantic-structure action)
(@999884 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999883 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@999885 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999886 @999887 @999888 @999889 ^semantic-structure predicate ^referent-type literal)
(@999886 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999885 @999887 @999888 ^semantic-structure predicate ^referent-type literal)
(@999887 ^optional true ^structure-type N ^relative-position after ^syntactic-structure predicate ^exclusive @999885 @999886 @999888 @999889 ^semantic-structure predicate ^referent-type literal)
(@999888 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999885 @999886 @999887 @999889 ^semantic-structure relation)
(@999889 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure complement ^exclusive @999885 @999886 @999887 @999888 ^semantic-structure relation ^referent-type literal)
(@999890 ^structure-type C-ADJ-P ^relative-position before ^syntactic-structure head ^required true ^semantic-structure *embed* ^embed-structure arg1)
(@999891 ^referent @101148 ^structure-type C ^converts-to CP ^prior-word C-ADJ-P ^current-word IS-V ^assigners @999890 @999892 @999893 @999894 @999895 ^construction |C-ADJ-P IS /DP/PP/C-ADJP-CONJP/RP| ^prior-word-first false ^semantic-structure action)
(@999892 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999893 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999894 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @999895 ^semantic-structure predicate ^referent-type literal)
(@999895 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement ^exclusive @999894 ^semantic-structure relation)
(@999896 ^before @999897 ^structure-type ADJ ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999897 ^before @999899 ^after @999896 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999898 ^message-type adjective-definition ^structure-type CP ^prior-word ADJ ^current-word IS-V ^assigners @999896 @999897 @999899 ^construction *-ADJ-is-DP ^prior-word-first true)
(@999899 ^structure-type DP ^relative-position after ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999900 ^before @999901 ^structure-type N ^syntactic-structure head ^required true ^semantic-structure arg1 ^referent-type literal)
(@999901 ^before @999903 ^after @999900 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999902 ^message-type adjective-definition ^structure-type CP ^prior-word N ^current-word IS-V ^assigners @999900 @999901 @999903 ^construction *-N-is-DP ^prior-word-first true)
(@999903 ^after @999901 ^structure-type DP ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999904 ^message-type what-is-question ^structure-type S ^prior-word what ^current-word IS-V ^assigners @999905 @999906 @999907 @999908 ^construction *-What-is-PP/DP-QT ^prior-word-first true)
(@999905 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^exclusive @999906 ^semantic-structure relation)
(@999906 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999905 ^semantic-structure arg1)
(@999907 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999908 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999909 ^before @999914 ^structure-type IS-V ^syntactic-structure nil ^required true ^semantic-structure nil)
(@999910 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure head ^exclusive @999911 ^semantic-structure arg1)
(@999911 ^optional true ^specifier definite ^structure-type THIS ^relative-position after ^syntactic-structure head ^exclusive @999910 ^semantic-structure arg1 ^demonstrative true)
(@999912 ^before @999909 @999914 ^structure-type N ^syntactic-structure predicate ^required true ^semantic-structure property ^referent-type literal)
(@999913 ^message-type predicate-question ^structure-type S ^prior-word what ^current-word N ^assigners @999909 @999910 @999911 @999912 @999914 ^construction *-What-N-is-DP-QT ^prior-word-first true)
(@999914 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999915 ^message-type where-is-question ^structure-type S ^prior-word where ^current-word IS-V ^assigners @999916 @999917 @999918 ^construction *-Where-is-DP-QT ^prior-word-first true)
(@999916 ^before @999917 @999918 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure where-question)
(@999917 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@999918 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999919 ^message-type object-description ^structure-type CP ^prior-word there ^current-word IS-V ^assigners @999920 @999921 @999922 @999923 @999924 ^construction *-There-is-DP/ADJ/PP ^prior-word-first true)
(@999920 ^before @999922 @999923 @999924 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999921 ^structure-type ADV ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999922 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @999923 @999924 ^semantic-structure predicate)
(@999923 ^optional true ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999922 @999924 ^semantic-structure predicate ^referent-type literal)
(@999924 ^optional true ^syntactic-structure complement ^exclusive @999922 @999923 ^semantic-structure arg2 ^structrure P)
(@999925 ^message-type object-description ^structure-type C ^converts-to CP ^prior-word there ^current-word IS-V ^assigners @999926 @999927 @999928 @999929 @999930 @999931 ^construction There-is-ADJ/DP/PP ^prior-word-first false)
(@999926 ^before @999927 @999928 @999929 @999930 @999931 ^structure-type IS-V ^syntactic-structure predicate ^required true ^semantic-structure action)
(@999927 ^structure-type ADV ^syntactic-structure adverb-modifier ^semantic-structure modifier ^referent-type literal)
(@999928 ^optional true ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999929 @999930 @999931 ^semantic-structure predicate ^referent-type literal)
(@999929 ^optional true ^structure-type DP ^syntactic-structure predicate ^exclusive @999928 @999930 @999931 ^semantic-structure predicate)
(@999930 ^optional true ^structure-type PP ^syntactic-structure complement ^exclusive @999928 @999929 @999931 ^semantic-structure arg2)
(@999931 ^optional true ^structure-type C-ADJ-P ^syntactic-structure predicate ^exclusive @999928 @999929 @999930 ^semantic-structure predicate)
(@999932 ^message-type object-question ^structure-type S ^prior-word * ^current-word is ^assigners @999933 @999934 @999935 @999936 @999937 ^construction *-Is-DP-DP/ADJ/PP?)
(@999934 ^optional true ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999933 @999936 ^semantic-structure predicate ^referent-type literal)
(@999933 ^optional true ^structure-type DP ^syntactic-structure predicate ^exclusive @999934 @999936 ^semantic-structure predicate ^referent-type literal)
(@999935 ^before @999933 @999934 @999936 ^specifier definite ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1 ^demonstrative true)
(@999936 ^optional true ^structure-type PP ^syntactic-structure complement ^exclusive @999933 @999934 ^semantic-structure relation)
(@999937 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999938 ^message-type object-question ^structure-type S ^prior-word IS-V ^current-word D ^assigners @999939 @999940 @999941 @999942 @999943 @999944 ^construction *-Is-DP-DP/ADJ/PP? ^prior-word-first true)
(@999940 ^before @999941 @999942 @999943 ^specifier definite ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure arg1 ^demonstrative true)
(@999939 ^before @999940 @999941 @999942 @999945 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@999941 ^optional true ^structure-type DP ^syntactic-structure predicate ^exclusive @999942 @999943 ^semantic-structure predicate ^referent-type literal)
(@999942 ^after @999940 ^optional true ^structure-type ADJ ^syntactic-structure predicate ^exclusive @999941 @999943 ^semantic-structure predicate ^referent-type literal)
(@999943 ^optional true ^structure-type PP ^syntactic-structure complement ^exclusive @999941 @999942 ^semantic-structure relation)
(@999944 ^structure-type QT ^syntactic-structure terminator ^required true)
(@999946 ^spelling |0| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011200)
(@999947 ^spelling |1| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011201)
(@999948 ^spelling |2| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011202)
(@999949 ^spelling |3| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011203)
(@999950 ^spelling |4| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011204)
(@999951 ^spelling |5| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011205)
(@999952 ^spelling |6| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011206)
(@999953 ^spelling |7| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011207)
(@999954 ^spelling |8| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011208)
(@999955 ^spelling |9| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011209)
(@999956 ^spelling |10| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011210)
(@999957 ^spelling |11| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011211)
(@999958 ^spelling |12| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011212)
(@999959 ^spelling |13| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011213)
(@999960 ^spelling |14| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011214)
(@999961 ^spelling |15| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011215)
(@999962 ^spelling |16| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011216)
(@999963 ^spelling |17| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011217)
(@999964 ^spelling |18| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011218)
(@999965 ^spelling |19| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011219)
(@999966 ^spelling |20| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011220)
(@999967 ^spelling |30| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011230)
(@999968 ^spelling |31| ^number singular ^specifier indefinite ^structure-type DP ^constraint @4011231)
(@999969 ^before @999970 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^repeatable true)
(@999970 ^before @999971 ^optional true ^structure-type N ^relative-position after ^syntactic-structure head)
(@999972 ^spelling no ^number plural ^super-type @6010000 ^constraint @4011200)
(@999971 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@999973 ^spelling zero ^number plural ^super-type @6010000 ^constraint @4011200)
(@999974 ^spelling one ^number singular ^super-type @6010000 ^constraint @4011201)
(@999975 ^spelling two ^number plural ^super-type @6010000 ^constraint @4011202)
(@999976 ^spelling three ^number singular ^super-type @6010000 ^constraint @4011203)
(@999977 ^spelling four ^number singular ^super-type @6010000 ^constraint @4011204)
(@999978 ^spelling five ^number singular ^super-type @6010000 ^constraint @4011205)
(@999979 ^spelling six ^number singular ^super-type @6010000 ^constraint @4011206)
(@999980 ^spelling seven ^number singular ^super-type @6010000 ^constraint @4011207)
(@999981 ^spelling eight ^number singular ^super-type @6010000 ^constraint @4011208)
(@999982 ^spelling nine ^number singular ^super-type @6010000 ^constraint @4011209)
(@999983 ^spelling ten ^number singular ^super-type @6010000 ^constraint @4011210)
(@999984 ^spelling eleven ^number singular ^super-type @6010000 ^constraint @4011211)
(@999985 ^spelling twelve ^number plural ^super-type @6010000 ^constraint @4011212)
(@999986 ^spelling thirteen ^number singular ^super-type @6010000 ^constraint @4011213)
(@999987 ^spelling fourteen ^number singular ^super-type @6010000 ^constraint @4011214)
(@999988 ^spelling fifteen ^number singular ^super-type @6010000 ^constraint @4011215)
(@999989 ^spelling sixteen ^number singular ^super-type @6010000 ^constraint @4011216)
(@999990 ^spelling seventeen ^number singular ^super-type @6010000 ^constraint @4011217)
(@999991 ^spelling eighteen ^number singular ^super-type @6010000 ^constraint @4011218)
(@999992 ^spelling nineteen ^number singular ^super-type @6010000 ^constraint @4011219)
(@999993 ^spelling twenty ^number singular ^super-type @6010000 ^constraint @4011220)
(@999994 ^spelling thirty ^number singular ^super-type @6010000 ^constraint @4011230)
(@999995 ^spelling thirty-one ^number singular ^super-type @6010000 ^constraint @4011231)
(@999996 ^spelling D-zero ^referent @4011200 ^structure-type ADJ ^prior-word D ^current-word zero)
(@999997 ^spelling D-one ^referent @4011201 ^structure-type ADJ ^prior-word D ^current-word one)
(@999998 ^spelling D-two ^referent @4011202 ^structure-type ADJ ^prior-word D ^current-word two)
(@999999 ^spelling D-three ^referent @4011203 ^structure-type ADJ ^prior-word D ^current-word three)
(@1000000 ^spelling D-four ^referent @4011204 ^structure-type ADJ ^prior-word D ^current-word four)
(@1000001 ^spelling D-five ^referent @4011205 ^structure-type ADJ ^prior-word D ^current-word five)
(@1000002 ^spelling D-six ^referent @4011206 ^structure-type ADJ ^prior-word D ^current-word six)
(@1000003 ^spelling D-seven ^referent @4011207 ^structure-type ADJ ^prior-word D ^current-word seven)
(@1000004 ^spelling D-eight ^referent @4011208 ^structure-type ADJ ^prior-word D ^current-word eight)
(@1000005 ^spelling D-nine ^referent @4011209 ^structure-type ADJ ^prior-word D ^current-word nine)
(@1000006 ^spelling D-ten ^referent @4011210 ^structure-type ADJ ^prior-word D ^current-word ten)
(@1000007 ^spelling D-eleven ^referent @4011211 ^structure-type ADJ ^prior-word D ^current-word eleven)
(@1000008 ^spelling D-twelve ^referent @4011212 ^structure-type ADJ ^prior-word D ^current-word twelve)
(@1000009 ^spelling D-thirteen ^referent @4011213 ^structure-type ADJ ^prior-word D ^current-word thirteen)
(@1000010 ^spelling D-fourteen ^referent @4011214 ^structure-type ADJ ^prior-word D ^current-word fourteen)
(@1000011 ^spelling D-five ^referent @4011215 ^structure-type ADJ ^prior-word D ^current-word five)
(@1000012 ^spelling D-sixteen ^referent @4011216 ^structure-type ADJ ^prior-word D ^current-word sixteen)
(@1000013 ^spelling D-seventeen ^referent @4011217 ^structure-type ADJ ^prior-word D ^current-word seventeen)
(@1000014 ^spelling D-eighteen ^referent @4011218 ^structure-type ADJ ^prior-word D ^current-word eighteen)
(@1000015 ^spelling D-nineteen ^referent @4011219 ^structure-type ADJ ^prior-word D ^current-word nineteen)
(@1000016 ^spelling D-twenty ^referent @4011210 ^structure-type ADJ ^prior-word D ^current-word twenty)
(@1000017 ^spelling zeroth ^number plural ^super-type @6010000 ^constraint @4011100)
(@1000018 ^spelling first ^structure-type ADJ ^attachment immediate ^constraint @4011101)
(@1000019 ^spelling second ^structure-type ADJ ^attachment immediate ^constraint @4011102)
(@1000020 ^spelling third ^number singular ^super-type @6010000 ^constraint @4011103)
(@1000021 ^spelling fourth ^number singular ^super-type @6010000 ^constraint @4011104)
(@1000022 ^spelling fifth ^number singular ^super-type @6010000 ^constraint @4011105)
(@1000023 ^spelling sixth ^number singular ^super-type @6010000 ^constraint @4011106)
(@1000024 ^spelling seventh ^number singular ^super-type @6010000 ^constraint @4011107)
(@1000025 ^spelling eighth ^number singular ^super-type @6010000 ^constraint @4011108)
(@1000026 ^spelling ninth ^number singular ^super-type @6010000 ^constraint @4011109)
(@1000027 ^handle all)
(@1000028 ^spelling all ^referent @1000027 ^number plural ^specifier universal ^structure-type QUANT ^super-converts-to CP)
(@1000069 ^spelling they ^number plural ^specifier it ^structure-type DP ^super-converts-to CP)
(@1000071 ^spelling anyone ^referent @1000070 ^number singular ^specifier indefinite ^structure-type DP ^super-converts-to CP)
(@1000029 ^structure-type QUANT ^syntactic-structure quantifier ^required true)
(@1000030 ^spelling quant-of ^number plural ^specifier universal ^structure-type QUANT ^prior-word QUANT ^current-word of ^assigners @1000029 ^consumes-prior-word true ^super-converts-to CP)
(@1000031 ^optional true ^structure-type QUANT ^syntactic-structure quantifier)
(@1000032 ^before @1000033 @1000034 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^repeatable true)
(@1000033 ^before @1000034 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@1000035 ^number plural ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word the ^assigners @1000031 @1000032 @1000033 @1000034 ^construction quant-the ^prior-word-first true false ^consumes-prior-word true ^super-converts-to CP)
(@1000034 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@1000037 ^before @1000039 @1000040 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^repeatable true)
(@1000036 ^optional true ^structure-type QUANT ^syntactic-structure quantifier)
(@1000038 ^number plural ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word your ^assigners @1000036 @1000037 @1000039 @1000040 ^construction quant-your ^prior-word-first true false ^consumes-prior-word true)
(@1000039 ^before @1000040 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@1000041 ^number plural ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word ADJ ^assigners @1000042 @1000043 @1000044 @1000045 ^construction quant-ADJ ^prior-word-first true false)
(@1000040 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@1000042 ^optional true ^structure-type QUANT ^syntactic-structure quantifier)
(@1000085 ^spelling lefty ^referent @1000084 ^structure-type ADJ)
(@1000086 ^structure-type RC ^converts-to RCP ^prior-word D ^current-word that ^assigners @1000087 @1000088 @1000089 @1000090 @1000091 @1000092 @1000093 @1000094 ^construction that-is-ADJ/DP/PP/VP//C-ADJP-CONJP/RP/CP ^prior-word-first false ^attachment immediate)
(@1000046 ^number plural ^specifier universal ^structure-type D ^converts-to DP ^prior-word QUANT ^current-word N ^assigners @1000047 @1000048 @1000049 ^construction quant-N ^prior-word-first true false)
(@1000045 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@1000047 ^optional true ^structure-type QUANT ^syntactic-structure quantifier)
(@1000048 ^before @1000049 ^structure-type N ^syntactic-structure head ^required true)
(@1000049 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@1000050 ^spelling some ^referent @1000051 ^number plural ^specifier indefinite ^structure-type QUANT ^super-converts-to DP)
(@1000052 ^handle each ^spelling each ^referent @1000052 ^number singular ^specifier definite ^structure-type QUANT ^super-converts-to DP)
(@1000051 ^handle some)
(@1000054 ^spelling none ^referent @1000053 ^number plural ^specifier indefinite ^structure-type QUANT)
(@1000053 ^handle none)
(@1000055 ^spelling many ^referent @1000056 ^number plural ^specifier indefinite ^structure-type QUANT ^super-converts-to DP)
(@1000057 ^spelling few ^referent @1000058 ^number plural ^specifier indefinite ^structure-type QUANT ^super-converts-to DP)
(@1000056 ^handle many)
(@1000059 ^spelling this ^number singular ^specifier definite ^structure-type DP ^demonstrative true)
(@1000058 ^handle few)
(@1000060 ^spelling that ^number singular ^specifier definite ^structure-type DP ^demonstrative true)
(@1000061 ^number singular ^structure-type N ^prior-word D ^current-word one ^construction D-one ^demonstrative true)
(@1000062 ^number singular ^structure-type N ^prior-word ADJ ^current-word one ^construction adj-one ^demonstrative true)
(@1000063 ^number singular ^structure-type DP ^prior-word this ^current-word one ^construction adj-one ^demonstrative true)
(@1000064 ^spelling |;| ^structure-type SEMICOLON)
(@1000065 ^spelling it ^number singular ^specifier it ^structure-type DP ^super-converts-to CP)
(@1000067 ^property @1000068 ^handle rosie)
(@1000066 ^spelling you ^referent @1000067 ^number singular ^specifier personal ^structure-type DP)
(@1000068 ^type visual ^handle handle)
(@1000088 ^optional true ^structure-type ADV ^relative-position after ^syntactic-structure predicate ^referent-type literal ^repeatable true)
(@1000089 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure predicate ^exclusive @1000090 @1000091 @1000092 @1000093 ^referent-type literal)
(@1000070 ^property @1000068 ^handle anyone)
(@1000073 ^spelling someone ^referent @1000072 ^number singular ^specifier indefinite ^structure-type DP ^super-converts-to CP)
(@1000072 ^property @1000068 ^handle anyone)
(@1000076 ^relation @501003 ^spelling left ^structure-type P ^converts-to PP ^semantic-entity-type relation)
(@1000074 ^structure-type CP ^prior-word you ^current-word VP ^assigners @1000075 ^construction You-VP ^prior-word-first true false)
(@1000075 ^structure-type VP ^syntactic-structure predicate ^required true ^semantic-structure *copy*)
(@1000079 ^relation @501003 ^spelling left-noun ^number singular ^structure-type N ^prior-word the ^current-word left ^semantic-structure relation ^consumes-prior-word false ^semantic-entity-type relation)
(@1000077 ^relation @501002 ^spelling right ^structure-type P ^converts-to PP ^semantic-entity-type relation)
(@1000078 ^relation @501002 ^spelling right-noun ^number singular ^structure-type N ^prior-word the ^current-word right ^semantic-structure relation ^consumes-prior-word false ^semantic-entity-type relation)
(@1000080 ^referent @409002 ^structure-type ADJ)
(@1000081 ^referent @409001 ^structure-type ADJ)
(@1000082 ^spelling righty ^referent @1000083 ^structure-type ADJ)
(@1000117 ^spelling might ^referent @1000116 ^structure-type V-AUX)
(@1000087 ^structure-type IS-V ^syntactic-structure predicate ^required true)
(@1000118 ^handle must)
(@1000119 ^spelling must ^referent @1000118 ^structure-type V-AUX)
(@1000090 ^optional true ^structure-type DP ^relative-position after ^syntactic-structure predicate ^exclusive @1000089 @1000091 @1000092 @1000093 ^referent-type literal)
(@1000091 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure predicate ^exclusive @1000089 @1000090 @1000092 @1000093 ^attachment immediately-follow)
(@1000092 ^optional true ^structure-type C-ADJ-P ^relative-position after ^syntactic-structure predicate ^exclusive @1000089 @1000090 @1000091 @1000093)
(@1000093 ^after @1000089 @1000090 @1000091 @1000092 ^optional true ^structure-type VP ^relative-position after ^syntactic-structure complement ^exclusive @1000089 @1000090 @1000091 @1000092)
(@1000094 ^after @1000089 @1000090 @1000091 @1000092 @1000095 ^optional true ^structure-type CONJ-C-ADJ-P ^relative-position after ^syntactic-structure conj-predicate)
(@1000096 ^spelling then ^structure-type THEN)
(@1000097 ^message-type conditional ^spelling if ^structure-type C ^converts-to CP ^assigners @1000098 @1000099 @1000100 @1000101 ^current-word-first true)
(@1000099 ^before @1000100 @1000101 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^exclusive @1000098 ^delay-merge true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000098 ^before @1000100 @1000101 ^structure-type VP ^relative-position after ^syntactic-structure nil ^required true ^exclusive @1000099 ^delay-merge true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000100 ^before @1000101 ^structure-type THEN ^syntactic-structure nil ^required true)
(@1000101 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000102 ^before @1000104 @1000105 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^delay-merge true ^semantic-structure *embed* ^embed-structure when-subclause)
(@1000103 ^message-type conditional ^spelling when ^structure-type C ^converts-to CP ^assigners @1000102 @1000104 @1000105 ^current-word-first true)
(@1000105 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000104 ^before @1000105 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@1000106 ^message-type conditional ^spelling while ^structure-type C ^converts-to CP ^assigners @1000107 @1000108 @1000109 ^current-word-first true)
(@1000108 ^before @1000109 ^structure-type SEMICOLON ^syntactic-structure nil ^required true)
(@1000107 ^before @1000108 @1000109 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^delay-merge true ^semantic-structure *embed* ^embed-structure while-subclause)
(@1000109 ^structure-type CP ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure then-subclause)
(@1000110 ^spelling V-if ^structure-type IF ^converts-to IF-CLAUSE ^prior-word V ^current-word if whether ^assigners @1000111 ^hypothetical true ^current-word-first false)
(@1000112 ^handle can)
(@1000111 ^structure-type CP ^relative-position after ^syntactic-structure nil ^required true ^semantic-structure *embed* ^embed-structure if-subclause)
(@1000113 ^spelling can ^referent @1000112 ^structure-type V-AUX)
(@1000114 ^spelling may ^referent @1000115 ^structure-type V-AUX)
(@1000115 ^handle may)
(@1000116 ^handle might)
(@1000126 ^spelling would ^referent @1000127 ^structure-type V-AUX)
(@1000129 ^spelling usually ^referent @1000128 ^structure-type V-AUX)
(@1000120 ^spelling could ^referent @1000121 ^structure-type V-AUX)
(@1000122 ^spelling should ^referent @1000123 ^structure-type V-AUX)
(@1000121 ^handle could)
(@1000123 ^handle should)
(@1000124 ^handle will)
(@1000125 ^spelling will ^referent @1000124 ^structure-type V-AUX)
(@1000130 ^optional true ^structure-type ADV ^relative-position before ^syntactic-structure adverb-modifier ^semantic-structure modifier)
(@1000127 ^handle would)
(@1000128 ^handle usually)
(@1000146 ^spelling and ^structure-type CP-CONJ ^alternative-structure CONJ ^semantic-structure conjunction)
(@1000151 ^spelling but ^structure-type CP-CONJ ^alternative-structure CONJ ^semantic-structure conjunction)
(@1000131 ^structure-type DP ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000132 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement2 ^semantic-structure arg2)
(@1000133 ^spelling playing ^referent @101120 ^super-type @20999)
(@1000134 ^spelling placing ^referent @101120 ^super-type @20999)
(@1000135 ^spelling moving ^referent @101008 ^super-type @20999)
(@1000136 ^spelling more ^referent @501025 ^structure-type C-ADJ ^converts-to C-ADJ-P ^assigners @1000137 @1000138 @1000139 ^semantic-structure relation)
(@1000139 ^before @1000138 ^structure-type THAN ^syntactic-structure nil ^required true)
(@1000137 ^before @1000138 @1000139 ^structure-type N ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000138 ^structure-type N ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@1000140 ^spelling fewer ^referent @501025 ^structure-type C-ADJ ^converts-to C-ADJ-P ^assigners @1000141 @1000142 @1000143 ^semantic-structure relation)
(@1000143 ^structure-type N ^relative-position after ^syntactic-structure complement ^required true ^semantic-structure arg2)
(@1000141 ^before @1000142 @1000143 ^structure-type N ^relative-position after ^syntactic-structure head ^required true ^semantic-structure arg1)
(@1000142 ^before @1000143 ^structure-type THAN ^syntactic-structure nil ^required true)
(@1000145 ^spelling and ^structure-type CONJ ^alternative-structure CP-CONJ ^semantic-structure conjunction ^super-converts-to CONJP ^merge-delay true)
(@1000144 ^spelling than ^structure-type THAN)
(@1000147 ^spelling andx ^structure-type CONJ ^semantic-structure conjunction ^super-converts-to CONJP CONJ-C-ADJ-P ^merge-delay true)
(@1000148 ^spelling andc ^structure-type CP-CONJ ^semantic-structure conjunction)
(@1000149 ^spelling plus ^structure-type CP-CONJ ^semantic-structure conjunction)
(@1000150 ^spelling but ^structure-type CONJ ^alternative-structure CP-CONJ ^semantic-structure conjunction ^super-converts-to CONJP ^merge-delay true)
(@1000152 ^spelling |, and| ^structure-type CONJ ^prior-word |,| ^current-word and ^semantic-structure conjunction ^converts-to-any true ^merge-delay true)
(@1000153 ^spelling |,| ^structure-type CONJ ^semantic-structure conjunction ^converts-to-any true ^merge-delay true)
(@1000154 ^spelling CONJ-ADJ ^structure-type CONJ-ADJ ^converts-to CONJP ^prior-word CONJ ^current-word ADJ ^assigners @1000155 @1000156 ^prior-word-first true false)
(@1000155 ^before @1000156 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000158 ^before @1000159 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000156 ^structure-type ADJ ^syntactic-structure predicate ^required true ^semantic-structure predicate)
(@1000161 ^before @1000162 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000157 ^spelling CONJ-N ^structure-type CONJ-N ^converts-to CONJP ^prior-word CONJ ^current-word N ^assigners @1000158 @1000159 ^prior-word-first true false)
(@1000159 ^structure-type N ^syntactic-structure head ^required true ^semantic-structure predicate)
(@1000167 ^optional true ^structure-type CP ^syntactic-structure sentence ^exclusive @1000168 ^semantic-structure *embed* ^embed-structure subclause)
(@1000160 ^spelling CONJ-DP ^structure-type CONJ-DP ^converts-to CONJP ^prior-word CONJ ^current-word D ^assigners @1000161 @1000162 ^prior-word-first true false)
(@1000162 ^structure-type DP ^syntactic-structure head ^required true ^semantic-structure predicate)
(@1000163 ^spelling CONJ-PP ^structure-type CONJ-PP ^converts-to CONJP ^prior-word CONJ ^current-word P ^assigners @1000164 @1000165 ^prior-word-first true false)
(@1000164 ^before @1000165 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000165 ^structure-type PP ^syntactic-structure complement ^required true ^semantic-structure predicate)
(@1000166 ^structure-type C ^converts-to CP ^prior-word CP ^current-word CP-CONJ ^assigners @1000167 @1000168 @1000169 @1000170 ^construction CP-CONJ-CP ^prior-word-first true false)
(@1000168 ^optional true ^structure-type VP ^syntactic-structure sentence ^exclusive @1000167 ^semantic-structure *embed* ^embed-structure subclause)
(@1000169 ^before @1000167 @1000168 @1000170 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000170 ^before @1000167 @1000168 ^structure-type CP-CONJ ^syntactic-structure CONJ ^required true)
(@1000171 ^structure-type C ^converts-to CP ^prior-word CP ^current-word CONJ ^assigners @1000172 @1000173 @1000174 ^construction CP-AND-CP ^prior-word-first true false)
(@1000172 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000173 ^before @1000172 @1000174 ^structure-type CP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000174 ^before @1000172 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000175 ^structure-type C ^converts-to CP ^prior-word VP ^current-word CP-CONJ ^assigners @1000176 @1000177 @1000178 @1000179 ^construction VP-CONJ-CP ^prior-word-first true false)
(@1000176 ^optional true ^structure-type CP ^syntactic-structure sentence ^exclusive @1000177 ^semantic-structure *embed* ^embed-structure subclause)
(@1000177 ^optional true ^structure-type VP ^syntactic-structure sentence ^exclusive @1000176 ^semantic-structure *embed* ^embed-structure subclause)
(@1000178 ^before @1000176 @1000177 @1000179 ^structure-type VP ^syntactic-structure sentence ^required true ^semantic-structure *embed* ^embed-structure subclause)
(@1000179 ^before @1000176 @1000177 ^structure-type CP-CONJ ^syntactic-structure CONJ ^required true)
(@1000180 ^spelling CONJ-C-ADJ-P ^structure-type CONJ-C-ADJ ^converts-to CONJ-C-ADJ-P ^prior-word CONJ ^current-word C-ADJ ^assigners @1000181 @1000182 ^prior-word-first true false)
(@1000181 ^before @1000182 ^structure-type CONJ ^syntactic-structure CONJ ^required true)
(@1000182 ^structure-type C-ADJ-P ^syntactic-structure head ^required true)
(@1000183 ^before @1000184 @1000185 @1000186 ^optional true ^structure-type ADJ ^relative-position after ^syntactic-structure adjoin ^repeatable true)
(@1000184 ^before @1000185 @1000186 ^structure-type N ^relative-position after ^syntactic-structure head ^required true)
(@1000187 ^spelling |alice's| ^referent @4016001 ^number singular ^specifier definite ^super-type @991050)
(@1000185 ^before @1000186 ^optional true ^structure-type PP ^relative-position after ^syntactic-structure complement)
(@1000186 ^optional true ^structure-type RCP ^relative-position after ^syntactic-structure complement)
(@1000188 ^spelling |bob's| ^referent @4016002 ^number singular ^specifier definite ^super-type @991050)
(@1000189 ^spelling |charlie's| ^referent @4016003 ^number singular ^specifier definite ^super-type @991050)
(@4010000 ^type unit ^handle unit ^item-type property)
(@4010001 ^property @4010000 ^handle meters ^item-type concept)
(@4010002 ^property @4010000 ^handle feet ^item-type concept)
(@4010003 ^property @4010000 ^handle inches ^item-type concept)
(@4010004 ^property @4010000 ^handle centimeters ^item-type concept)
(@4011000 ^type number ^handle number ^item-type property)
(@4011100 ^property @4011000 ^handle zeroth1 ^item-type predicate)
(@4011101 ^property @4011000 ^handle first1 ^item-type predicate)
(@4011102 ^property @4011000 ^handle second1 ^item-type predicate)
(@4011103 ^property @4011000 ^handle third1 ^item-type predicate)
(@4011104 ^property @4011000 ^handle fourth1 ^item-type predicate)
(@4011105 ^property @4011000 ^handle fifth1 ^item-type predicate)
(@4011106 ^property @4011000 ^handle sixth1 ^item-type predicate)
(@4011107 ^property @4011000 ^handle seventh1 ^item-type predicate)
(@4011108 ^property @4011000 ^handle eighth1 ^item-type predicate)
(@4011109 ^property @4011000 ^handle ninth1 ^item-type predicate)
(@4011200 ^property @4011000 ^handle 0 ^item-type predicate)
(@4011201 ^property @4011000 ^handle 1 ^item-type predicate)
(@4011202 ^property @4011000 ^handle 2 ^item-type predicate)
(@4011203 ^property @4011000 ^handle 3 ^item-type predicate)
(@4011204 ^property @4011000 ^handle 4 ^item-type predicate)
(@4011205 ^property @4011000 ^handle 5 ^item-type predicate)
(@4011206 ^property @4011000 ^handle 6 ^item-type predicate)
(@4011207 ^property @4011000 ^handle 7 ^item-type predicate)
(@4011208 ^property @4011000 ^handle 8 ^item-type predicate)
(@4011209 ^property @4011000 ^handle 9 ^item-type predicate)
(@4011210 ^property @4011000 ^handle 10 ^item-type predicate)
(@4011211 ^property @4011000 ^handle 11 ^item-type predicate)
(@4011212 ^property @4011000 ^handle 12 ^item-type predicate)
(@4011213 ^property @4011000 ^handle 13 ^item-type predicate)
(@4011214 ^property @4011000 ^handle 14 ^item-type predicate)
(@4011215 ^property @4011000 ^handle 15 ^item-type predicate)
(@4011216 ^property @4011000 ^handle 16 ^item-type predicate)
(@4011217 ^property @4011000 ^handle 17 ^item-type predicate)
(@4011218 ^property @4011000 ^handle 18 ^item-type predicate)
(@4011219 ^property @4011000 ^handle 19 ^item-type predicate)
(@4011220 ^property @4011000 ^handle 20 ^item-type predicate)
(@4011221 ^property @4011000 ^handle 21 ^item-type predicate)
(@4011222 ^property @4011000 ^handle 22 ^item-type predicate)
(@4011223 ^property @4011000 ^handle 23 ^item-type predicate)
(@4011224 ^property @4011000 ^handle 24 ^item-type predicate)
(@4011225 ^property @4011000 ^handle 25 ^item-type predicate)
(@4011226 ^property @4011000 ^handle 26 ^item-type predicate)
(@4011227 ^property @4011000 ^handle 27 ^item-type predicate)
(@4011228 ^property @4011000 ^handle 28 ^item-type predicate)
(@4011229 ^property @4011000 ^handle 29 ^item-type predicate)
(@4011230 ^property @4011000 ^handle 30 40 ^item-type predicate)
(@4011231 ^property @4011000 ^handle 31 ^item-type predicate)
(@4011232 ^property @4011000 ^handle 32 ^item-type predicate)
(@4011233 ^property @4011000 ^handle 33 ^item-type predicate)
(@4011234 ^property @4011000 ^handle 34 ^item-type predicate)
(@4011235 ^property @4011000 ^handle 35 ^item-type predicate)
(@4011236 ^property @4011000 ^handle 36 ^item-type predicate)
(@4011237 ^property @4011000 ^handle 37 ^item-type predicate)
(@4011238 ^property @4011000 ^handle 38 ^item-type predicate)
(@4011239 ^property @4011000 ^handle 39 ^item-type predicate)
(@4012000 ^type visual ^handle spatial-shape ^item-type property)
(@4012001 ^property @4012000 ^handle end1 ^item-type predicate)
(@4012002 ^property @4012000 ^handle wall1 ^item-type predicate)
(@4012003 ^property @4012000 ^handle hall1 ^item-type predicate)
(@4012004 ^property @4012000 ^handle door ^item-type predicate ^output-word door)
(@4012005 ^property @4012000 ^handle intersection ^item-type predicate ^output-word intersection)
(@4012006 ^property @4012000 ^handle opening1 ^item-type predicate)
(@4012007 ^property @4012000 ^handle t-intersection1 ^item-type predicate)
(@4012008 ^property @4012000 ^handle room1 ^item-type predicate)
(@4012009 ^property @4012000 ^handle waypoint ^item-type predicate)
(@4012010 ^multiple true ^property @4012000 ^handle door ^item-type predicate ^output-word door)
(@4012011 ^property @4012000 ^handle office1 ^item-type predicate ^style office)
(@4014000 ^type visual ^handle property ^item-type property)
(@4014001 ^property @4014000 ^handle task-completed ^item-type predicate)
(@4014100 ^type state ^handle meat1 ^item-type property)
(@4014101 ^property @4014100 ^handle cooked1 ^item-type concept)
(@4014102 ^property @4014100 ^handle raw1 ^item-type concept)
(@4014200 ^type state ^handle door1 ^item-type property)
(@4014201 ^property @4014200 ^handle open2 ^item-type concept)
(@4014202 ^property @4014200 ^handle closed2 ^item-type concept)
(@4014300 ^type state ^handle action1 ^item-type property)
(@4014302 ^property @4014300 ^handle last-moved1 ^item-type predicate)
(@4015000 ^type visual ^handle property ^item-type property)
(@4015001 ^property @4015000 ^handle task-completed ^item-type predicate)
(@4015002 ^property @4015000 ^handle won ^item-type predicate)
(@4015003 ^property @4015000 ^handle lost ^item-type predicate)
(@4016000 ^handle possessive ^item-type property)
(@4016001 ^property @4016000 ^handle alices1 ^item-type predicate ^person-name alice1)
(@4016002 ^property @4016000 ^handle bobs1 ^item-type predicate ^person-name bob1)
(@4016003 ^property @4016000 ^handle charlies1 ^item-type predicate ^person-name charlie1)
(@4017000 ^type visual ^handle gender ^item-type property)
(@6010000 ^specifier indefinite ^structure-type CN ^converts-to DP ^assigners @999969 @999970 @999971)
}

