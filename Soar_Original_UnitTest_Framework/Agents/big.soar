# This file was generated by concatenating all agents from the old Demos
# directory, to serve as a torture test for the parser.
sp {hello-world
    (state <s> ^type state)
-->
    (write |Hello World|)
    (halt)
}
sp {elaborate*top-state*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)
}
sp {elaborate*state*name
    (state <s> ^superstate <ss>)
    (<ss> ^operator <op>)
    (<op> ^name <name>)
-->
    (<s> ^name <name>)
}
sp {elaborate*state*top-state
    (state <s> ^superstate <ss>)
    (<ss> ^top-state <ts>)
-->
    (<s> ^top-state <ts>)
}
sp {kb*propose*test-notify
    (state <s> ^name kb
               ^phase test
               ^sub-phase notify
               ^result <result>
               ^step <step>
               ^max-tests <max>
               ^current-test {<c> <= <max>}
               ^tests <ts>)
    (<ts> ^test <t>)
    (<t> ^id <c>
         ^steps {>= <step>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name test-notify
          ^test <c>
          ^step <step>
          ^result <result>)
}
sp {apply*test-notify*success
    (state <s> ^operator <op>
               ^tests <ts>)
    (<ts> ^test <t>)
    (<op> ^name test-notify
          ^test <c>
          ^step <step>
          ^result success)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>)
-->
    (<s> ^step <step> -
         ^step (+ <step> 1)
         ^result success -
         ^sub-phase notify -
         ^sub-phase cue)
    (write | | <step> |: complete.| (crlf) | |)
}
sp {apply*test-notify*clean*query
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^query <q>)
-->
    (<cmd> ^query <q> -)
}
sp {apply*test-notify*clean*neg-query
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^neg-query <q>)
-->
    (<cmd> ^neg-query <q> -)
}
sp {apply*test-notify*clean*retrieve
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^retrieve <q>)
-->
    (<cmd> ^retrieve <q> -)
}
sp {apply*test-notify*clean*next
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^next <q>)
-->
    (<cmd> ^next <q> -)
}
sp {apply*test-notify*clean*previous
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^previous <q>)
-->
    (<cmd> ^previous <q> -)
}
sp {apply*test-notify*clean*before
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^before <q>)
-->
    (<cmd> ^before <q> -)
}
sp {apply*test-notify*clean*after
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^after <q>)
-->
    (<cmd> ^after <q> -)
}
sp {apply*test-notify*clean*prohibit
    (state <s> ^operator <op>
               ^epmem <epmem>)
    (<op> ^name test-notify
          ^result success)
    (<epmem> ^command <cmd>)
    (<cmd> ^prohibit <q>)
-->
    (<cmd> ^prohibit <q> -)
}
sp {apply*test-notify*failure
    (state <s> ^operator <op>
               ^tests <ts>)
    (<op> ^name test-notify
          ^test <c>
          ^step <step>
          ^result failure)
    (<ts> ^test <t>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>)
-->
    (write | | <step> |: failed.| (crlf) | |)
    (halt)
}
sp {kb*propose*done
    (state <s> ^name kb
               ^phase test
               ^sub-phase init
               ^max-tests <max>
               ^current-test {<c> > <max>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name done
          ^test <c>)
}
sp {apply*done
    (state <s> ^operator <op>)
    (<op> ^name done)
-->
    (write (crlf) |All tests complete!| (crlf))
    (halt)
}
sp {kb*propose*test-init
    (state <s> ^name kb
               ^phase test
               ^sub-phase init
               ^max-tests <max>
               ^current-test {<c> <= <max>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name test-init
          ^test <c>)
}
sp {apply*test-init
    (state <s> ^operator <op>
               ^tests <ts>)
    (<ts> ^test <t>)
    (<op> ^name test-init
          ^test <c>)
    (<t> ^id <c>
         ^name <t-name>
         ^note <t-note>)
-->
    (<s> ^sub-phase init -
         ^sub-phase cue
         ^step 1)
    (write (crlf) |Test (| <c> |) "| <t-name> |" - begin|)
    (write (crlf) <t-note> (crlf) | |)
}
sp {kb*propose*test-cue
    (state <s> ^name kb
               ^phase test
               ^sub-phase cue
               ^step <step>
               ^max-tests <max>
               ^current-test {<c> <= <max>}
               ^tests <ts>)
    (<ts> ^test <t>)
    (<t> ^id <c>
         ^steps {>= <step>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name test-cue
          ^test <c>
          ^step <step>)
}
sp {apply*test-cue*prepare
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>)
    (<ts> ^test <t>)
    (<epmem> ^command <e-cmd>)
    (<op> ^name test-cue
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^command <st-cmd>)
    (<st-cmd> ^<t-cmd-name> <t-cmd-val>)
-->
    (<e-cmd> ^<t-cmd-name> <t-cmd-val>)
    (write (crlf) | | <step>|: cue | <t-cmd-name> )
}
sp {apply*test-cue*next
    (state <s> ^operator <op>)
    (<op> ^name test-cue)
-->
    (<s> ^sub-phase cue -
         ^sub-phase result)
}
sp {kb*propose*transition
    (state <s> ^name kb
               ^phase load
               ^max-entries <max>
               ^current-entry {> <max>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name transition)
}
sp {apply*transition*clean
    (state <s> ^operator <op>
               ^observing <e>)
    (<op> ^name transition)
-->
    (<s> ^observing <e> -)
}
sp {apply*transition
    (state <s> ^operator <op>)
    (<op> ^name transition)
-->
    (<s> ^phase load -
         ^phase test)
    (cmd epmem --set trigger none)
    (write | | (crlf) |loading done, proceeding to tests| (crlf) | |)
}
sp {propose*initialize-kb
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-kb)
}
sp {apply*initialize-kb*params
    (state <s> ^operator <op>)
    (<op> ^name initialize-kb)
-->
    (<s> ^phase load
         ^sub-phase init
         ^current-entry 1
         ^current-test 1
         ^max-entries 5
         ^max-tests 14
         ^entries <e>
         ^tests <t>)
}
sp {apply*intialize-kb*fill
    (state <s> ^operator <op>
               ^max-entries <max-entries>
               ^max-tests <max-tests>
               ^entries <e>
               ^tests <t>)
    (<op> ^name initialize-kb)
-->
    (<s> ^name kb)
    (<e> ^entry <e1>
         ^entry <e2>
         ^entry <e3>
         ^entry <e4>
         ^entry <e5>)
    (<t> ^test <t1>
         ^test <t2>
         ^test <t3>
         ^test <t4>
         ^test <t5>
         ^test <t6>
         ^test <t7>
         ^test <t8>
         ^test <t9>
         ^test <t10>
         ^test <t11>
         ^test <t13>
         ^test <t14>
         ^test <t15>)
    (<e1> ^id 1
          ^name |Sei whale|
          ^scientific-name |Balaenoptera borealis|
          ^attributes <a1>)
    (<a1> ^kind-of rorqual
          ^order Cetacea
          ^is warm-blooded
          ^may-catch rabies)
    (<e2> ^id 2
          ^name |humpback whale|
          ^scientific-name |Megaptera novaeangliae|
          ^attributes <a1>)
    (<e3> ^id 3
          ^name |killer whale|
          ^scientific-name |Orcinus orca|
          ^attributes <a3>)
    (<a3> ^kind-of |dolphin or porpoise|
          ^order Cetacea
          ^is warm-blooded
          ^may-catch rabies)
    (<e4> ^id 4
          ^name |blue dolphin|
          ^scientific-name |Stenella caeruleoalba|
          ^attributes <a3>)
    (<e5> ^id 5
          ^name |True's beaked whale|
          ^scientific-name |Mesoplodon mirus|
          ^attributes <a5>)
    (<a5> ^kind-of |beaked whale|
          ^order Cetacea
          ^is warm-blooded
          ^may-catch rabies)
          ###
    (<t1> ^id 1
          ^name |bad retrieval|
          ^note |attempting to retrieve known bad memory ids|
          ^steps 2
          ^step <st1-1>
          ^step <st1-2>)
    (<st1-1> ^id 1
             ^type retrieve
             ^status none
             ^command <c1-1>)
    (<c1-1> ^retrieve 100)
    (<st1-2> ^id 2
             ^type retrieve
             ^status none
             ^command <c1-2>)
    (<c1-2> ^retrieve 99999)
    ###
    (<t2> ^id 2
          ^name |good retrieval|
          ^note |attempting to retrieve a known good memory id|
          ^steps 1
          ^step <st2-1>)
    (<st2-1> ^id 1
             ^type retrieve
             ^status good
             ^command <c2-1>
             ^expected 1)
    (<c2-1> ^retrieve 1)
    ###
    (<t3> ^id 3
          ^name |bad query|
          ^note |attempting to query for a known bad state name|
          ^steps 1
          ^step <st3-1>)
    (<st3-1> ^id 1
             ^type query
             ^status failure
             ^command <c3-1>)
    (<c3-1> ^query <q3-1>)
    (<q3-1> ^name bad-state-name)
    ###
    (<t4> ^id 4
          ^name |soar query|
          ^note |state name; superstate; good state, bad state; state, superstate; io|
          ^steps 5
          ^step <st4-1>
          ^step <st4-2>
          ^step <st4-3>
          ^step <st4-4>
          ^step <st4-5>)
    (<st4-1> ^id 1
             ^type query
             ^status success
             ^command <c4-1>
             ^expected <max-entries>
             ^score 1.)
    (<c4-1> ^query <q4-1>)
    (<q4-1> ^name kb)
    (<st4-2> ^id 2
             ^type query
             ^status success
             ^command <c4-2>
             ^expected <max-entries>
             ^score 1.)
    (<c4-2> ^query <q4-2>)
    (<q4-2> ^superstate nil)
    (<st4-3> ^id 3
             ^type query
             ^status success
             ^command <c4-3>
             ^expected <max-entries>
             ^score 1.)
    (<c4-3> ^query <q4-3>)
    (<q4-3> ^name kb
            ^name bad-state-name)
    (<st4-4> ^id 4
             ^type query
             ^status success
             ^command <c4-4>
             ^expected <max-entries>
             ^score 2.)
    (<c4-4> ^query <q4-4>)
    (<q4-4> ^name kb
            ^superstate nil)
    (<st4-5> ^id 5
             ^type query
             ^status success
             ^command <c4-5>
             ^expected <max-entries>
             ^score 1.)
    (<c4-5> ^query <q4-5>)
    (<q4-5> ^io <io4-5>)
    ###
    (<t5> ^id 5
          ^name |observing query|
          ^note |query by "observing": 0, 1, last, last+1|
          ^steps 4
          ^step <st5-1>
          ^step <st5-2>
          ^step <st5-3>
          ^step <st5-4>)
    (<st5-1> ^id 1
             ^type query
             ^status failure
             ^command <c5-1>)
    (<c5-1> ^query <q5-1>)
    (<q5-1> ^observing 0)
    (<st5-2> ^id 2
             ^type query
             ^status success
             ^command <c5-2>
             ^expected 1
             ^score 1.)
    (<c5-2> ^query <q5-2>)
    (<q5-2> ^observing 1)
    (<st5-3> ^id 3
             ^type query
             ^status success
             ^command <c5-3>
             ^expected <max-entries>
             ^score 1.)
    (<c5-3> ^query <q5-3>)
    (<q5-3> ^observing <max-entries>)
    (<st5-4> ^id 4
             ^type query
             ^status failure
             ^command <c5-4>)
    (<c5-4> ^query <q5-4>)
    (<q5-4> ^observing (+ <max-entries> 1))
    ###
    (<t6> ^id 6
          ^name |prohibit test|
          ^note |query 1, prohibit the result, failure; query state name, prohibit last, last-1|
          ^steps 4
          ^step <st6-1>
          ^step <st6-2>
          ^step <st6-3>
          ^step <st6-4>)
    (<st6-1> ^id 1
             ^type query
             ^status success
             ^command <c6-1>
             ^expected 1
             ^score 1.)
    (<c6-1> ^query <q6-1>)
    (<q6-1> ^observing 1)
    (<st6-2> ^id 2
             ^type query
             ^status failure
             ^command <c6-2>)
    (<c6-2> ^query <q6-2>
            ^prohibit 1)
    (<q6-2> ^observing 1)
    (<st6-3> ^id 3
             ^type query
             ^status success
             ^command <c6-3>
             ^expected <max-entries>
             ^score 1.)
    (<c6-3> ^query <q6-3>)
    (<q6-3> ^name kb)
    (<st6-4> ^id 4
             ^type query
             ^status success
             ^command <c6-4>
             ^expected (- <max-entries> 1)
             ^score 1.)
    (<c6-4> ^query <q6-4>
            ^prohibit <max-entries>)
    (<q6-4> ^name kb)
    ###
    (<t7> ^id 7
          ^name |next test|
          ^note |query 1, next, 2, next 3; query last, next, failure|
          ^steps 5
          ^step <st7-1>
          ^step <st7-2>
          ^step <st7-3>
          ^step <st7-4>
          ^step <st7-5>)
    (<st7-1> ^id 1
             ^type query
             ^status success
             ^command <c7-1>
             ^expected 1
             ^score 1.)
    (<c7-1> ^query <q7-1>)
    (<q7-1> ^observing 1)
    (<st7-2> ^id 2
             ^type retrieve
             ^status good
             ^command <c7-2>
             ^expected 2)
    (<c7-2> ^next <n7-2>)
    (<st7-3> ^id 3
             ^type retrieve
             ^status good
             ^command <c7-3>
             ^expected 3)
    (<c7-3> ^next <n7-3>)
    (<st7-4> ^id 4
             ^type query
             ^status success
             ^command <c7-4>
             ^expected <max-entries>
             ^score 1.)
    (<c7-4> ^query <q7-4>)
    (<q7-4> ^observing <max-entries>)
    (<st7-5> ^id 5
             ^type retrieve
             ^status none
             ^command <c7-5>)
    (<c7-5> ^next <n7-5>)
    ###
    (<t8> ^id 8
          ^name |previous test|
          ^note |query 1, previous, failure; query last, previous, last-1, previous, last-2|
          ^steps 5
          ^step <st8-1>
          ^step <st8-2>
          ^step <st8-3>
          ^step <st8-4>
          ^step <st8-5>)
    (<st8-1> ^id 1
             ^type query
             ^status success
             ^command <c8-1>
             ^expected 1
             ^score 1.)
    (<c8-1> ^query <q8-1>)
    (<q8-1> ^observing 1)
    (<st8-2> ^id 2
             ^type retrieve
             ^status none
             ^command <c8-2>
             ^expected 2)
    (<c8-2> ^previous <p8-2>)
    (<st8-3> ^id 3
             ^type query
             ^status success
             ^command <c8-3>
             ^expected <max-entries>
             ^score 1.)
    (<c8-3> ^query <q8-3>)
    (<q8-3> ^observing <max-entries>)
    (<st8-4> ^id 4
             ^type retrieve
             ^status good
             ^command <c8-4>
             ^expected (- <max-entries> 1))
    (<c8-4> ^previous <p8-4>)
    (<st8-5> ^id 5
             ^type retrieve
             ^status good
             ^command <c8-5>
             ^expected (- <max-entries> 2))
    (<c8-5> ^previous <p8-5>)
    ###
    (<t9> ^id 9
          ^name |before test|
          ^note |query 1, before 1, failure; query 2, before 2, failure, before 3, 2; query state name, before last, last-1|
          ^steps 7
          ^step <st9-1>
          ^step <st9-2>
          ^step <st9-3>
          ^step <st9-4>
          ^step <st9-5>
          ^step <st9-6>
          ^step <st9-7>)
    (<st9-1> ^id 1
             ^type query
             ^status success
             ^command <c9-1>
             ^expected 1
             ^score 1.)
    (<c9-1> ^query <q9-1>)
    (<q9-1> ^observing 1)
    (<st9-2> ^id 2
             ^type query
             ^status failure
             ^command <c9-2>)
    (<c9-2> ^query <q9-2>
            ^before 1)
    (<q9-2> ^observing 1)
    (<st9-3> ^id 3
             ^type query
             ^status success
             ^command <c9-3>
             ^expected 2
             ^score 1.)
    (<c9-3> ^query <q9-3>)
    (<q9-3> ^observing 2)
    (<st9-4> ^id 4
             ^type query
             ^status failure
             ^command <c9-4>)
    (<c9-4> ^query <q9-4>
            ^before 2)
    (<q9-4> ^observing 2)
    (<st9-5> ^id 5
             ^type query
             ^status success
             ^command <c9-5>
             ^expected 2
             ^score 1.)
    (<c9-5> ^query <q9-5>
            ^before 3)
    (<q9-5> ^observing 2)
    (<st9-6> ^id 6
             ^type query
             ^status success
             ^command <c9-6>
             ^expected <max-entries>
             ^score 1.)
    (<c9-6> ^query <q9-6>)
    (<q9-6> ^name kb)
    (<st9-7> ^id 7
             ^type query
             ^status success
             ^command <c9-7>
             ^expected (- <max-entries> 1)
             ^score 1.)
    (<c9-7> ^query <q9-7>
            ^before <max-entries>)
    (<q9-7> ^name kb)
    ###
    (<t10> ^id 10
           ^name |after test|
           ^note |query last, after last, failure; query last-1, after last-1, failure, after last-2, last-1|
           ^steps 5
           ^step <st10-1>
           ^step <st10-2>
           ^step <st10-3>
           ^step <st10-4>
           ^step <st10-5>)
    (<st10-1> ^id 1
              ^type query
              ^status success
              ^command <c10-1>
              ^expected <max-entries>
              ^score 1.)
    (<c10-1> ^query <q10-1>)
    (<q10-1> ^observing <max-entries>)
    (<st10-2> ^id 2
              ^type query
              ^status failure
              ^command <c10-2>)
    (<c10-2> ^query <q10-2>
             ^after <max-entries>)
    (<q10-2> ^observing <max-entries>)
    (<st10-3> ^id 3
              ^type query
              ^status success
              ^command <c10-3>
              ^expected (- <max-entries> 1)
              ^score 1.)
    (<c10-3> ^query <q10-3>)
    (<q10-3> ^observing (- <max-entries> 1))
    (<st10-4> ^id 4
              ^type query
              ^status failure
              ^command <c10-4>)
    (<c10-4> ^query <q10-4>
             ^after (- <max-entries> 1))
    (<q10-4> ^observing (- <max-entries> 1))
    (<st10-5> ^id 5
              ^type query
              ^status success
              ^command <c10-5>
              ^expected (- <max-entries> 1)
              ^score 1.)
    (<c10-5> ^query <q10-5>
             ^after (- <max-entries> 2))
    (<q10-5> ^observing (- <max-entries> 1))
    ###
    (<t11> ^id 11
           ^name |before/after test|
           ^note |query 3, before last, after 1, before last + after 1, before 4 + after 2, before 3 + after 2 (fail), before 4 + after 3 (fail)|
           ^steps 7
           ^step <st11-1>
           ^step <st11-2>
           ^step <st11-3>
           ^step <st11-4>
           ^step <st11-5>
           ^step <st11-6>
           ^step <st11-7>)
    (<st11-1> ^id 1
              ^type query
              ^status success
              ^command <c11-1>
              ^expected 3
              ^score 1.)
    (<c11-1> ^query <q11-1>)
    (<q11-1> ^observing 3)
    (<st11-2> ^id 2
              ^type query
              ^status success
              ^command <c11-2>
              ^expected 3
              ^score 1.)
    (<c11-2> ^query <q11-2>
             ^before <max-entries>)
    (<q11-2> ^observing 3)
    (<st11-3> ^id 3
              ^type query
              ^status success
              ^command <c11-3>
              ^expected 3
              ^score 1.)
    (<c11-3> ^query <q11-3>
             ^after 1)
    (<q11-3> ^observing 3)
    (<st11-4> ^id 4
              ^type query
              ^status success
              ^command <c11-4>
              ^expected 3
              ^score 1.)
    (<c11-4> ^query <q11-4>
             ^before <max-entries>
             ^after 1)
    (<q11-4> ^observing 3)
    (<st11-5> ^id 5
              ^type query
              ^status success
              ^command <c11-5>
              ^expected 3
              ^score 1.)
    (<c11-5> ^query <q11-5>
             ^before 4
             ^after 2)
    (<q11-5> ^observing 3)
    (<st11-6> ^id 6
              ^type query
              ^status failure
              ^command <c11-6>)
    (<c11-6> ^query <q11-6>
             ^before 3
             ^after 2)
    (<q11-6> ^observing 3)
    (<st11-7> ^id 7
              ^type query
              ^status failure
              ^command <c11-7>)
    (<c11-7> ^query <q11-7>
             ^before 4
             ^after 3)
    (<q11-7> ^observing 3)
    ###
    ###
    (<t13> ^id 12
           ^name |pos+neg tests|
           ^note |+good state -bad state, last; +bad stat -good state, last; +good state -last, last-1; +last -good state, last; +last -last, last; +1 last -last, 1|
           ^steps 6
           ^step <st13-1>
           ^step <st13-2>
           ^step <st13-3>
           ^step <st13-4>
           ^step <st13-5>
           ^step <st13-6>)
    (<st13-1> ^id 1
              ^type query
              ^status success
              ^command <c13-1>
              ^expected <max-entries>
              ^score 1.)
    (<c13-1> ^query <q13-1>
             ^neg-query <nq13-1>)
    (<q13-1> ^name kb)
    (<nq13-1> ^name bad-state-name)
    (<st13-2> ^id 2
              ^type query
              ^status success
              ^command <c13-2>
              ^expected <max-entries>
              ^score -1.)
    (<c13-2> ^query <q13-2>
             ^neg-query <nq13-2>)
    (<q13-2> ^name bad-state-name)
    (<nq13-2> ^name kb)
    (<st13-3> ^id 3
              ^type query
              ^status success
              ^command <c13-3>
              ^expected (- <max-entries> 1)
              ^score 1.)
    (<c13-3> ^query <q13-3>
             ^neg-query <nq13-3>)
    (<q13-3> ^name kb)
    (<nq13-3> ^observing <max-entries>)
    (<st13-4> ^id 4
              ^type query
              ^status success
              ^command <c13-4>
              ^expected <max-entries>
              ^score 0.)
    (<c13-4> ^query <q13-4>
             ^neg-query <nq13-4>)
    (<q13-4> ^observing <max-entries>)
    (<nq13-4> ^name kb)
    (<st13-5> ^id 5
              ^type query
              ^status success
              ^command <c13-5>
              ^expected <max-entries>
              ^score 0.)
    (<c13-5> ^query <q13-5>
             ^neg-query <nq13-5>)
    (<q13-5> ^observing <max-entries>)
    (<nq13-5> ^observing <max-entries>)
    (<st13-6> ^id 6
              ^type query
              ^status success
              ^command <c13-6>
              ^expected 1
              ^score 1.)
    (<c13-6> ^query <q13-6>
             ^neg-query <nq13-6>)
    (<q13-6> ^observing <max-entries>
             ^observing 1)
    (<nq13-6> ^observing <max-entries>)
    ###
    (<t14> ^id 13
           ^name |all together now!|
           ^note |+state, last; +state -last, last-1; +state -last before last after 1, last-1; +state -last before last-1 after 1, last-2; +state -last before last-1 prohibit last-2, last-3; +state +1, 1; +state +1 +2 +3 +4, 4; +state +1 +2 +3 +4 -4, 3; +state +1 +2 +3 +4 -4 before 3, 2; +state +1 +2 +3 +4 -4 before 3 prohibit 2, 1; +state +1 +2 +3 +4 -4 after 3 prohibit 2, last; +state +1 +2 +3 +4 -4 after 3 before last prohibit 2, last-1; next, last; previous, last-1|
           ^steps 14
           ^step <st14-1>
           ^step <st14-2>
           ^step <st14-3>
           ^step <st14-4>
           ^step <st14-5>
           ^step <st14-6>
           ^step <st14-7>
           ^step <st14-8>
           ^step <st14-9>
           ^step <st14-10>
           ^step <st14-11>
           ^step <st14-12>
           ^step <st14-13>
           ^step <st14-14>)
    (<st14-1> ^id 1
              ^type query
              ^status success
              ^command <c14-1>
              ^expected <max-entries>
              ^score 1.)
    (<c14-1> ^query <q14-1>
             ^neg-query <n14-1>)
    (<q14-1> ^name kb)
    (<st14-2> ^id 2
              ^type query
              ^status success
              ^command <c14-2>
              ^expected (- <max-entries> 1)
              ^score 1.)
    (<c14-2> ^query <q14-2>
             ^neg-query <n14-2>)
    (<q14-2> ^name kb)
    (<n14-2> ^observing <max-entries>)
    (<st14-3> ^id 3
              ^type query
              ^status success
              ^command <c14-3>
              ^expected (- <max-entries> 1)
              ^score 1.)
    (<c14-3> ^query <q14-3>
             ^neg-query <n14-3>
             ^before <max-entries>
             ^after 1)
    (<q14-3> ^name kb)
    (<n14-3> ^observing <max-entries>)
    (<st14-4> ^id 4
              ^type query
              ^status success
              ^command <c14-4>
              ^expected (- <max-entries> 2)
              ^score 1.)
    (<c14-4> ^query <q14-4>
             ^neg-query <n14-4>
             ^before (- <max-entries> 1)
             ^after 1)
    (<q14-4> ^name kb)
    (<n14-4> ^observing <max-entries>)
    (<st14-5> ^id 5
              ^type query
              ^status success
              ^command <c14-5>
              ^expected (- <max-entries> 3)
              ^score 1.)
    (<c14-5> ^query <q14-5>
             ^neg-query <n14-5>
             ^before (- <max-entries> 1)
             ^after 1
             ^prohibit (- <max-entries> 2))
    (<q14-5> ^name kb)
    (<n14-5> ^observing <max-entries>)
    (<st14-6> ^id 6
              ^type query
              ^status success
              ^command <c14-6>
              ^expected 1
              ^score 2.)
    (<c14-6> ^query <q14-6>
             ^neg-query <n14-6>)
    (<q14-6> ^name kb
             ^observing 1)
    (<st14-7> ^id 7
              ^type query
              ^status success
              ^command <c14-7>
              ^expected 4
              ^score 2.)
    (<c14-7> ^query <q14-7>
             ^neg-query <n14-7>)
    (<q14-7> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
    (<st14-8> ^id 8
              ^type query
              ^status success
              ^command <c14-8>
              ^expected 3
              ^score 2.)
    (<c14-8> ^query <q14-8>
             ^neg-query <n14-8>)
    (<q14-8> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
    (<n14-8> ^observing 4)
    (<st14-9> ^id 9
              ^type query
              ^status success
              ^command <c14-9>
              ^expected 2
              ^score 2.)
    (<c14-9> ^query <q14-9>
             ^neg-query <n14-9>
             ^before 3)
    (<q14-9> ^name kb
             ^observing 1
             ^observing 2
             ^observing 3
             ^observing 4)
    (<n14-9> ^observing 4)
    (<st14-10> ^id 10
               ^type query
               ^status success
               ^command <c14-10>
               ^expected 1
               ^score 2.)
    (<c14-10> ^query <q14-10>
              ^neg-query <n14-10>
              ^before 3
              ^prohibit 2)
    (<q14-10> ^name kb
              ^observing 1
              ^observing 2
              ^observing 3
              ^observing 4)
    (<n14-10> ^observing 4)
    (<st14-11> ^id 11
               ^type query
               ^status success
               ^command <c14-11>
               ^expected <max-entries>
               ^score 1.)
    (<c14-11> ^query <q14-11>
              ^neg-query <n14-11>
              ^after 3
              ^prohibit 2)
    (<q14-11> ^name kb
              ^observing 1
              ^observing 2
              ^observing 3
              ^observing 4)
    (<n14-11> ^observing 4)
    (<st14-12> ^id 12
               ^type query
               ^status success
               ^command <c14-12>
               ^expected (- <max-entries> 1)
               ^score 1.)
    (<c14-12> ^query <q14-12>
              ^neg-query <n14-12>
              ^after 3
              ^before <max-entries>
              ^prohibit 2)
    (<q14-12> ^name kb
              ^observing 1
              ^observing 2
              ^observing 3
              ^observing 4)
    (<n14-12> ^observing 4)
    (<st14-13> ^id 13
               ^type retrieve
               ^status good
               ^command <c14-13>
               ^expected <max-entries>)
    (<c14-13> ^next <n14-13>)
    (<st14-14> ^id 14
               ^type retrieve
               ^status good
               ^command <c14-14>
               ^expected (- <max-entries> 1))
    (<c14-14> ^previous <p14-14>)
    ###
    (<t15> ^id 14
           ^name |mode 3 checks|
           ^note |warm-blooded, score 1; warm-blooded and Cetacea, score 2; warm-blooded, rabies, not Cetacea, score 1; warm-blooded, rabies, not beaked whale, score 2|
           ^steps 4
           ^step <st15-1>
           ^step <st15-2>
           ^step <st15-3>
           ^step <st15-4>)
    (<st15-1> ^id 1
              ^type query
              ^status success
              ^command <c15-1>
              ^expected <max-entries>
              ^score 1.)
    (<c15-1> ^query <q15-1>)
    (<q15-1> ^observing-entry <oe15-1>)
    (<oe15-1> ^attributes <a15-1>)
    (<a15-1> ^is warm-blooded)
    (<st15-2> ^id 2
              ^type query
              ^status success
              ^command <c15-2>
              ^expected <max-entries>
              ^score 2.)
    (<c15-2> ^query <q15-2>)
    (<q15-2> ^observing-entry <oe15-2>)
    (<oe15-2> ^attributes <a15-2>)
    (<a15-2> ^is warm-blooded
             ^order Cetacea)
    (<st15-3> ^id 3
              ^type query
              ^status success
              ^command <c15-3>
              ^expected <max-entries>
              ^score 1.)
    (<c15-3> ^query <q15-3>
             ^neg-query <n15-3>)
    (<q15-3> ^observing-entry <oe15-3>)
    (<oe15-3> ^attributes <a15-3>)
    (<a15-3> ^is warm-blooded
             ^may-catch rabies)
    (<n15-3> ^observing-entry <noe15-3>)
    (<noe15-3> ^attributes <na15-3>)
    (<na15-3> ^order Cetacea)
    (<st15-4> ^id 4
              ^type query
              ^status success
              ^command <c15-4>
              ^expected (- <max-entries> 1)
              ^score 2.)
    (<c15-4> ^query <q15-4>
             ^neg-query <n15-4>)
    (<q15-4> ^observing-entry <oe15-4>)
    (<oe15-4> ^attributes <a15-4>)
    (<a15-4> ^is warm-blooded
             ^may-catch rabies)
    (<n15-4> ^observing-entry <noe15-4>)
    (<noe15-4> ^attributes <na15-4>)
    (<na15-4> ^kind-of |beaked whale|)
}
sp {kb*propose*test-result
    (state <s> ^name kb
               ^phase test
               ^sub-phase result
               ^step <step>
               ^max-tests <max>
               ^current-test {<c> <= <max>}
               ^tests <ts>)
    (<ts> ^test <t>)
    (<t> ^id <c>
         ^steps {>= <step>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
}
sp {apply*test-result*retrieve*none*success
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type retrieve
          ^status none)
    (<e-result> ^retrieved no-memory)
-->
    (<s> ^result success
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - no-memory| (crlf))
    (write |  result - no-memory| (crlf))
}
sp {apply*test-result*retrieve*none*failure
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type retrieve
          ^status none)
   -(<e-result> ^retrieved no-memory)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - no-memory| (crlf))
    (write |  result - memory retrieved| (crlf))
}
sp {apply*test-result*retrieve*good*success
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type retrieve
          ^status good
          ^expected <expected>)
    (<e-result> ^retrieved <retrieved>)
    (<retrieved> ^observing <expected>)
    (<entry> ^id <expected>
             ^name <entry-name>
             ^scientific-name <entry-s-name>)
-->
    (<s> ^result success
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - | <entry-name> | (| <entry-s-name> |)| (crlf))
    (write |  result - | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {apply*test-result*retrieve*good*wrong
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry1>
          ^entry <entry2>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type retrieve
          ^status good
          ^expected <expected>)
    (<e-result> ^retrieved <retrieved>)
    (<retrieved> ^observing {<observed> <> <expected>})
    (<entry1> ^id <expected>
              ^name <entry1-name>
              ^scientific-name <entry1-s-name>)
    (<entry2> ^id <observed>
              ^name <entry2-name>
              ^scientific-name <entry2-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
    (write |  result - | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*retrieve*good*none
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry1>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type retrieve
          ^status good
          ^expected <expected>)
    (<e-result> ^retrieved no-memory)
    (<entry1> ^id <expected>
              ^name <entry1-name>
              ^scientific-name <entry1-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
    (write |  result - no-memory| (crlf))
}
sp {apply*test-result*query*failure*success
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status failure)
    (<e-result> ^failure)
-->
    (<s> ^result success
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - query failure| (crlf))
    (write |  result - query failure| (crlf))
}
sp {apply*test-result*query*failure*failure
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry2>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status failure)
    (<e-result> ^success
                ^retrieved <retrieved>)
    (<retrieved> ^observing <observed>)
    (<entry2> ^id <observed>
              ^name <entry2-name>
              ^scientific-name <entry2-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - query failure| (crlf))
    (write |  result - | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*failure
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry1>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status success
          ^expected <expected>)
    (<e-result> ^failure)
    (<entry1> ^id <expected>
              ^name <entry1-name>
              ^scientific-name <entry1-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting - | <entry1-name> | (| <entry1-s-name> |)| (crlf))
    (write |  result - query failure| (crlf))
}
sp {apply*test-result*query*success*success
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status success
          ^expected <expected>
          ^score <score>)
    (<e-result> ^retrieved <retrieved>
                ^match-score <score>)
    (<retrieved> ^observing <expected>)
    (<entry> ^id <expected>
             ^name <entry-name>
             ^scientific-name <entry-s-name>)
-->
    (<s> ^result success
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting (| <score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
    (write |  result (| <score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*wrong*retrieval
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry1>
          ^entry <entry2>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status success
          ^expected <expected>
          ^score <exp-score>)
    (<e-result> ^retrieved <retrieved>
                ^match-score <obs-score>)
    (<retrieved> ^observing {<observed> <> <expected>})
    (<entry1> ^id <expected>
              ^name <entry1-name>
              ^scientific-name <entry1-s-name>)
    (<entry2> ^id <observed>
              ^name <entry2-name>
              ^scientific-name <entry2-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting (| <exp-score> |) = | <entry1-name> | (| <entry1-s-name> |)| (crlf))
    (write |  result (| <obs-score> |) = | <entry2-name> | (| <entry2-s-name> |)| (crlf))
}
sp {apply*test-result*query*success*wrong*score
    (state <s> ^operator <op>
               ^tests <ts>
               ^epmem <epmem>
               ^entries <es>)
    (<ts> ^test <t>)
    (<epmem> ^result <e-result>)
    (<es> ^entry <entry>)
    (<op> ^name test-result
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^step <st>)
    (<st> ^id <step>
          ^type query
          ^status success
          ^expected <expected>
          ^score <exp-score>)
    (<e-result> ^retrieved <retrieved>
                ^match-score {<obs-score> <> <exp-score>})
    (<retrieved> ^observing <expected>)
    (<entry> ^id <expected>
             ^name <entry-name>
             ^scientific-name <entry-s-name>)
-->
    (<s> ^result failure
         ^sub-phase result -
         ^sub-phase notify)
    (write |  expecting (| <exp-score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
    (write |  result (| <obs-score> |) = | <entry-name> | (| <entry-s-name> |)| (crlf))
}
sp {kb*propose*test-next
    (state <s> ^name kb
               ^phase test
               ^sub-phase cue
               ^step <step>
               ^max-tests <max>
               ^current-test {<c> <= <max>}
               ^tests <ts>)
    (<ts> ^test <t>)
    (<t> ^id <c>
         ^steps {< <step>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name test-next
          ^test <c>
          ^step <step>)
}
sp {apply*test-next
    (state <s> ^operator <op>
               ^tests <ts>)
    (<ts> ^test <t>)
    (<op> ^name test-next
          ^test <c>
          ^step <step>)
    (<t> ^id <c>
         ^name <t-name>)
-->
    (<s> ^sub-phase cue -
         ^sub-phase init
         ^step <step> -
         ^current-test <c> -
         ^current-test (+ <c> 1))
    (write (crlf) |Test (| <c> |) "| <t-name> |" - complete| (crlf) | |)
}
sp {kb*elaborate*observing
    (state <s> ^name kb
               ^observing <c>
               ^entries <es>)
    (<es> ^entry <e>)
    (<e> ^id <c>)
-->
    (<s> ^observing-entry <e>)
}
sp {kb*propose*load
    (state <s> ^name kb
               ^phase load
               ^max-entries <max>
               ^current-entry {<c> <= <max>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name load
          ^entry <c>)
}
sp {apply*load*observe
    (state <s> ^operator <op>
               ^entries <es>)
    (<es> ^entry <e>)
    (<e> ^id <c>
         ^name <name>
         ^scientific-name <s-name>)
    (<op> ^name load
          ^entry <c>)
-->
    (<s> ^observing <c>)
    (write |Observing (| <c> |): | <name> | (| <s-name> |)| (crlf))
    (cmd epmem --set trigger dc)
}
sp {apply*load*remove
    (state <s> ^operator <op>
               ^observing {<o> <> <c>})
    (<op> ^name load
          ^entry <c>)
-->
    (<s> ^observing <o> -)
}
sp {apply*load*increment
    (state <s> ^operator <op>)
    (<op> ^name load
          ^entry <c>)
-->
    (<s> ^current-entry <c> -
         ^current-entry (+ <c> 1))
}
watch 0
epmem --set learning on
epmem --set balance 1
epmem --set trigger none
watch --epmem
sp {elaborate*top-state*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)
}
sp {elaborate*state*name
    (state <s> ^superstate.operator.name <name>)
-->
    (<s> ^name <name>)
}
sp {elaborate*state*top-state
    (state <s> ^superstate.top-state <ts>)
-->
    (<s> ^top-state <ts>)
}
sp {process-column*elaborate*arithmetic-problem
    (state <s> ^name
               ^superstate.arithmetic-problem <ap>)
-->
    (<s> ^arithmetic-problem <ap>)
}
sp {process-column*elaborate*arithmetic-facts
    (state <s> ^name
               ^superstate.arithmetic <a>)
-->
    (<s> ^arithmetic <a>)
}
sp {process-column*elaborate*current-column
    (state <s> ^name <> compute-result
               ^superstate.arithmetic-problem <ap>)
    (<ap> ^current-column <cc>)
-->
    (<s> ^current-column <cc>)
}
sp {arithmetic*elaborate*state*top-number*one-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit1 <d1>
          ^next-column nil)
-->
 #  (write (crlf) |Top Number: | <d1>)
    (<ap> ^top-number <d1>)
}
sp {arithmetic*elaborate*state*bottom-number*one-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit2 <d1>
          ^next-column nil)
-->
 #  (write (crlf) |Bottom Number: | <d1>)
    (<ap> ^bottom-number <d1>)
}
sp {arithmetic*elaborate*state*result-number*one-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^result <d1>
          ^next-column nil)
-->
 # (write (crlf) |Result Number: | <d1>)
    (<ap> ^result-number <d1>)
}
sp {arithmetic*elaborate*state*top-number*two-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit1 <d1>
          ^next-column <tc>)
    (<tc> ^digit1 <d2>
          ^next-column nil)
-->
    (<ap> ^top-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*two-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit2 <d1>
          ^next-column <tc>)
    (<tc> ^digit2 <d2>
          ^next-column nil)
-->
 # (write (crlf) |Bottom Number: |  (+ (* 10 <d2>) <d1>))
    (<ap> ^bottom-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*two-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^result <d1>
          ^next-column <tc>)
    (<tc> ^result <d2>
          ^next-column nil)
-->
 #  (write (crlf) |Result Number: |  (+ (* 10 <d2>) <d1>))
    (<ap> ^result-number (+ (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*top-number*three-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit1 <d1>
          ^next-column <tc>)
    (<tc> ^digit1 <d2>
          ^next-column <hc>)
    (<hc> ^digit1 <d3>
          ^next-column nil)
-->
 #  (write (crlf) |Top Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
    (<ap> ^top-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*three-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit2 <d1>
          ^next-column <tc>)
    (<tc> ^digit2 <d2>
          ^next-column <hc>)
    (<hc> ^digit2 <d3>
          ^next-column nil)
-->
 # (write (crlf) |Bottom Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
    (<ap> ^bottom-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*three-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^result <d1>
          ^next-column <tc>)
    (<tc> ^result <d2>
          ^next-column <hc>)
    (<hc> ^result <d3>
          ^next-column nil)
-->
 #  (write (crlf) |Result Number: |  (+ (* 100 <d3>) (* 10 <d2>) <d1>))
    (<ap> ^result-number (+ (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*top-number*four-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit1 <d1>
          ^next-column <tc>)
    (<tc> ^digit1 <d2>
          ^next-column <hc>)
    (<hc> ^digit1 <d3>
          ^next-column <thc>)
    (<thc> ^digit1 <d4>
           ^next-column nil)
-->
 # (write (crlf) |Top Number: |  (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
    (<ap> ^top-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*bottom-number*four-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^digit2 <d1>
          ^next-column <tc>)
    (<tc> ^digit2 <d2>
          ^next-column <hc>)
    (<hc> ^digit2 <d3>
          ^next-column <thc>)
    (<thc> ^digit2 <d4>
           ^next-column nil)
-->
    (<ap> ^bottom-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*result-number*four-column
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^one-column <oc>)
    (<oc> ^result <d1>
          ^next-column <tc>)
    (<tc> ^result <d2>
          ^next-column <hc>)
    (<hc> ^result <d3>
          ^next-column <thc>)
    (<thc> ^result <d4>
           ^next-column nil)
-->
 # (write (crlf) |Result Number: |  (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
    (<ap> ^result-number (+ (* 1000 <d4>) (* 100 <d3>) (* 10 <d2>) <d1>))
}
sp {arithmetic*elaborate*state*compute-answer*add
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^top-number <tn>
          ^bottom-number <bn>
          ^operation addition)
-->
    (<ap> ^computed-result (+ <tn> <bn>))
    #  (write (crlf) |Computed Addition Result : | (+ <tn> <bn>))
}
sp {arithmetic*elaborate*state*compute-answer*sub
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^top-number <tn>
          ^bottom-number <bn>
          ^operation subtraction)
-->
    (<ap> ^computed-result (- <tn> <bn>))
    #  (write (crlf) |Computed Subtraction Result : | (- <tn> <bn>))
}
sp {arithmetic*elaborate*state*compare-results*not-equal
    (state <s> ^name arithmetic
               ^superstate nil
               ^arithmetic-problem <ap>)
    (<ap> ^computed-result <cr>
          ^top-number <tn>
          ^bottom-number <bn>
          ^operation-symbol <os>
          ^result-number { <> <cr> <rn>})
-->
    (write (crlf) |***************************Results Incorrect: | <tn> | | <os> | | <bn> | = | <cr> | <> | <rn> | Diff | (- <cr> <rn>))
    (halt)
}
sp {get-digit1*propose*compute-result
    (state <s> ^name get-digit1
               ^digit1 <a1>
               ^digit2 <a2>
              -^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name compute-result)
}
sp {get-digit1*elaborate*state
    (state <s> ^name get-digit1
               ^superstate.current-column <c>)
    (<c> ^digit1 <a>
         ^carry-borrow <cb>)
-->
    (<s> ^digit1 <a>
         ^digit2 <cb>)
}
sp {process-column*propose*write-digit1
    (state <s> ^name get-digit1
               ^result <a>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name write-digit1)
}
sp {process-column*apply*write-digit1-carry1
    (state <s> ^operator.name write-digit1
               ^result <a>
               ^carry-borrow 1
               ^superstate <ss>)
-->
    (<ss> ^digit1 <a>
          ^carry-borrow 1)
}
sp {process-column*apply*write-digit1*carry0
    (state <s> ^operator.name write-digit1
               ^result <a>
               ^carry-borrow 0
               ^superstate <ss>)
-->
    (<ss> ^digit1 <a>)
}
sp {process-column*propose*get-digit2
    (state <s> ^name process-column
              -^digit2)
-->
    (<s> ^operator <op> + =)
    (<op> ^name get-digit2)
}
sp {process-column*apply*get-digit2
    (state <s> ^operator.name get-digit2
               ^current-column.digit2 <a>)
-->
    (<s> ^digit2 <a>)
}
sp {process-column*propose*compute-result
    (state <s> ^name process-column
               ^digit1 <a1>
               ^digit2 <a2>
              -^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name compute-result)
}
sp {process-column*apply*compute-result*query*add
    (state <s> ^operator.name compute-result
               ^arithmetic-problem.operation <op>
               ^digit1 <a1>
               ^digit2 <a2>)
-->
    (<s> ^query <q>)
    (<q> ^digit1 <a1>
         ^digit2 <a2>
         ^operation <op>)
}
sp {process-column*apply*compute-result*query*add*smem
    (state <s> ^operator.name compute-result
               ^arithmetic-problem.operation addition
               ^digit1 <a1>
               ^digit2 <a2>
               ^smem.command <cmd>
               ^top-state.fact-source smem)
-->
    (<cmd> ^query <q>)
    (<q> ^digit1 <a1>
         ^digit2 <a2>
         ^sum <sum>
         ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*clean-query*add
    (state <s> ^operator.name compute-result
               ^digit1 <a1>
               ^digit2 <a2>
               ^arithmetic-problem.operation addition
               ^smem.command <cmd>)
    (<cmd> ^query <q>)
   -(<q> ^digit1 <a1>
         ^digit2 <a2>)
-->
    (<cmd> ^query <q> -)
}
sp {process-column*apply*compute-result*addition*retrieval*wm
    (state <s> ^query <q>
               ^arithmetic.facts <af>
               ^top-state.fact-source wm)
    (<q> ^operation addition
         ^digit1 <d1>
         ^digit2 <d2>)
    (<af> ^digit1 <d1>
          ^digit2 <d2>
          ^sum <sum>
          ^carry-borrow <cb>)
-->
    (<q> ^sum <sum>
         ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*addition*retrieval*smem
    (state <s> ^query <q>
               ^smem.result.retrieved <af>
               ^top-state.fact-source smem)
    (<q> ^operation addition
         ^digit1 <d1>
         ^digit2 <d2>)
    (<af> ^digit1 <d1>
          ^digit2 <d2>
          ^sum <sum>
          ^carry-borrow <cb>)
-->
    (<q> ^sum <sum>
         ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*use*wm
    (state <s> ^operator.name compute-result
               ^digit1 <d1>
               ^digit2 <d2>
               ^query <q>
               ^top-state.fact-source wm)
    (<q> ^digit1 <d1>
         ^digit2 <d2>
         ^sum <sum>
         ^carry-borrow <cb>)
-->
    (<s> ^result <sum>
         ^carry-borrow <cb>)
}
sp {process-column*apply*compute-result*use*smem
    (state <s> ^operator.name compute-result
               ^digit1 <d1>
               ^digit2 <d2>
               ^query <q>
               ^top-state.fact-source smem
               ^smem.command <cmd>)
    (<q> ^digit1 <d1>
         ^digit2 <d2>
         ^sum <sum>
         ^carry-borrow <cb>)
    (<cmd> ^query <smem-q>)
-->
    (<s> ^result <sum>
         ^carry-borrow <cb>)
    (<cmd> ^query <smem-q> -)
}
sp {process-column*apply*compute-result*subtraction*wm
    (state <s> ^operator.name compute-result
               ^arithmetic.subtraction-facts <af>
               ^arithmetic-problem.operation subtraction
               ^digit1 <a1>
               ^digit2 <a2>
               ^top-state.fact-source wm)
    (<af> ^digit1 <a1>
          ^digit2 <a2>
          ^result <result>)
-->
    (<s> ^result <result>)
}
sp {process-column*apply*compute-result*clean-query*subtract
    (state <s> ^operator.name compute-result
               ^digit1 <a1>
               ^digit2 <a2>
               ^arithmetic-problem.operation subtraction
               ^smem.command <cmd>)
    (<cmd> ^query <q>)
   -(<q> ^digit1 <a1>
         ^digit2 <a2>)
-->
    (<cmd> ^query <q> -)
}
sp {process-column*apply*compute-result*query*subtract*smem
    (state <s> ^operator.name compute-result
               ^arithmetic-problem.operation subtraction
               ^digit1 <a1>
               ^digit2 <a2>
               ^smem.command <cmd>
               ^top-state.fact-source smem)
-->
    (<cmd> ^query <q>)
    (<q> ^digit1 <a1>
         ^digit2 <a2>
         ^result <result>)
}
sp {process-column*apply*compute-result*subtraction*smem
    (state <s> ^operator.name compute-result
               ^smem <smem>
               ^arithmetic-problem.operation subtraction
               ^digit1 <a1>
               ^digit2 <a2>
               ^top-state.fact-source smem)
    (<af> ^digit1 <a1>
          ^digit2 <a2>
          ^result <result>)
    (<smem> ^result.retrieved <af>
            ^command <cmd>)
    (<cmd> ^query <smem-q>)
-->
    (<s> ^result <result>)
    (<cmd> ^query <smem-q> -)
}
sp {process-column*propose*write-result
    (state <s> ^name process-column
               ^result <a>
              -^carry-borrow 1
              -^current-column.result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name write-result)
}
sp {process-column*propose*write-result2
    (state <s> ^name process-column
               ^result <a>
               ^carry-borrow 1
               ^current-column <cc>)
    (<cc> ^next-column.carry-borrow
         -^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name write-result)
}
sp {process-column*apply*write-result
    (state <s> ^operator.name write-result
               ^result <a>
               ^current-column <cc>)
-->
    (<cc> ^result <a>)
}
sp {carry-borrow*propose*new-column
    (state <s> ^name carry-borrow
               ^current-column.next-column nil)
-->
    (<s> ^operator.name new-column)}
sp {carry-borrow*apply*new-column
    (state <s> ^operator.name new-column
               ^current-column <cc>)
-->
    (<cc> ^next-column <nc>
                      nil -)
    (<nc> ^digit1 0
          ^digit2 0
          ^column t
          ^next-column nil)
}
sp {process-column*propose*get-digit1
    (state <s> ^name process-column
              -^digit1)
-->
    (<s> ^operator <op> + =)
    (<op> ^name get-digit1)
}
sp {process-column*apply*get-digit1
    (state <s> ^operator.name get-digit1
               ^current-column <cc>)
    (<cc> ^digit1 <a>
         -^new-digit1
         -^carry-borrow 1)
-->
    (<s> ^digit1 <a>)
}
sp {process-column*apply*get-digit1-new
    (state <s> ^operator.name get-digit1
               ^current-column <cc>)
    (<cc> ^digit1
          ^new-digit1 <a>
         -^carry-borrow 1)
-->
    (<s> ^digit1 <a>)
}
sp {process-column*propose*carry-borrow
    (state <s> ^name << process-column get-digit1 >>
               ^carry-borrow 1
               ^current-column.next-column <nc>)
    (<nc> -^carry-borrow)
-->
    (<s> ^operator <op> + =)
    (<op> ^name carry-borrow)
}
sp {process-column*apply*carry-borrow
    (state <s> ^operator.name carry-borrow
               ^carry-borrow 1
               ^current-column.next-column <nc>)
    (<nc> ^column t)
-->
    (<nc> ^carry-borrow 1)
}
sp {process-column*compare*carry-borrow
    (state <s> ^name process-column
               ^operator <op1> +
                        <op2> +)
    (<op1> ^name carry-borrow)
    (<op2> ^name write-result)
-->
    (<s> ^operator <op1> > <op2>)
}
sp {compute-result*propose*add-ten
    (state <s> ^name compute-result
               ^current-column.new-digit1 <r>
               ^result <r>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name add-ten)
}
sp {compute-result*apply*add-ten*wm
    (state <s> ^operator <op>
               ^arithmetic.add10-facts <af>
               ^superstate <ss>
               ^top-state.fact-source wm)
    (<ss> ^digit1 <d>)
    (<af> ^digit1 <d>
          ^digit-10 <d10>)
    (<op> ^name add-ten)
-->
    (<ss> ^digit1 <d> -
                 <d10>)
}
sp {compute-result*apply*add-ten*smem*query
    (state <s> ^operator <op>
               ^smem.command <cmd>
               ^superstate <ss>
               ^top-state.fact-source smem)
    (<ss> ^digit1 <d>)
    (<op> ^name add-ten)
-->
    (<cmd> ^query <q>)
    (<q> ^digit1 <d>
         ^digit-10 <d10>)
}
sp {compute-result*apply*add-ten*smem*result
    (state <s> ^operator <op>
               ^smem.result.retrieved <af>
               ^superstate <ss>
               ^top-state.fact-source smem)
    (<ss> ^digit1 <d>)
    (<af> ^digit1 <d>
          ^digit-10 <d10>)
    (<op> ^name add-ten)
-->
    (<ss> ^digit1 <d> -
                 <d10>)
}
sp {compute-result*propose*compute-result
    (state <s> ^name compute-result
               ^digit1 <a1>
               ^digit2 <a2>
              -^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name compute-result)
}
sp {compute-result*elaborate*substate
    (state <s> ^name compute-result
               ^superstate.current-column <cc>)
    (<cc> ^next-column <nc>)
    (<nc> ^digit1 <d1>)
-->
    (<s> ^current-column <nc>
         ^digit1 <d1>
         ^digit2 1)
}
sp {compute-result*propose*borrow
    (state <s> ^name compute-result
              -^current-column.new-digit1 <r>
               ^result <r>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name borrow)
}
sp {compute-result*apply*borrow
    (state <s> ^operator <op>
               ^result <r>
               ^current-column <cc>)
    (<cc> ^digit1 <d1>)
    (<op> ^name borrow)
-->
    (<cc> ^new-digit1 <r>)
}
sp {arithmetic*propose*next-column
    (state <s> ^name arithmetic
               ^arithmetic-problem.current-column <c>)
    (<c> ^result
         ^next-column <nc>)
    (<nc> ^column t)
-->
    (<s> ^operator <op> + =)
    (<op> ^name next-column)
}
sp {arithmetic*apply*next-column
    (state <s> ^operator.name next-column
               ^arithmetic-problem <ap>)
    (<ap> ^current-column <c>)
    (<c> ^next-column <nc>)
-->
    (<ap> ^current-column <c> -
                         <nc>)
}
sp {arithmetic*propose*generate-facts
    (state <s> ^name arithmetic
              -^arithmetic.facts)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name generate-facts)
}
sp {arithmetic*apply*generate-facts*smem
    (state <s> ^operator.name generate-facts
               ^fact-source smem)
-->
    (<s> ^arithmetic.facts preloaded)
}
sp {arithmetic*apply*generate-facts*add*sub
    (state <s> ^operator.name generate-facts
               ^fact-source wm)
-->
    (<s> ^arithmetic.facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
    (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
    (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
    (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
    (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
    (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
    (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
    (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
    (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
    (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
    (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
    (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
    (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
    (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
    (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
    (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
    (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
    (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
    (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
    (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
    (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
    (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
    (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
    (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
    (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
    (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
    (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
    (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
    (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
    (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
    (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
    (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
    (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
    (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
    (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
    (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
    (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
    (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
    (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
    (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
    (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
    (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
    (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
    (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
    (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
    (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
    (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
    (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
    (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
    (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
    (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
    (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
    (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
    (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
    (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
    (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
    (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
    (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
    (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
    (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
    (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
    (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
    (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
    (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
    (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
    (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
    (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
    (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
    (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
    (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
    (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
    (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
    (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
    (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
    (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
    (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
    (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
    (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
    (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
    (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
    (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
    (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
    (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
    (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
    (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
    (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
    (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
    (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
    (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
    (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
    (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
    (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
    (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
    (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
    (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
    (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
    (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
    (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
    (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
    (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
sp {arithmetic*apply*generate-facts*sub
    (state <s> ^operator.name generate-facts
               ^fact-source wm)
-->
    (<s> ^arithmetic.subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^result 0)
    (<a01> ^digit1 10 ^digit2 1 ^result 9)
    (<a02> ^digit1 10 ^digit2 2 ^result 8)
    (<a03> ^digit1 10 ^digit2 3 ^result 7)
    (<a04> ^digit1 10 ^digit2 4 ^result 6)
    (<a05> ^digit1 10 ^digit2 5 ^result 5)
    (<a06> ^digit1 10 ^digit2 6 ^result 4)
    (<a07> ^digit1 10 ^digit2 7 ^result 3)
    (<a08> ^digit1 10 ^digit2 8 ^result 2)
    (<a09> ^digit1 10 ^digit2 9 ^result 1)
    (<a10> ^digit1 1 ^digit2 0 ^result 1)
    (<a11> ^digit1 1 ^digit2 1 ^result 0)
    (<a12> ^digit1 11 ^digit2 2 ^result 9)
    (<a13> ^digit1 11 ^digit2 3 ^result 8)
    (<a14> ^digit1 11 ^digit2 4 ^result 7)
    (<a15> ^digit1 11 ^digit2 5 ^result 6)
    (<a16> ^digit1 11 ^digit2 6 ^result 5)
    (<a17> ^digit1 11 ^digit2 7 ^result 4)
    (<a18> ^digit1 11 ^digit2 8 ^result 3)
    (<a19> ^digit1 11 ^digit2 9 ^result 2)
    (<a20> ^digit1 2 ^digit2 0 ^result 2)
    (<a21> ^digit1 2 ^digit2 1 ^result 1)
    (<a22> ^digit1 2 ^digit2 2 ^result 0)
    (<a23> ^digit1 12 ^digit2 3 ^result 9)
    (<a24> ^digit1 12 ^digit2 4 ^result 8)
    (<a25> ^digit1 12 ^digit2 5 ^result 7)
    (<a26> ^digit1 12 ^digit2 6 ^result 6)
    (<a27> ^digit1 12 ^digit2 7 ^result 5)
    (<a28> ^digit1 12 ^digit2 8 ^result 4)
    (<a29> ^digit1 12 ^digit2 9 ^result 3)
    (<a30> ^digit1 3 ^digit2 0 ^result 3)
    (<a31> ^digit1 3 ^digit2 1 ^result 2)
    (<a32> ^digit1 3 ^digit2 2 ^result 1)
    (<a33> ^digit1 3 ^digit2 3 ^result 0)
    (<a34> ^digit1 13 ^digit2 4 ^result 9)
    (<a35> ^digit1 13 ^digit2 5 ^result 8)
    (<a36> ^digit1 13 ^digit2 6 ^result 7)
    (<a37> ^digit1 13 ^digit2 7 ^result 6)
    (<a38> ^digit1 13 ^digit2 8 ^result 5)
    (<a39> ^digit1 13 ^digit2 9 ^result 4)
    (<a40> ^digit1 4 ^digit2 0 ^result 4)
    (<a41> ^digit1 4 ^digit2 1 ^result 3)
    (<a42> ^digit1 4 ^digit2 2 ^result 2)
    (<a43> ^digit1 4 ^digit2 3 ^result 1)
    (<a44> ^digit1 4 ^digit2 4 ^result 0)
    (<a45> ^digit1 14 ^digit2 5 ^result 9)
    (<a46> ^digit1 14 ^digit2 6 ^result 8)
    (<a47> ^digit1 14 ^digit2 7 ^result 7)
    (<a48> ^digit1 14 ^digit2 8 ^result 6)
    (<a49> ^digit1 14 ^digit2 9 ^result 5)
    (<a50> ^digit1 5 ^digit2 0 ^result 5)
    (<a51> ^digit1 5 ^digit2 1 ^result 4)
    (<a52> ^digit1 5 ^digit2 2 ^result 3)
    (<a53> ^digit1 5 ^digit2 3 ^result 2)
    (<a54> ^digit1 5 ^digit2 4 ^result 1)
    (<a55> ^digit1 5 ^digit2 5 ^result 0)
    (<a56> ^digit1 15 ^digit2 6 ^result 9)
    (<a57> ^digit1 15 ^digit2 7 ^result 8)
    (<a58> ^digit1 15 ^digit2 8 ^result 7)
    (<a59> ^digit1 15 ^digit2 9 ^result 6)
    (<a60> ^digit1 6 ^digit2 0 ^result 6)
    (<a61> ^digit1 6 ^digit2 1 ^result 5)
    (<a62> ^digit1 6 ^digit2 2 ^result 4)
    (<a63> ^digit1 6 ^digit2 3 ^result 3)
    (<a64> ^digit1 6 ^digit2 4 ^result 2)
    (<a65> ^digit1 6 ^digit2 5 ^result 1)
    (<a66> ^digit1 6 ^digit2 6 ^result 0)
    (<a67> ^digit1 16 ^digit2 7 ^result 9)
    (<a68> ^digit1 16 ^digit2 8 ^result 8)
    (<a69> ^digit1 16 ^digit2 9 ^result 7)
    (<a70> ^digit1 7 ^digit2 0 ^result 7)
    (<a71> ^digit1 7 ^digit2 1 ^result 6)
    (<a72> ^digit1 7 ^digit2 2 ^result 5)
    (<a73> ^digit1 7 ^digit2 3 ^result 4)
    (<a74> ^digit1 7 ^digit2 4 ^result 3)
    (<a75> ^digit1 7 ^digit2 5 ^result 2)
    (<a76> ^digit1 7 ^digit2 6 ^result 1)
    (<a77> ^digit1 7 ^digit2 7 ^result 0)
    (<a78> ^digit1 17 ^digit2 8 ^result 9)
    (<a79> ^digit1 17 ^digit2 9 ^result 8)
    (<a80> ^digit1 8 ^digit2 0 ^result 8)
    (<a81> ^digit1 8 ^digit2 1 ^result 7)
    (<a82> ^digit1 8 ^digit2 2 ^result 6)
    (<a83> ^digit1 8 ^digit2 3 ^result 5)
    (<a84> ^digit1 8 ^digit2 4 ^result 4)
    (<a85> ^digit1 8 ^digit2 5 ^result 3)
    (<a86> ^digit1 8 ^digit2 6 ^result 2)
    (<a87> ^digit1 8 ^digit2 7 ^result 1)
    (<a88> ^digit1 8 ^digit2 8 ^result 0)
    (<a89> ^digit1 18 ^digit2 9 ^result 9)
    (<a90> ^digit1 9 ^digit2 0 ^result 9)
    (<a91> ^digit1 9 ^digit2 1 ^result 8)
    (<a92> ^digit1 9 ^digit2 2 ^result 7)
    (<a93> ^digit1 9 ^digit2 3 ^result 6)
    (<a94> ^digit1 9 ^digit2 4 ^result 5)
    (<a95> ^digit1 9 ^digit2 5 ^result 4)
    (<a96> ^digit1 9 ^digit2 6 ^result 3)
    (<a97> ^digit1 9 ^digit2 7 ^result 2)
    (<a98> ^digit1 9 ^digit2 8 ^result 1)
    (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
sp {arithmetic*apply*generate-facts*add10
    (state <s> ^operator.name generate-facts
               ^fact-source wm)
-->
    (<s> ^arithmetic.add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
    (<a00> ^digit1 0 ^digit-10 10)
    (<a01> ^digit1 1 ^digit-10 11)
    (<a02> ^digit1 2 ^digit-10 12)
    (<a03> ^digit1 3 ^digit-10 13)
    (<a04> ^digit1 4 ^digit-10 14)
    (<a05> ^digit1 5 ^digit-10 15)
    (<a06> ^digit1 6 ^digit-10 16)
    (<a07> ^digit1 7 ^digit-10 17)
    (<a08> ^digit1 8 ^digit-10 18)
    (<a09> ^digit1 9 ^digit-10 19)
}
sp {arithmetic*propose*stop-arithmetic
    (state <s> ^name arithmetic
               ^count 0)
-->
    (<s> ^operator <op> + =)
    (<op> ^name stop-arithmetic)
}
sp {arithmetic*apply*stop-arithmetic
    (state <s> ^operator <op>)
    (<op> ^name stop-arithmetic)
-->
    (write |Finished|)
    (halt)
}
sp {generate-problem*propose*generate-digit2
    (state <s> ^name generate-problem
               ^digits <d>
               ^current-column  { <> nil <cc> })
    (<cc> -^digit2
           ^digit1)
-->
    (<s> ^operator <op> + =)
    (<op> ^name generate-digit2
          ^digit2 <d>)
}
sp {generate-problem*compare*generate-digit2
    (state <s> ^name generate-problem
               ^current-column <cc>
               ^problem.operation subtraction
               ^operator <op1> +)
    (<op1> ^name generate-digit2
           ^digit2 >= <d>)
    (<cc> ^digit1 <d>
          ^next-column nil)
-->
    (<s> ^operator <op1> <)
}
sp {generate-problem*apply*generate-digit2
    (state <s> ^operator <op>
               ^current-column <c1>)
    (<op> ^name generate-digit2
          ^digit2 <d>)
-->
    (<c1> ^digit2 <d>)
}
sp {generate-problem*propose*next-column
    (state <s> ^name generate-problem
               ^current-column <c1>)
    (<c1> ^digit1
          ^digit2
          ^next-column <x>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name next-column)
}
sp {generate-problem*apply*next-column
    (state <s> ^operator <op>
               ^current-column <cc>)
    (<op> ^name next-column)
    (<cc> ^next-column <nc>)
-->
    (<s> ^current-column <cc> -
                        <nc>)
}
sp {generate-problem*propose*generate-operation-add
    (state <s> ^quiescence t
               ^name generate-problem
              -^problem)
-->
    (<s> ^operator <op> + =)
    (<op> ^name generate-operation
          ^operation addition
          ^operation-symbol |+|)
}
sp {generate-problem*propose*generate-operation-sub
    (state <s> ^quiescence t
               ^name generate-problem
              -^problem)
-->
    (<s> ^operator <op> + =)
    (<op> ^name generate-operation
          ^operation subtraction
          ^operation-symbol |-|)
}
sp {generate-problem*apply*generate-operation
    (state <s> ^operator <op>)
    (<op> ^name generate-operation
          ^operation <oper>
          ^operation-symbol <os>)
-->
    (<s> ^digits 0 1 2 3 4 5 6 7 8 9
         ^problem <p>
         ^current-column <c1>)
    (<p> ^operation <oper>
         ^operation-symbol <os>
         ^current-column <c1>
         ^one-column <c1>)
    (<c1> ^next-column <c2>
          ^column t)
    (<c2> ^next-column <c3>
          ^column t)
    (<c3> ^next-column nil
          ^column t)}
sp {generate-problem*propose*finish-problem-generation
    (state <s> ^name generate-problem
               ^current-column nil)
-->
    (<s> ^operator <op> + =)
    (<op> ^name finish-problem-generation)
}
sp {generate-problem*apply*finish-problem-generation
    (state <s> ^operator <op>
               ^superstate <ss>
               ^problem <p>)
    (<op> ^name finish-problem-generation)
-->
    (<ss> ^arithmetic-problem <p>)
}
sp {generate-problem*propose*generate-digit1
    (state <s> ^name generate-problem
               ^digits <d>
               ^current-column { <> nil <cc> })
    (<cc> -^digit1)
-->
    (<s> ^operator <op> + =)
    (<op> ^name generate-digit1
          ^digit1 <d>)
}
sp {generate-problem*compare*generate-digit1
    (state <s> ^name generate-problem
               ^current-column <cc>
               ^problem.operation subtraction
               ^operator <op1> +)
    (<op1> ^name generate-digit1
           ^digit1 0)
    (<cc> ^next-column nil)
-->
    (<s> ^operator <op1> -)
}
sp {generate-problem*apply*generate-digit1
    (state <s> ^operator <op>
               ^current-column <c1>)
    (<op> ^name generate-digit1
          ^digit1 <d>)
-->
    (<c1> ^digit1 <d>)
}
sp {arithmetic*propose*initialize-arithmetic
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-arithmetic)
}
sp {arithmetic*apply*initialize-arithmetic
    (state <s> ^operator.name initialize-arithmetic)
-->
    (<s> ^name arithmetic
         ^fact-source smem
         ^output yes
         ^count 1000)}
sp {arithmetic*propose*generate-problem
    (state <s> ^name arithmetic
              -^arithmetic-problem
              -^count 0)
-->
    (<s> ^operator <op> + =)
    (<op> ^name generate-problem)
}
sp {arithmetic*propose*finish-problem
    (state <s> ^name arithmetic
               ^count <count>
               ^arithmetic-problem.current-column <c>)
    (<c> ^result
         ^next-column nil)
-->
    (<s> ^operator <op> + =)
    (<op> ^name finish-problem
          ^count <count>)
}
sp {arithmetic*apply*finish-problem*decrement-count
    (state <s> ^name arithmetic
               ^operator <o>
               ^arithmetic-problem <ap>
               ^count <c>)
    (<o>  ^name finish-problem
          ^count <c>)
-->
    (<s> ^arithmetic-problem <ap> -
         ^count <c> -
    (- <c> 1))
}
sp {generate-facts*propose*clean
    (state <s> ^name generate-facts
               ^phase clean)
-->
    (<s> ^operator <op> + =)
    (<op> ^name clean)
}
sp {apply*clean
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name clean)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^arithmetic.facts new)
}
sp {generate-facts*propose*store
    (state <s> ^name generate-facts
               ^phase store)
-->
    (<s> ^operator <op> + =)
    (<op> ^name store)
}
sp {apply*store
    (state <s> ^operator <op>)
    (<op> ^name store)
-->
    (<s> ^phase store -
         ^phase clean)
}
sp {arithmetic*apply*store*add
    (state <s> ^operator.name store
               ^smem.command <cmd>)
    (<cmd> ^store <arithmetic>)
-->
    (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<arithmetic> ^facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
    (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
    (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
    (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
    (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
    (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
    (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
    (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
    (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
    (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
    (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
    (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
    (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
    (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
    (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
    (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
    (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
    (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
    (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
    (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
    (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
    (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
    (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
    (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
    (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
    (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
    (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
    (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
    (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
    (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
    (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
    (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
    (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
    (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
    (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
    (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
    (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
    (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
    (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
    (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
    (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
    (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
    (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
    (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
    (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
    (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
    (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
    (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
    (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
    (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
    (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
    (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
    (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
    (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
    (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
    (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
    (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
    (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
    (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
    (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
    (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
    (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
    (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
    (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
    (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
    (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
    (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
    (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
    (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
    (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
    (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
    (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
    (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
    (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
    (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
    (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
    (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
    (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
    (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
    (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
    (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
    (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
    (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
    (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
    (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
    (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
    (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
    (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
    (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
    (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
    (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
    (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
    (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
    (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
    (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
    (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
    (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
    (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
    (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
    (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
sp {arithmetic*apply*store*sub
    (state <s> ^operator.name store
               ^smem.command <cmd>)
    (<cmd> ^store <arithmetic>)
-->
    (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<arithmetic> ^subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^result 0)
    (<a01> ^digit1 10 ^digit2 1 ^result 9)
    (<a02> ^digit1 10 ^digit2 2 ^result 8)
    (<a03> ^digit1 10 ^digit2 3 ^result 7)
    (<a04> ^digit1 10 ^digit2 4 ^result 6)
    (<a05> ^digit1 10 ^digit2 5 ^result 5)
    (<a06> ^digit1 10 ^digit2 6 ^result 4)
    (<a07> ^digit1 10 ^digit2 7 ^result 3)
    (<a08> ^digit1 10 ^digit2 8 ^result 2)
    (<a09> ^digit1 10 ^digit2 9 ^result 1)
    (<a10> ^digit1 1 ^digit2 0 ^result 1)
    (<a11> ^digit1 1 ^digit2 1 ^result 0)
    (<a12> ^digit1 11 ^digit2 2 ^result 9)
    (<a13> ^digit1 11 ^digit2 3 ^result 8)
    (<a14> ^digit1 11 ^digit2 4 ^result 7)
    (<a15> ^digit1 11 ^digit2 5 ^result 6)
    (<a16> ^digit1 11 ^digit2 6 ^result 5)
    (<a17> ^digit1 11 ^digit2 7 ^result 4)
    (<a18> ^digit1 11 ^digit2 8 ^result 3)
    (<a19> ^digit1 11 ^digit2 9 ^result 2)
    (<a20> ^digit1 2 ^digit2 0 ^result 2)
    (<a21> ^digit1 2 ^digit2 1 ^result 1)
    (<a22> ^digit1 2 ^digit2 2 ^result 0)
    (<a23> ^digit1 12 ^digit2 3 ^result 9)
    (<a24> ^digit1 12 ^digit2 4 ^result 8)
    (<a25> ^digit1 12 ^digit2 5 ^result 7)
    (<a26> ^digit1 12 ^digit2 6 ^result 6)
    (<a27> ^digit1 12 ^digit2 7 ^result 5)
    (<a28> ^digit1 12 ^digit2 8 ^result 4)
    (<a29> ^digit1 12 ^digit2 9 ^result 3)
    (<a30> ^digit1 3 ^digit2 0 ^result 3)
    (<a31> ^digit1 3 ^digit2 1 ^result 2)
    (<a32> ^digit1 3 ^digit2 2 ^result 1)
    (<a33> ^digit1 3 ^digit2 3 ^result 0)
    (<a34> ^digit1 13 ^digit2 4 ^result 9)
    (<a35> ^digit1 13 ^digit2 5 ^result 8)
    (<a36> ^digit1 13 ^digit2 6 ^result 7)
    (<a37> ^digit1 13 ^digit2 7 ^result 6)
    (<a38> ^digit1 13 ^digit2 8 ^result 5)
    (<a39> ^digit1 13 ^digit2 9 ^result 4)
    (<a40> ^digit1 4 ^digit2 0 ^result 4)
    (<a41> ^digit1 4 ^digit2 1 ^result 3)
    (<a42> ^digit1 4 ^digit2 2 ^result 2)
    (<a43> ^digit1 4 ^digit2 3 ^result 1)
    (<a44> ^digit1 4 ^digit2 4 ^result 0)
    (<a45> ^digit1 14 ^digit2 5 ^result 9)
    (<a46> ^digit1 14 ^digit2 6 ^result 8)
    (<a47> ^digit1 14 ^digit2 7 ^result 7)
    (<a48> ^digit1 14 ^digit2 8 ^result 6)
    (<a49> ^digit1 14 ^digit2 9 ^result 5)
    (<a50> ^digit1 5 ^digit2 0 ^result 5)
    (<a51> ^digit1 5 ^digit2 1 ^result 4)
    (<a52> ^digit1 5 ^digit2 2 ^result 3)
    (<a53> ^digit1 5 ^digit2 3 ^result 2)
    (<a54> ^digit1 5 ^digit2 4 ^result 1)
    (<a55> ^digit1 5 ^digit2 5 ^result 0)
    (<a56> ^digit1 15 ^digit2 6 ^result 9)
    (<a57> ^digit1 15 ^digit2 7 ^result 8)
    (<a58> ^digit1 15 ^digit2 8 ^result 7)
    (<a59> ^digit1 15 ^digit2 9 ^result 6)
    (<a60> ^digit1 6 ^digit2 0 ^result 6)
    (<a61> ^digit1 6 ^digit2 1 ^result 5)
    (<a62> ^digit1 6 ^digit2 2 ^result 4)
    (<a63> ^digit1 6 ^digit2 3 ^result 3)
    (<a64> ^digit1 6 ^digit2 4 ^result 2)
    (<a65> ^digit1 6 ^digit2 5 ^result 1)
    (<a66> ^digit1 6 ^digit2 6 ^result 0)
    (<a67> ^digit1 16 ^digit2 7 ^result 9)
    (<a68> ^digit1 16 ^digit2 8 ^result 8)
    (<a69> ^digit1 16 ^digit2 9 ^result 7)
    (<a70> ^digit1 7 ^digit2 0 ^result 7)
    (<a71> ^digit1 7 ^digit2 1 ^result 6)
    (<a72> ^digit1 7 ^digit2 2 ^result 5)
    (<a73> ^digit1 7 ^digit2 3 ^result 4)
    (<a74> ^digit1 7 ^digit2 4 ^result 3)
    (<a75> ^digit1 7 ^digit2 5 ^result 2)
    (<a76> ^digit1 7 ^digit2 6 ^result 1)
    (<a77> ^digit1 7 ^digit2 7 ^result 0)
    (<a78> ^digit1 17 ^digit2 8 ^result 9)
    (<a79> ^digit1 17 ^digit2 9 ^result 8)
    (<a80> ^digit1 8 ^digit2 0 ^result 8)
    (<a81> ^digit1 8 ^digit2 1 ^result 7)
    (<a82> ^digit1 8 ^digit2 2 ^result 6)
    (<a83> ^digit1 8 ^digit2 3 ^result 5)
    (<a84> ^digit1 8 ^digit2 4 ^result 4)
    (<a85> ^digit1 8 ^digit2 5 ^result 3)
    (<a86> ^digit1 8 ^digit2 6 ^result 2)
    (<a87> ^digit1 8 ^digit2 7 ^result 1)
    (<a88> ^digit1 8 ^digit2 8 ^result 0)
    (<a89> ^digit1 18 ^digit2 9 ^result 9)
    (<a90> ^digit1 9 ^digit2 0 ^result 9)
    (<a91> ^digit1 9 ^digit2 1 ^result 8)
    (<a92> ^digit1 9 ^digit2 2 ^result 7)
    (<a93> ^digit1 9 ^digit2 3 ^result 6)
    (<a94> ^digit1 9 ^digit2 4 ^result 5)
    (<a95> ^digit1 9 ^digit2 5 ^result 4)
    (<a96> ^digit1 9 ^digit2 6 ^result 3)
    (<a97> ^digit1 9 ^digit2 7 ^result 2)
    (<a98> ^digit1 9 ^digit2 8 ^result 1)
    (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
sp {arithmetic*apply*store*add10
    (state <s> ^operator.name store
               ^smem.command <cmd>)
    (<cmd> ^store <arithmetic>)
-->
    (<cmd> ^store
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
    (<arithmetic> ^add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
    (<a00> ^digit1 0 ^digit-10 10)
    (<a01> ^digit1 1 ^digit-10 11)
    (<a02> ^digit1 2 ^digit-10 12)
    (<a03> ^digit1 3 ^digit-10 13)
    (<a04> ^digit1 4 ^digit-10 14)
    (<a05> ^digit1 5 ^digit-10 15)
    (<a06> ^digit1 6 ^digit-10 16)
    (<a07> ^digit1 7 ^digit-10 17)
    (<a08> ^digit1 8 ^digit-10 18)
    (<a09> ^digit1 9 ^digit-10 19)
}
sp {generate-facts*propose*init
    (state <s> ^name generate-facts
              -^phase)
-->
    (<s> ^operator <op> + =)
    (<op> ^name init)
}
sp {apply*init
    (state <s> ^operator <op>
               ^smem.command <cmd>)
    (<op> ^name init)
-->
    (<s> ^phase check)
    (<cmd> ^query.facts <fact>)
}
sp {generate-facts*propose*check
    (state <s> ^name generate-facts
               ^phase check)
-->
    (<s> ^operator <op> + =)
    (<op> ^name check)
}
sp {apply*check*new
    (state <s> ^operator <op>
               ^smem <smem>)
    (<op> ^name check)
    (<smem> ^result.failure <q>
            ^command <cmd>)
    (<cmd> ^query <q>)
-->
    (<s> ^phase check -
         ^phase store)
    (<cmd> ^query <q> -
           ^store <arithmetic>)
}
sp {apply*check*existing
    (state <s> ^operator <op>
               ^smem.result.success <q>
               ^superstate <ss>)
    (<op> ^name check)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^arithmetic.facts existing)
}
sp {arithmetic*propose*process-column
    (state <s> ^name arithmetic
               ^arithmetic-problem.current-column <cc>)
   -(<cc> ^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name process-column)
}
smem --set learning on
smem --add {
    (<arithmetic> ^facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^sum 0 ^carry-borrow 0)
    (<a01> ^digit1 0 ^digit2 1 ^sum 1 ^carry-borrow 0)
    (<a02> ^digit1 0 ^digit2 2 ^sum 2 ^carry-borrow 0)
    (<a03> ^digit1 0 ^digit2 3 ^sum 3 ^carry-borrow 0)
    (<a04> ^digit1 0 ^digit2 4 ^sum 4 ^carry-borrow 0)
    (<a05> ^digit1 0 ^digit2 5 ^sum 5 ^carry-borrow 0)
    (<a06> ^digit1 0 ^digit2 6 ^sum 6 ^carry-borrow 0)
    (<a07> ^digit1 0 ^digit2 7 ^sum 7 ^carry-borrow 0)
    (<a08> ^digit1 0 ^digit2 8 ^sum 8 ^carry-borrow 0)
    (<a09> ^digit1 0 ^digit2 9 ^sum 9 ^carry-borrow 0)
    (<a10> ^digit1 1 ^digit2 0 ^sum 1 ^carry-borrow 0)
    (<a11> ^digit1 1 ^digit2 1 ^sum 2 ^carry-borrow 0)
    (<a12> ^digit1 1 ^digit2 2 ^sum 3 ^carry-borrow 0)
    (<a13> ^digit1 1 ^digit2 3 ^sum 4 ^carry-borrow 0)
    (<a14> ^digit1 1 ^digit2 4 ^sum 5 ^carry-borrow 0)
    (<a15> ^digit1 1 ^digit2 5 ^sum 6 ^carry-borrow 0)
    (<a16> ^digit1 1 ^digit2 6 ^sum 7 ^carry-borrow 0)
    (<a17> ^digit1 1 ^digit2 7 ^sum 8 ^carry-borrow 0)
    (<a18> ^digit1 1 ^digit2 8 ^sum 9 ^carry-borrow 0)
    (<a19> ^digit1 1 ^digit2 9 ^sum 0 ^carry-borrow 1)
    (<a20> ^digit1 2 ^digit2 0 ^sum 2 ^carry-borrow 0)
    (<a21> ^digit1 2 ^digit2 1 ^sum 3 ^carry-borrow 0)
    (<a22> ^digit1 2 ^digit2 2 ^sum 4 ^carry-borrow 0)
    (<a23> ^digit1 2 ^digit2 3 ^sum 5 ^carry-borrow 0)
    (<a24> ^digit1 2 ^digit2 4 ^sum 6 ^carry-borrow 0)
    (<a25> ^digit1 2 ^digit2 5 ^sum 7 ^carry-borrow 0)
    (<a26> ^digit1 2 ^digit2 6 ^sum 8 ^carry-borrow 0)
    (<a27> ^digit1 2 ^digit2 7 ^sum 9 ^carry-borrow 0)
    (<a28> ^digit1 2 ^digit2 8 ^sum 0 ^carry-borrow 1)
    (<a29> ^digit1 2 ^digit2 9 ^sum 1 ^carry-borrow 1)
    (<a30> ^digit1 3 ^digit2 0 ^sum 3 ^carry-borrow 0)
    (<a31> ^digit1 3 ^digit2 1 ^sum 4 ^carry-borrow 0)
    (<a32> ^digit1 3 ^digit2 2 ^sum 5 ^carry-borrow 0)
    (<a33> ^digit1 3 ^digit2 3 ^sum 6 ^carry-borrow 0)
    (<a34> ^digit1 3 ^digit2 4 ^sum 7 ^carry-borrow 0)
    (<a35> ^digit1 3 ^digit2 5 ^sum 8 ^carry-borrow 0)
    (<a36> ^digit1 3 ^digit2 6 ^sum 9 ^carry-borrow 0)
    (<a37> ^digit1 3 ^digit2 7 ^sum 0 ^carry-borrow 1)
    (<a38> ^digit1 3 ^digit2 8 ^sum 1 ^carry-borrow 1)
    (<a39> ^digit1 3 ^digit2 9 ^sum 2 ^carry-borrow 1)
    (<a40> ^digit1 4 ^digit2 0 ^sum 4 ^carry-borrow 0)
    (<a41> ^digit1 4 ^digit2 1 ^sum 5 ^carry-borrow 0)
    (<a42> ^digit1 4 ^digit2 2 ^sum 6 ^carry-borrow 0)
    (<a43> ^digit1 4 ^digit2 3 ^sum 7 ^carry-borrow 0)
    (<a44> ^digit1 4 ^digit2 4 ^sum 8 ^carry-borrow 0)
    (<a45> ^digit1 4 ^digit2 5 ^sum 9 ^carry-borrow 0)
    (<a46> ^digit1 4 ^digit2 6 ^sum 0 ^carry-borrow 1)
    (<a47> ^digit1 4 ^digit2 7 ^sum 1 ^carry-borrow 1)
    (<a48> ^digit1 4 ^digit2 8 ^sum 2 ^carry-borrow 1)
    (<a49> ^digit1 4 ^digit2 9 ^sum 3 ^carry-borrow 1)
    (<a50> ^digit1 5 ^digit2 0 ^sum 5 ^carry-borrow 0)
    (<a51> ^digit1 5 ^digit2 1 ^sum 6 ^carry-borrow 0)
    (<a52> ^digit1 5 ^digit2 2 ^sum 7 ^carry-borrow 0)
    (<a53> ^digit1 5 ^digit2 3 ^sum 8 ^carry-borrow 0)
    (<a54> ^digit1 5 ^digit2 4 ^sum 9 ^carry-borrow 0)
    (<a55> ^digit1 5 ^digit2 5 ^sum 0 ^carry-borrow 1)
    (<a56> ^digit1 5 ^digit2 6 ^sum 1 ^carry-borrow 1)
    (<a57> ^digit1 5 ^digit2 7 ^sum 2 ^carry-borrow 1)
    (<a58> ^digit1 5 ^digit2 8 ^sum 3 ^carry-borrow 1)
    (<a59> ^digit1 5 ^digit2 9 ^sum 4 ^carry-borrow 1)
    (<a60> ^digit1 6 ^digit2 0 ^sum 6 ^carry-borrow 0)
    (<a61> ^digit1 6 ^digit2 1 ^sum 7 ^carry-borrow 0)
    (<a62> ^digit1 6 ^digit2 2 ^sum 8 ^carry-borrow 0)
    (<a63> ^digit1 6 ^digit2 3 ^sum 9 ^carry-borrow 0)
    (<a64> ^digit1 6 ^digit2 4 ^sum 0 ^carry-borrow 1)
    (<a65> ^digit1 6 ^digit2 5 ^sum 1 ^carry-borrow 1)
    (<a66> ^digit1 6 ^digit2 6 ^sum 2 ^carry-borrow 1)
    (<a67> ^digit1 6 ^digit2 7 ^sum 3 ^carry-borrow 1)
    (<a68> ^digit1 6 ^digit2 8 ^sum 4 ^carry-borrow 1)
    (<a69> ^digit1 6 ^digit2 9 ^sum 5 ^carry-borrow 1)
    (<a70> ^digit1 7 ^digit2 0 ^sum 7 ^carry-borrow 0)
    (<a71> ^digit1 7 ^digit2 1 ^sum 8 ^carry-borrow 0)
    (<a72> ^digit1 7 ^digit2 2 ^sum 9 ^carry-borrow 0)
    (<a73> ^digit1 7 ^digit2 3 ^sum 0 ^carry-borrow 1)
    (<a74> ^digit1 7 ^digit2 4 ^sum 1 ^carry-borrow 1)
    (<a75> ^digit1 7 ^digit2 5 ^sum 2 ^carry-borrow 1)
    (<a76> ^digit1 7 ^digit2 6 ^sum 3 ^carry-borrow 1)
    (<a77> ^digit1 7 ^digit2 7 ^sum 4 ^carry-borrow 1)
    (<a78> ^digit1 7 ^digit2 8 ^sum 5 ^carry-borrow 1)
    (<a79> ^digit1 7 ^digit2 9 ^sum 6 ^carry-borrow 1)
    (<a80> ^digit1 8 ^digit2 0 ^sum 8 ^carry-borrow 0)
    (<a81> ^digit1 8 ^digit2 1 ^sum 9 ^carry-borrow 0)
    (<a82> ^digit1 8 ^digit2 2 ^sum 0 ^carry-borrow 1)
    (<a83> ^digit1 8 ^digit2 3 ^sum 1 ^carry-borrow 1)
    (<a84> ^digit1 8 ^digit2 4 ^sum 2 ^carry-borrow 1)
    (<a85> ^digit1 8 ^digit2 5 ^sum 3 ^carry-borrow 1)
    (<a86> ^digit1 8 ^digit2 6 ^sum 4 ^carry-borrow 1)
    (<a87> ^digit1 8 ^digit2 7 ^sum 5 ^carry-borrow 1)
    (<a88> ^digit1 8 ^digit2 8 ^sum 6 ^carry-borrow 1)
    (<a89> ^digit1 8 ^digit2 9 ^sum 7 ^carry-borrow 1)
    (<a90> ^digit1 9 ^digit2 0 ^sum 9 ^carry-borrow 0)
    (<a91> ^digit1 9 ^digit2 1 ^sum 0 ^carry-borrow 1)
    (<a92> ^digit1 9 ^digit2 2 ^sum 1 ^carry-borrow 1)
    (<a93> ^digit1 9 ^digit2 3 ^sum 2 ^carry-borrow 1)
    (<a94> ^digit1 9 ^digit2 4 ^sum 3 ^carry-borrow 1)
    (<a95> ^digit1 9 ^digit2 5 ^sum 4 ^carry-borrow 1)
    (<a96> ^digit1 9 ^digit2 6 ^sum 5 ^carry-borrow 1)
    (<a97> ^digit1 9 ^digit2 7 ^sum 6 ^carry-borrow 1)
    (<a98> ^digit1 9 ^digit2 8 ^sum 7 ^carry-borrow 1)
    (<a99> ^digit1 9 ^digit2 9 ^sum 8 ^carry-borrow 1)
}
smem --add {
    (<arithmetic> ^subtraction-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>
                          <a11> <a12> <a13> <a14> <a15> <a16> <a17> <a18> <a19> <a10>
                          <a21> <a22> <a23> <a24> <a25> <a26> <a27> <a28> <a29> <a20>
                          <a31> <a32> <a33> <a34> <a35> <a36> <a37> <a38> <a39> <a30>
                          <a41> <a42> <a43> <a44> <a45> <a46> <a47> <a48> <a49> <a40>
                          <a51> <a52> <a53> <a54> <a55> <a56> <a57> <a58> <a59> <a50>
                          <a61> <a62> <a63> <a64> <a65> <a66> <a67> <a68> <a69> <a60>
                          <a71> <a72> <a73> <a74> <a75> <a76> <a77> <a78> <a79> <a70>
                          <a81> <a82> <a83> <a84> <a85> <a86> <a87> <a88> <a89> <a80>
                          <a91> <a92> <a93> <a94> <a95> <a96> <a97> <a98> <a99> <a90>)
    (<a00> ^digit1 0 ^digit2 0 ^result 0)
    (<a01> ^digit1 10 ^digit2 1 ^result 9)
    (<a02> ^digit1 10 ^digit2 2 ^result 8)
    (<a03> ^digit1 10 ^digit2 3 ^result 7)
    (<a04> ^digit1 10 ^digit2 4 ^result 6)
    (<a05> ^digit1 10 ^digit2 5 ^result 5)
    (<a06> ^digit1 10 ^digit2 6 ^result 4)
    (<a07> ^digit1 10 ^digit2 7 ^result 3)
    (<a08> ^digit1 10 ^digit2 8 ^result 2)
    (<a09> ^digit1 10 ^digit2 9 ^result 1)
    (<a10> ^digit1 1 ^digit2 0 ^result 1)
    (<a11> ^digit1 1 ^digit2 1 ^result 0)
    (<a12> ^digit1 11 ^digit2 2 ^result 9)
    (<a13> ^digit1 11 ^digit2 3 ^result 8)
    (<a14> ^digit1 11 ^digit2 4 ^result 7)
    (<a15> ^digit1 11 ^digit2 5 ^result 6)
    (<a16> ^digit1 11 ^digit2 6 ^result 5)
    (<a17> ^digit1 11 ^digit2 7 ^result 4)
    (<a18> ^digit1 11 ^digit2 8 ^result 3)
    (<a19> ^digit1 11 ^digit2 9 ^result 2)
    (<a20> ^digit1 2 ^digit2 0 ^result 2)
    (<a21> ^digit1 2 ^digit2 1 ^result 1)
    (<a22> ^digit1 2 ^digit2 2 ^result 0)
    (<a23> ^digit1 12 ^digit2 3 ^result 9)
    (<a24> ^digit1 12 ^digit2 4 ^result 8)
    (<a25> ^digit1 12 ^digit2 5 ^result 7)
    (<a26> ^digit1 12 ^digit2 6 ^result 6)
    (<a27> ^digit1 12 ^digit2 7 ^result 5)
    (<a28> ^digit1 12 ^digit2 8 ^result 4)
    (<a29> ^digit1 12 ^digit2 9 ^result 3)
    (<a30> ^digit1 3 ^digit2 0 ^result 3)
    (<a31> ^digit1 3 ^digit2 1 ^result 2)
    (<a32> ^digit1 3 ^digit2 2 ^result 1)
    (<a33> ^digit1 3 ^digit2 3 ^result 0)
    (<a34> ^digit1 13 ^digit2 4 ^result 9)
    (<a35> ^digit1 13 ^digit2 5 ^result 8)
    (<a36> ^digit1 13 ^digit2 6 ^result 7)
    (<a37> ^digit1 13 ^digit2 7 ^result 6)
    (<a38> ^digit1 13 ^digit2 8 ^result 5)
    (<a39> ^digit1 13 ^digit2 9 ^result 4)
    (<a40> ^digit1 4 ^digit2 0 ^result 4)
    (<a41> ^digit1 4 ^digit2 1 ^result 3)
    (<a42> ^digit1 4 ^digit2 2 ^result 2)
    (<a43> ^digit1 4 ^digit2 3 ^result 1)
    (<a44> ^digit1 4 ^digit2 4 ^result 0)
    (<a45> ^digit1 14 ^digit2 5 ^result 9)
    (<a46> ^digit1 14 ^digit2 6 ^result 8)
    (<a47> ^digit1 14 ^digit2 7 ^result 7)
    (<a48> ^digit1 14 ^digit2 8 ^result 6)
    (<a49> ^digit1 14 ^digit2 9 ^result 5)
    (<a50> ^digit1 5 ^digit2 0 ^result 5)
    (<a51> ^digit1 5 ^digit2 1 ^result 4)
    (<a52> ^digit1 5 ^digit2 2 ^result 3)
    (<a53> ^digit1 5 ^digit2 3 ^result 2)
    (<a54> ^digit1 5 ^digit2 4 ^result 1)
    (<a55> ^digit1 5 ^digit2 5 ^result 0)
    (<a56> ^digit1 15 ^digit2 6 ^result 9)
    (<a57> ^digit1 15 ^digit2 7 ^result 8)
    (<a58> ^digit1 15 ^digit2 8 ^result 7)
    (<a59> ^digit1 15 ^digit2 9 ^result 6)
    (<a60> ^digit1 6 ^digit2 0 ^result 6)
    (<a61> ^digit1 6 ^digit2 1 ^result 5)
    (<a62> ^digit1 6 ^digit2 2 ^result 4)
    (<a63> ^digit1 6 ^digit2 3 ^result 3)
    (<a64> ^digit1 6 ^digit2 4 ^result 2)
    (<a65> ^digit1 6 ^digit2 5 ^result 1)
    (<a66> ^digit1 6 ^digit2 6 ^result 0)
    (<a67> ^digit1 16 ^digit2 7 ^result 9)
    (<a68> ^digit1 16 ^digit2 8 ^result 8)
    (<a69> ^digit1 16 ^digit2 9 ^result 7)
    (<a70> ^digit1 7 ^digit2 0 ^result 7)
    (<a71> ^digit1 7 ^digit2 1 ^result 6)
    (<a72> ^digit1 7 ^digit2 2 ^result 5)
    (<a73> ^digit1 7 ^digit2 3 ^result 4)
    (<a74> ^digit1 7 ^digit2 4 ^result 3)
    (<a75> ^digit1 7 ^digit2 5 ^result 2)
    (<a76> ^digit1 7 ^digit2 6 ^result 1)
    (<a77> ^digit1 7 ^digit2 7 ^result 0)
    (<a78> ^digit1 17 ^digit2 8 ^result 9)
    (<a79> ^digit1 17 ^digit2 9 ^result 8)
    (<a80> ^digit1 8 ^digit2 0 ^result 8)
    (<a81> ^digit1 8 ^digit2 1 ^result 7)
    (<a82> ^digit1 8 ^digit2 2 ^result 6)
    (<a83> ^digit1 8 ^digit2 3 ^result 5)
    (<a84> ^digit1 8 ^digit2 4 ^result 4)
    (<a85> ^digit1 8 ^digit2 5 ^result 3)
    (<a86> ^digit1 8 ^digit2 6 ^result 2)
    (<a87> ^digit1 8 ^digit2 7 ^result 1)
    (<a88> ^digit1 8 ^digit2 8 ^result 0)
    (<a89> ^digit1 18 ^digit2 9 ^result 9)
    (<a90> ^digit1 9 ^digit2 0 ^result 9)
    (<a91> ^digit1 9 ^digit2 1 ^result 8)
    (<a92> ^digit1 9 ^digit2 2 ^result 7)
    (<a93> ^digit1 9 ^digit2 3 ^result 6)
    (<a94> ^digit1 9 ^digit2 4 ^result 5)
    (<a95> ^digit1 9 ^digit2 5 ^result 4)
    (<a96> ^digit1 9 ^digit2 6 ^result 3)
    (<a97> ^digit1 9 ^digit2 7 ^result 2)
    (<a98> ^digit1 9 ^digit2 8 ^result 1)
    (<a99> ^digit1 9 ^digit2 9 ^result 0)
}
smem --add {
    (<arithmetic> ^add10-facts
                          <a01> <a02> <a03> <a04> <a05> <a06> <a07> <a08> <a09> <a00>)
    (<a00> ^digit1 0 ^digit-10 10)
    (<a01> ^digit1 1 ^digit-10 11)
    (<a02> ^digit1 2 ^digit-10 12)
    (<a03> ^digit1 3 ^digit-10 13)
    (<a04> ^digit1 4 ^digit-10 14)
    (<a05> ^digit1 5 ^digit-10 15)
    (<a06> ^digit1 6 ^digit-10 16)
    (<a07> ^digit1 7 ^digit-10 17)
    (<a08> ^digit1 8 ^digit-10 18)
    (<a09> ^digit1 9 ^digit-10 19)
}
smem --set learning on
sp {propose*init
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <op> +)
    (<op> ^name init)
}
sp {apply*init
    (state <s> ^operator.name init
               ^smem.command <cmd>)
-->
    (<s> ^name friends)
    (<cmd> ^store <a> <b> <c>)
    (<a> ^name alice ^friend <b>)
    (<b> ^name bob ^friend <a>)
    (<c> ^name charley)
}
sp {propose*mod
    (state <s> ^name friends
               ^smem.command <cmd>)
    (<cmd> ^store <a> <b> <c>)
    (<a> ^name alice)
    (<b> ^name bob)
    (<c> ^name charley)
-->
    (<s> ^operator <op> +)
    (<op> ^name mod)
}
sp {apply*mod
    (state <s> ^operator.name mod
               ^smem.command <cmd>)
    (<cmd> ^store <a> <b> <c>)
    (<a> ^name alice)
    (<b> ^name bob)
    (<c> ^name charley)
-->
    (<a> ^name alice -)
    (<a> ^name anna
         ^friend <c>)
    (<cmd> ^store <b> -)
    (<cmd> ^store <c> -)
}
sp {propose*ncb-retrieval
    (state <s> ^name friends
               ^smem.command <cmd>)
    (<cmd> ^store <a>)
    (<a> ^name anna
         ^friend <f>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name ncb-retrieval
          ^friend <f>)
}
sp {apply*ncb-retrieval*retrieve
    (state <s> ^operator <op>
               ^smem.command <cmd>)
    (<op> ^name ncb-retrieval
          ^friend <f>)
    (<cmd> ^store <a>)
-->
    (<cmd> ^store <a> -
           ^retrieve <f>)
}
sp {apply*ncb-retrieval*clean
    (state <s> ^operator <op>
               ^smem.command <cmd>)
    (<op> ^name ncb-retrieval
          ^friend <f>)
    (<f> ^<attr> <val>)
-->
    (<f> ^<attr> <val> -)
}
sp {propose*cb-retrieval
    (state <s> ^name friends
               ^smem.command <cmd>)
    (<cmd> ^retrieve)
-->
    (<s> ^operator <op> + =)
    (<op> ^name cb-retrieval)
}
sp {apply*cb-retrieval
    (state <s> ^operator <op>
               ^smem.command <cmd>)
    (<op> ^name cb-retrieval)
    (<cmd> ^retrieve <lti>)
-->
    (<cmd> ^retrieve <lti> -
           ^query <cue>)
    (<cue> ^name <any-name>
           ^friend <lti>)
}
sp {done
    (state <s> ^smem <smem>)
    (<smem> ^command.query <q>
            ^result.<status> <q>)
-->
    (halt)
}
sp {towers-of-hanoi*object*disk*elaborate*state*larger
   "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name towers-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
-->
    (<j-disk> ^larger <i-disk>)}
sp {towers-of-hanoi*object*disk*elaborate*state*upper-disk
   "If not(above(x,disk)), then upper-disk(disk)."
    (state <s> ^name towers-of-hanoi
               ^disk <disk>)
              -{ (<s> ^holds.above <disk>) }
-->
    (<s> ^upper-disk <disk>)}
sp {towers-of-hanoi*object*peg*elaborate*state*clear
   "If not(on(x,peg)), then clear(peg)."
    (state <s> ^name towers-of-hanoi
               ^peg <peg>)
              -{ (<s> ^holds.on <peg>) }
-->
    (<s> ^clear <peg>)}
sp {elaborations*elaborate*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)}
sp {elaborations*elaborate*super*top-state
    (state <ss> ^superstate.top-state <s>)
-->
    (<ss> ^top-state <s>)
}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
-->
    (write (crlf)
           | Goal Move Disk:| <size>
           | to peg | <to-name>)}
sp {towers-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3>
                     <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
                     )
    (<h1> ^disk <disk-1> ^on <peg-c>)
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<h8> ^disk <disk-8> ^on <peg-c>)
    (<h9> ^disk <disk-9> ^on <peg-c>)
    (<h10> ^disk <disk-10> ^on <peg-c>)
    (<h11> ^disk <disk-11> ^on <peg-c>)
    (<disk-1> ^name 1 )
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<disk-8> ^name 8)
    (<disk-9> ^name 9)
    (<disk-10> ^name 10)
    (<disk-11> ^name 11)
    (<peg-c> ^name |C|)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {tower-of-hanoi*elaborate*desired*not-statisfied
    (state <s> ^name towers-of-hanoi
               ^desired <d>
               ^top-state <ts>)
              -{(<ts> ^holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)}
    (<d> ^holds <dh>)
    (<dh> ^disk <m-disk>
          ^on <target-peg>)
-->
    (<dh> ^satisfied *no*)}
sp {tower-of-hanoi*elaborate*desired*statisfied
    (state <s> ^name towers-of-hanoi
               ^desired.holds <dh>
               ^top-state.holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)
    (<dh> ^disk <m-disk>
          ^on <target-peg>)
-->
    (<dh> ^satisfied *yes*)}
sp {towers-of-hanoi*propose*initialize
    (state <s> ^name towers-of-hanoi
              -^disk)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize)}
sp {towers-of-hanoi*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
^peg <peg-a> <peg-b> <peg-c>
^holds <h1> <h2> <h3>
               <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
^desired <d>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<d> ^holds <d1> <d2> <d3>
               <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>
               )
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)
}
sp {tower-of-hanoi*propose*move-disk*mea*onpeg
    (state <s> ^desired <d>)
    (<d> ^holds <dh1>)
    (<dh1> ^disk <m-disk>
           ^on <target-peg>
           ^satisfied *no*)
          -{(<d> ^holds <dh2>)
    (<dh2> ^disk <x-disk>
           ^satisfied *no*)
    (<x-disk> ^larger <m-disk>)}
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type put-on-peg
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-disk
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h>
          ^peg { <> <peg1> <> <peg2> <target-peg> })
    (<h> ^disk <m-disk>
         ^above <disk1>
         ^on <peg2>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <peg1>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type clear-disk
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-smaller
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h1> <h2>
          ^peg { <> <disk1-target> <> <disk1-source> <target-peg> })
    (<h1> ^disk <m-disk>
          ^on <disk1-target>)
    (<h2> ^disk <disk1>
          ^on <disk1-source>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <disk1-target>)
    (<disk1> ^larger <m-disk>)
   -{(<ts> ^holds <h3>)
    (<h3> ^disk <disk3>
          ^on <disk1-target>)
    (<disk3> ^larger <m-disk>)
    (<disk1> ^larger <disk3>)}
-->
    (<s> ^operator <o> +)
    (<o> ^name move-disk
         ^type clear-smaller
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*select*maintain*operator
    (state <s> ^operator <o>)
-->
    (<s> ^operator <o> >)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<h> ^disk <m-disk>
         ^above none
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
 #   (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
    (<h> ^above none <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^upper-disk <o-disk>
          ^upper-disk <m-disk>
          ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above <adisk>
         ^on { <> <target-peg> <source-peg> })
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
 # (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above <o-disk> <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {elaborate*state*desired
    (state <s> ^superstate <ss>)
    (<ss> ^operator <o>)
    (<o> ^disk <disk>
         ^to <peg>)
-->
    (<s> ^desired.move-disk <md>)
    (<md> ^disk <disk>
          ^peg <peg>)}
sp {towers-of-hanoi*propose*initialize-recursive
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-toh-recursive)}
sp {towers-of-hanoi*apply*initialize-recursive
    (state <s> ^operator.name initialize-toh-recursive)
-->
    (<s> ^name towers-of-hanoi
         ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
^peg <peg-a> <peg-b> <peg-c>
^holds <h1> <h2> <h3>
               <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
^desired <d>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<d> ^holds <d1> <d2> <d3>
               <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>
               )
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)
}
multi-attributes disk 7
multi-attributes peg 3
multi-attributes holds 8
multi-attributes upper-disk 2
multi-attributes clear 2
chunk never
multi-attributes disk 3
multi-attributes peg 3
multi-attributes holds 4
multi-attributes upper-disk 2
multi-attributes clear 2
chunk never
sp {top-goal*elaborate*goal*tower-of-hanoi
    (state <s> ^superstate nil)
-->
    (<s> ^name tower-of-hanoi)}
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^name tower-of-hanoi)
-->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
         ^peg <peg-a> <peg-b> <peg-c>
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7>
         ^top-state <s>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d>)
    (<d> ^holds <d1> <d2> <d3> <d4> <d5> <d6> <d7>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above none ^on <peg-c>)}
sp {tower-of-hanoi*object*disk*elaborate*state*larger
    "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name tower-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
-->
    (<j-disk> ^larger <i-disk>)}
sp {tower-of-hanoi*object*disk*elaborate*state*upper-disk
    "If not(above(x,disk)), then upper-disk(disk)."
    (state <s> ^name tower-of-hanoi
               ^disk <disk>)
              -{ (<s> ^holds.above <disk>) }
-->
    (<s> ^upper-disk <disk>)}
sp {tower-of-hanoi*object*peg*elaborate*state*clear
    "If not(on(x,peg)), then clear(peg)."
    (state <s> ^name tower-of-hanoi
               ^peg <peg>)
              -{ (<s> ^holds.on <peg>) }
-->
    (<s> ^clear <peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*onpeg
    (state <s> ^desired <d>)
    (<d> ^holds <dh1>)
    (<dh1> ^disk <m-disk>
           ^on <target-peg>
           ^satisfied *no*)
          -{(<d> ^holds <dh2>)
    (<dh2> ^disk <x-disk>
           ^satisfied *no*)
    (<x-disk> ^larger <m-disk>)}
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type put-on-peg
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-disk
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h>
          ^peg { <> <peg1> <> <peg2> <target-peg> })
    (<h> ^disk <m-disk>
         ^above <disk1>
         ^on <peg2>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <peg1>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^type clear-disk
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*mea*clear-smaller
    (state <s> ^desired <d>
               ^top-state <ts>)
    (<ts> ^holds <h1> <h2>
          ^peg { <> <disk1-target> <> <disk1-source> <target-peg> })
    (<h1> ^disk <m-disk>
          ^on <disk1-target>)
    (<h2> ^disk <disk1>
          ^on <disk1-source>)
    (<d> ^move-disk <md>)
    (<md> ^disk <disk1>
          ^peg <disk1-target>)
    (<disk1> ^larger <m-disk>)
   -{(<ts> ^holds <h3>)
    (<h3> ^disk <disk3>
          ^on <disk1-target>)
    (<disk3> ^larger <m-disk>)
    (<disk1> ^larger <disk3>)}
-->
    (<s> ^operator <o> +)
    (<o> ^name move-disk
         ^type clear-smaller
         ^disk <m-disk>
         ^to <target-peg>)}
sp {tower-of-hanoi*select*maintain*operator
    (state <s> ^operator <o>)
-->
    (<s> ^operator <o> >)}
sp {tower-of-hanoi*elaborate*desired*not-statisfied
    (state <s> ^name tower-of-hanoi
               ^desired <d>
               ^top-state <ts>)
              -{(<ts> ^holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)}
    (<d> ^holds <dh>)
    (<dh> ^disk <m-disk>
          ^on <target-peg>)
-->
    (<dh> ^satisfied *no*)}
sp {tower-of-hanoi*elaborate*desired*statisfied
    (state <s> ^name tower-of-hanoi
               ^desired.holds <dh>
               ^top-state.holds <h>)
    (<h> ^disk <m-disk>
         ^on <target-peg>)
    (<dh> ^disk <m-disk>
          ^on <target-peg>)
-->
    (<dh> ^satisfied *yes*)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<h> ^disk <m-disk>
         ^above none
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^clear <target-peg>
          ^upper-disk <m-disk>
          ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on { <> <target-peg> <source-peg> })
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above none <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^top-state <ts>)
    (<ts> ^upper-disk <o-disk>
          ^upper-disk <m-disk>
          ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above <adisk>
         ^on { <> <target-peg> <source-peg> })
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <m-disk-name>)
    (<target-peg> ^name <target-peg-name>)
    (<source-peg> ^name <source-peg-name>)
-->
    (write (crlf) |Move | <m-disk-name> | from | <source-peg-name> | to | <target-peg-name>)
    (<h> ^above <o-disk> <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7>)
    (<h1> ^disk <disk-1> ^on <peg-c>)
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<disk-1> ^name 1 )
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<peg-c> ^name |C|)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {elaborate*state*top-state
    (state <s> ^superstate <ss>)
    (<ss> ^top-state <ts>)
-->
    (<s> ^top-state <ts>)}
sp {elaborate*state*desired
    (state <s> ^superstate <ss>)
    (<ss> ^operator <o>)
    (<o> ^disk <disk>
         ^to <peg>)
-->
    (<s> ^desired.move-disk <md>)
    (<md> ^disk <disk>
          ^peg <peg>)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
-->
    (write (crlf)
           | Goal Move Disk:| <size>
           | to peg | <to-name>)}
multi-attributes operator 2
multi-attributes disk 7
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
chunk never
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^superstate nil)
-->
    (<s> ^peg a b c
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
         ^last-disk1-peg b
         ^last-disk-moved 2
         ^clear b c)
    (<h1> ^disk 1 ^above 2 ^on a)
    (<h2> ^disk 2 ^above 3 ^on a)
    (<h3> ^disk 3 ^above 4 ^on a)
    (<h4> ^disk 4 ^above 5 ^on a)
    (<h5> ^disk 5 ^above 6 ^on a)
    (<h6> ^disk 6 ^above 7 ^on a)
    (<h7> ^disk 7 ^above 8 ^on a)
    (<h8> ^disk 8 ^above 9 ^on a)
    (<h9> ^disk 9 ^above 10 ^on a)
    (<h10> ^disk 10 ^above 11 ^on a)
    (<h11> ^disk 11 ^above none ^on a)}
sp {tower-of-hanoi*propose*move-disk1
    (state <s> ^holds <h>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved <> 1)
    (<h> ^disk 1
         ^on <source-peg>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk 1
         ^from <source-peg>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto2
    "Target peg is clear."
    (state <s> ^upper-disk <m-disk>
               ^clear <target-peg>
               ^holds <h>
               ^last-disk-moved 1)
    (<h> ^disk { <m-disk> <> 1 }
         ^on <source-peg>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above2
    "Upper disk on the target peg is larger."
    (state <s> ^upper-disk <m-disk> { > <m-disk> <o-disk> }
               ^holds <h> { <> <h> <i> }
               ^last-disk-moved 1)
    (<h> ^disk { <> 1 <m-disk> }
         ^on <source-peg>)
    (<i> ^disk { > <m-disk> <o-disk> }
         ^on <target-peg>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above none
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <target-peg> -)}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on <source-peg>)
-->
    (<s> ^clear <target-peg> -)
    (<h> ^above none <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^upper-disk <o-disk>
               ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above <adisk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
-->
    (<s> ^upper-disk <o-disk> -)
    (<h> ^above <o-disk> <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*add-clear-source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>)
    (<h> ^disk <m-disk>
         ^above none
         ^on <source-peg>)
-->
    (<s> ^clear <source-peg>)}
sp {apply*move-disk*add*upper-disk*source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on <source-peg>)
-->
    (<s> ^upper-disk <adisk>)}
sp {apply*move-disk*record*last-disk-moved
    (state <s> ^operator <o>
               ^last-disk-moved { <> <m-disk> <old-disk> })
    (<o> ^name move-disk
         ^disk <m-disk>)
-->
    (<s> ^last-disk-moved <m-disk>
         ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
    (state <s> ^operator <o>
               ^last-disk1-peg { <> <peg> <old-peg> })
    (<o> ^name move-disk
         ^disk 1
         ^from <peg>)
-->
    (<s> ^last-disk1-peg <peg>
         ^last-disk1-peg <old-peg> -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk 1 ^on c)
    (<h2> ^disk 2 ^on c)
    (<h3> ^disk 3 ^on c)
    (<h4> ^disk 4 ^on c)
    (<h5> ^disk 5 ^on c)
    (<h6> ^disk 6 ^on c)
    (<h7> ^disk 7 ^on c)
    (<h8> ^disk 8 ^on c)
    (<h9> ^disk 9 ^on c)
    (<h10> ^disk 10 ^on c)
    (<h11> ^disk 11 ^on c)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <size>
         ^to <to-name>)
-->
    (write (crlf)
           | Move Disk:| <size>
           | to peg | <to-name>)}
excise tower-of-hanoi*monitor*operator-execution*move-disk
multi-attributes operator 2
multi-attributes disk 7
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
chunk never
sp {top-goal*elaborate*goal*tower-of-hanoi
    (state <s> ^superstate nil)
-->
    (<s> ^name tower-of-hanoi)}
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^name tower-of-hanoi)
-->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
          <disk-8> <disk-9> <disk-10> <disk-11>
^peg <peg-a> <peg-b> <peg-c>
^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
^last-disk1-peg <peg-b> ;# peg-b if odd number of disks, peg-c if even
^last-disk-moved <disk-2>
^clear <peg-b> <peg-c>
^upper-disk <disk-1>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
sp {tower-of-hanoi*object*disk*elaborate*state*larger
    "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name tower-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
-->
    (<j-disk> ^larger <i-disk>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto
    "Target peg is clear."
    (state <s> ^name tower-of-hanoi
               ^upper-disk <m-disk>
               ^clear { <> <last-peg> <target-peg> }
               ^holds <h>
               ^last-disk1-peg <last-peg>
               ^last-disk-moved.name <> 1)
    (<m-disk> ^name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above
    "Upper disk on the target peg is larger."
    (state <s> ^name tower-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk1-peg <last-peg>
         ^last-disk-moved.name <> 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on { <> <last-peg> <target-peg> })
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*onto2
    "Target peg is clear."
    (state <s> ^name tower-of-hanoi
               ^upper-disk <m-disk>
               ^clear <target-peg>
               ^holds <h>
               ^last-disk-moved.name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<m-disk> ^name <> 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {tower-of-hanoi*propose*move-disk*disk-to-move*above2
    "Upper disk on the target peg is larger."
    (state <s> ^name tower-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk-moved.name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <> 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above none
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <target-peg> -)}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on <source-peg>)
-->
    (<s> ^clear <target-peg> -)
    (<h> ^above none <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^upper-disk <o-disk>
               ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above <adisk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
-->
    (<s> ^upper-disk <o-disk> -)
    (<h> ^above <o-disk> <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*add-clear-source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>)
    (<h> ^disk <m-disk>
         ^above none
         ^on <source-peg>)
-->
    (<s> ^clear <source-peg>)}
sp {apply*move-disk*add*upper-disk*source
    (state <s> ^operator <o>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on <source-peg>)
-->
    (<s> ^upper-disk <adisk>)}
sp {apply*move-disk*record*last-disk-moved
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>)
-->
    (<s> ^last-disk-moved <m-disk>)}
sp {apply*move-disk*remove*last-disk-moved
    (state <s> ^operator <o>
               ^last-disk-moved <old-disk>)
    (<o> ^name move-disk
         ^disk <> <old-disk>)
-->
    (<s> ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <peg>)
-->
    (<s> ^last-disk1-peg <peg>)}
sp {apply*move-disk*remove*last-disk1-peg
    (state <s> ^operator <o>
               ^last-disk1-peg <old-peg>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <> <old-peg>)
-->
    (<s> ^last-disk1-peg <old-peg> -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk <disk-1> ^on <peg-c>)
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<h8> ^disk <disk-8> ^on <peg-c>)
    (<h9> ^disk <disk-9> ^on <peg-c>)
    (<h10> ^disk <disk-10> ^on <peg-c>)
    (<h11> ^disk <disk-11> ^on <peg-c>)
    (<disk-1> ^name 1 )
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<disk-8> ^name 8)
    (<disk-9> ^name 9)
    (<disk-10> ^name 10)
    (<disk-11> ^name 11)
    (<peg-c> ^name |C|)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
-->
    (write (crlf)
           | Move Disk:| <size>
           | to peg | <to-name>)}
excise tower-of-hanoi*monitor*operator-execution*move-disk
sp {tower-of-hanoi*monitor*state*holds*above*disk
    (state <s> ^superstate nil
               ^holds <h>)
    (<h> ^disk.size <u-size>
         ^above.size <w-size>
         ^on.name <peg-name>)
-->
    (write (crlf)
           |  On(| <u-size> 
           |,| <peg-name> 
           |),Above(| <w-size>
           |).|)}
sp {tower-of-hanoi*monitor*state*holds*above*none
    (state <s> ^superstate nil
               ^holds <h>)
    (<h> ^disk.size <size>
         ^above none
         ^on.name <peg-name>)
-->
    (write (crlf)
           |  On(| <size> 
           |,| <peg-name> 
           |).|)}
sp {tower-of-hanoi*monitor*state*upper-disk
    (state <s> ^superstate nil
               ^upper-disk.size <size>)
-->
    (write (crlf)
           |  Upper-Disk(| <size> 
           |).|)}
sp {tower-of-hanoi*monitor*state*clear
    (state <s> ^superstate nil
               ^clear.name <name>)
-->
    (write (crlf)
           |  Clear(Peg(| <name> 
           |)).|)}
sp {tower-of-hanoi*desired-state*above*disk
    (state <s> ^desired <d>
               ^superstate nil)
    (<d> ^disk <u-disk> ^above <w-disk> ^on <peg>)
    (<u-disk> ^size <u-size>)
    (<w-disk> ^size <w-size>)
    (<peg> ^name <peg-name>)
-->
    (write (crlf)
           |  Desired/On(| <u-size> 
           |,| <peg-name> 
           |),Above(| <u-size>
           |,| <w-size>
           |)/.|)}
sp {tower-of-hanoi*desired-state*above*none
    (state <s> ^desired <d> ^superstate nil)
    (<d> ^disk <disk> ^above none ^on <peg>)
    (<disk> ^size <size>)
    (<peg> ^name <peg-name>)
-->
    (write (crlf)
           |  Desired[On(| <size> 
           |,| <peg-name> 
           |),Above(| <size>
           |,-)].|)}
sp {tower-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^from.name <from-name>
         ^to.name <to-name>)
-->
    (write (crlf)
           |  Executing(Move-Disk(| <size>
           |,| <from-name> 
           |,| <to-name>
           |)).|)}
sp {towers-of-hanoi*object*disk*elaborate*state*larger
   "If size-of(i) > size-of(j), then larger(i,j)."
    (state <s> ^name towers-of-hanoi
               ^disk <i-disk> { <> <i-disk> <j-disk> })
    (<i-disk> ^size <i-size>)
    (<j-disk> ^size <j-size> > <i-size>)
-->
    (<j-disk> ^larger <i-disk>)}
sp {towers-of-hanoi*object*disk*elaborate*state*upper-disk
   "If not(above(x,disk)), then upper-disk(disk)."
    (state <s> ^name towers-of-hanoi
               ^disk <disk>)
              -{ (<s> ^holds.above <disk>) }
-->
    (<s> ^upper-disk <disk>)}
sp {towers-of-hanoi*object*peg*elaborate*state*clear
   "If not(on(x,peg)), then clear(peg)."
    (state <s> ^name towers-of-hanoi
               ^peg <peg>)
              -{ (<s> ^holds.on <peg>) }
-->
    (<s> ^clear <peg>)}
sp {elaborate*top-state*name
    (state <s> ^superstate nil)
-->
    (<s> ^name towers-of-hanoi)
}
sp {towers-of-hanoi*monitor*operator-execution*move-disk
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.size <size>
         ^to.name <to-name>)
-->
    (write (crlf)
           | Move Disk:| <size>
           | to peg | <to-name>)}
sp {towers-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk <disk-1> ^on <peg-c>)
    (<h2> ^disk <disk-2> ^on <peg-c>)
    (<h3> ^disk <disk-3> ^on <peg-c>)
    (<h4> ^disk <disk-4> ^on <peg-c>)
    (<h5> ^disk <disk-5> ^on <peg-c>)
    (<h6> ^disk <disk-6> ^on <peg-c>)
    (<h7> ^disk <disk-7> ^on <peg-c>)
    (<h8> ^disk <disk-8> ^on <peg-c>)
    (<h9> ^disk <disk-9> ^on <peg-c>)
    (<h10> ^disk <disk-10> ^on <peg-c>)
    (<h11> ^disk <disk-11> ^on <peg-c>)
    (<disk-1> ^name 1 )
    (<disk-2> ^name 2 )
    (<disk-3> ^name 3 )
    (<disk-4> ^name 4 )
    (<disk-5> ^name 5 )
    (<disk-6> ^name 6 )
    (<disk-7> ^name 7 )
    (<disk-8> ^name 8)
    (<disk-9> ^name 9)
    (<disk-10> ^name 10)
    (<disk-11> ^name 11)
    (<peg-c> ^name |C|)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {towers-of-hanoi*propose*initialize
    (state <s> ^name towers-of-hanoi
              -^disk)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize)}
sp {towers-of-hanoi*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
^peg <peg-a> <peg-b> <peg-c>
^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
^last-disk1-peg <peg-b> ; # peg-b if odd number of disks, peg-c if even
^last-disk-moved <disk-2>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*onto
   "Target peg is clear."
    (state <s> ^name towers-of-hanoi
               ^upper-disk <m-disk>
               ^clear { <> <last-peg> <target-peg> }
               ^holds <h>
               ^last-disk1-peg <last-peg>
               ^last-disk-moved.name <> 1)
    (<m-disk> ^name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*above
   "Upper disk on the target peg is larger."
    (state <s> ^name towers-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk1-peg <last-peg>
         ^last-disk-moved.name <> 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on { <> <last-peg> <target-peg> })
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*onto2
   "Target peg is clear."
    (state <s> ^name towers-of-hanoi
               ^upper-disk <m-disk>
               ^clear <target-peg>
               ^holds <h>
               ^last-disk-moved.name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<m-disk> ^name <> 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {towers-of-hanoi*propose*move-disk*disk-to-move*above2
   "Upper disk on the target peg is larger."
    (state <s> ^name towers-of-hanoi)
    (<s> ^upper-disk <m-disk> { <> <m-disk> <o-disk> }
         ^holds <h> { <> <h> <i> }
         ^last-disk-moved.name 1)
    (<h> ^disk <m-disk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
    (<o-disk> ^larger <m-disk>)
    (<m-disk> ^name <> 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)}
sp {apply*move-disk*source-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above none
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*source-not-clear*target-clear
    (state <s> ^operator <o>
               ^clear <target-peg>
               ^holds <h>)
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above { <> none <adisk> }
         ^on <source-peg>)
-->
    (<h> ^above none <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*target-not-clear
    (state <s> ^operator <o>
               ^upper-disk <o-disk>
               ^holds <h> { <> <h> <i> })
    (<o> ^name move-disk
         ^disk <m-disk>
         ^from <source-peg>
         ^to <target-peg>)
    (<h> ^disk <m-disk>
         ^above <adisk>
         ^on <source-peg>)
    (<i> ^disk <o-disk>
         ^on <target-peg>)
-->
    (<h> ^above <o-disk> <adisk> -
         ^on <target-peg> <source-peg> - )}
sp {apply*move-disk*record*last-disk-moved
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk <m-disk>)
-->
    (<s> ^last-disk-moved <m-disk>)}
sp {apply*move-disk*remove*last-disk-moved
    (state <s> ^operator <o>
               ^last-disk-moved <old-disk>)
    (<o> ^name move-disk
         ^disk <> <old-disk>)
-->
    (<s> ^last-disk-moved <old-disk> -)}
sp {apply*move-disk*record*last-disk1-peg
    (state <s> ^operator <o>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <peg>)
-->
    (<s> ^last-disk1-peg <peg>)}
sp {apply*move-disk*remove*last-disk1-peg
    (state <s> ^operator <o>
               ^last-disk1-peg <old-peg>)
    (<o> ^name move-disk
         ^disk.name 1
         ^from <> <old-peg>)
-->
    (<s> ^last-disk1-peg <old-peg> -)}
sp {towers-of-hanoi*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-toh)}
sp {towers-of-hanoi*apply*initialize-toh
    (state <s> ^operator.name initialize-toh)
-->
    (<s> ^name towers-of-hanoi
         ^disk <disk-1> <disk-2> <disk-3> <disk-4> <disk-5> <disk-6> <disk-7>
              <disk-8> <disk-9> <disk-10> <disk-11>
^peg <peg-a> <peg-b> <peg-c>
^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
^last-disk1-peg <peg-b> ; # peg-b if odd number of disks, peg-c if even
^last-disk-moved <disk-2>)
    (<h1> ^disk <disk-1> ^above <disk-2> ^on <peg-a>)
    (<h2> ^disk <disk-2> ^above <disk-3> ^on <peg-a>)
    (<h3> ^disk <disk-3> ^above <disk-4> ^on <peg-a>)
    (<h4> ^disk <disk-4> ^above <disk-5> ^on <peg-a>)
    (<h5> ^disk <disk-5> ^above <disk-6> ^on <peg-a>)
    (<h6> ^disk <disk-6> ^above <disk-7> ^on <peg-a>)
    (<h7> ^disk <disk-7> ^above <disk-8> ^on <peg-a>)
    (<h8> ^disk <disk-8> ^above <disk-9> ^on <peg-a>)
    (<h9> ^disk <disk-9> ^above <disk-10> ^on <peg-a>)
    (<h10> ^disk <disk-10> ^above <disk-11> ^on <peg-a>)
    (<h11> ^disk <disk-11> ^above none ^on <peg-a>)
    (<disk-1> ^name 1 ^size 1)
    (<disk-2> ^name 2 ^size 2)
    (<disk-3> ^name 3 ^size 3)
    (<disk-4> ^name 4 ^size 4)
    (<disk-5> ^name 5 ^size 5)
    (<disk-6> ^name 6 ^size 6)
    (<disk-7> ^name 7 ^size 7)
    (<disk-8> ^name 8 ^size 8)
    (<disk-9> ^name 9 ^size 9)
    (<disk-10> ^name 10 ^size 10)
    (<disk-11> ^name 11 ^size 11)
    (<peg-a> ^name |A|)
    (<peg-b> ^name |B|)
    (<peg-c> ^name |C|)
    (<s> ^desired <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9> <d10> <d11>)
    (<d1> ^disk <disk-1> ^above <disk-2> ^on <peg-c>)
    (<d2> ^disk <disk-2> ^above <disk-3> ^on <peg-c>)
    (<d3> ^disk <disk-3> ^above <disk-4> ^on <peg-c>)
    (<d4> ^disk <disk-4> ^above <disk-5> ^on <peg-c>)
    (<d5> ^disk <disk-5> ^above <disk-6> ^on <peg-c>)
    (<d6> ^disk <disk-6> ^above <disk-7> ^on <peg-c>)
    (<d7> ^disk <disk-7> ^above <disk-8> ^on <peg-c>)
    (<d8> ^disk <disk-8> ^above <disk-9> ^on <peg-c>)
    (<d9> ^disk <disk-9> ^above <disk-10> ^on <peg-c>)
    (<d10> ^disk <disk-10> ^above <disk-11> ^on <peg-c>)
    (<d11> ^disk <disk-11> ^above none ^on <peg-c>)}
multi-attributes disk 7
multi-attributes peg 3
multi-attributes holds 8
multi-attributes upper-disk 2
multi-attributes clear 2
chunk never
max-elaborations 50000
multi-attributes on 3
multi-attributes peg 4
multi-attributes holds 10
multi-attributes clear 3
chunk never
sp {tower-of-hanoi*propose*state*initial-and-desired-states
    "A 3-Disk Tower of Hanoi Problem." 
    (state <s> ^superstate nil)
-->
    (<s> ^operator <o>
         ^peg a b c
         ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>
         ^last-disk1-peg b
         ^last-disk-moved 2
         ^clear b c)
    (<o> ^name doit)
    (<h1> ^disk 1 ^above 2 ^on a)
    (<h2> ^disk 2 ^above 3 ^on a)
    (<h3> ^disk 3 ^above 4 ^on a)
    (<h4> ^disk 4 ^above 5 ^on a)
    (<h5> ^disk 5 ^above 6 ^on a)
    (<h6> ^disk 6 ^above 7 ^on a)
    (<h7> ^disk 7 ^above 8 ^on a)
    (<h8> ^disk 8 ^above 9 ^on a)
    (<h9> ^disk 9 ^above 10 ^on a)
    (<h10> ^disk 10 ^above 11 ^on a)
    (<h11> ^disk 11 ^above none ^on a)}
sp {tower-of-hanoi*move-disk1*source-clear*target-not-clear
    (state <s> ^operator.name doit
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> })
    (<h> ^disk 1
         ^above none
         ^on <source-peg>)
    (<h2> ^disk <t-disk>
          ^on <target-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> none -)
    (<s> ^clear <source-peg>
         ^upper-disk <t-disk> -
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-disk1*source-not-clear*target-clear
    (state <s> ^operator.name doit
               ^holds <h>
               ^clear <target-peg>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> })
    (<h> ^disk 1
         ^above <t-disk>
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> - none)
    (<s> ^clear <target-peg> -
         ^upper-disk <t-disk>
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-disk1*source-not-clear*target-not-clear
    (state <s> ^operator.name doit
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^peg { <> <last-peg> <> <source-peg> <target-peg> }
               ^last-disk1-peg <last-peg>
               ^last-disk-moved {<> 1 <ldm> })
    (<h> ^disk 1
         ^above { <> none <s-disk> }
         ^on <source-peg>)
    (<h2> ^disk <t-disk>
          ^on <target-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> <s-disk> -)
    (<s> ^upper-disk <s-disk>
         ^upper-disk <t-disk> -
         ^last-disk1-peg <source-peg> <last-peg> -
         ^last-disk-moved 1 <ldm> -)}
sp {tower-of-hanoi*move-diskn*source-clear*target-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h>
               ^clear <target-peg>
               ^last-disk-moved 1)
    (<h> ^disk { <> 1 <mdisk> }
         ^above none
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -)
    (<s> ^clear <source-peg> <target-peg> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-clear*target-not-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h> <h2>
               ^upper-disk <t-disk>
               ^last-disk-moved 1)
    (<h> ^disk  { <> 1 <mdisk> }
         ^above none
         ^on <source-peg>)
    (<h2> ^disk { > <mdisk> <t-disk> }
          ^on <target-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> none -)
    (<s> ^clear <source-peg>
         ^upper-disk <t-disk> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-not-clear*target-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^holds <h>
               ^clear <target-peg>
               ^last-disk-moved 1)
    (<h> ^disk  { <> 1 <mdisk> }
         ^above { <> none <t-disk> }
         ^on <source-peg>)
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> - none)
    (<s> ^clear <target-peg> -
         ^upper-disk <t-disk>
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*move-diskn*source-not-clear*target-not-clear
    (state <s> ^operator.name doit
               ^upper-disk <mdisk>
               ^upper-disk <t-disk>
               ^holds <h> <h2>
               ^last-disk-moved 1)
    (<h> ^disk  { <> 1 <mdisk> }
         ^above { <> none <s-disk> }
         ^on <source-peg>)
    (<h2> ^disk { > <mdisk> <t-disk> }
          ^on { <> <source-peg> <target-peg> })
-->
    (<h> ^on <target-peg> <source-peg> -
         ^above <t-disk> <s-disk> -)
    (<s> ^upper-disk <s-disk>
         ^upper-disk <t-disk> -
         ^last-disk-moved <mdisk> 1 -)}
sp {tower-of-hanoi*desired-of-disk*satisfied
    (state <s> ^holds <h1> <h2> <h3> <h4> <h5> <h6> <h7> <h8> <h9> <h10> <h11>)
    (<h1> ^disk 1 ^on c)
    (<h2> ^disk 2 ^on c)
    (<h3> ^disk 3 ^on c)
    (<h4> ^disk 4 ^on c)
    (<h5> ^disk 5 ^on c)
    (<h6> ^disk 6 ^on c)
    (<h7> ^disk 7 ^on c)
    (<h8> ^disk 8 ^on c)
    (<h9> ^disk 9 ^on c)
    (<h10> ^disk 10 ^on c)
    (<h11> ^disk 11 ^on c)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {blocks-world*elaborate*state*clear
    (state <s> ^name blocks-world
               ^object <block>
              -^ontop.bottom-block <block>)
-->
    (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
    (state <s> ^name blocks-world
               ^object <object>)
    (<object> ^type table)
-->
    (<s> ^clear <object>)
}
sp {elaborate*top-state*name
    (state <s> ^superstate nil)
-->
    (<s> ^name blocks-world)
}
sp {blocks-world*monitor*world-state
    (state <s> ^ontop <ontop>)
    (<ontop> ^top-block.name <top-name>
             ^bottom-block.name <bottom-name>)
-->
    (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
    (state <s> ^operator <o>)
    (<o> ^name move-block
         ^moving-block.name <mob-name>
         ^destination.name <dob-name>)
-->
    (write (crlf)
          |  APPLIED | <o>
          |: move-block(| <mob-name>
          |,| <dob-name>
          |)|)}
sp {blocks-world*elaborate*state*success
    (state <s> ^desired <ds>
               ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
    (<ontopa1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<ontopa2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<ontopa3> ^top-block <blockC>
               ^bottom-block <table>)
    (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
-->
    (write (crlf) |Finished Stacking the Blocks.|)
    (halt)}
sp {blocks-world*reject*move-block*twice
    (state <s> ^name blocks-world
               ^operator <o> +
               ^last-moved-block <mb>)
    (<o> ^moving-block <mb>)
-->
    (<s> ^operator <o> < )}
sp {blocks-world*propose*initialize
    (state <s> ^name blocks-world
              -^object)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-clear-block-to-clear-object
    (state <s> ^name blocks-world)
    (<s> ^clear <blockA>
         ^clear { <> <blockA> <object> })
    (<blockA> ^type block)
   -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-block
         ^moving-block <blockA>
         ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
    (state <s> ^operator <o>
               ^ontop <ontop>)
    (<ontop> ^top-block <mblock>
             ^bottom-block { <> <tblock> <object> })
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
-->
    (<ontop> ^bottom-block <tblock>
             ^bottom-block <object> -)}
sp {blocks-world*apply*operator*remember*moved-block
    (state <s1> ^operator <o1>
               -^last-moved-block <mb>)
    (<o1> ^name move-block
          ^moving-block <mb>)
-->
    (<s1> ^last-moved-block <mb>)
}
sp {blocks-world*apply*operator*forget*moved-block
    (state <s> ^operator <o>
               ^last-moved-block <mb>)
    (<o> ^name move-block
         ^moving-block <> <mb>)
-->
    (<s> ^last-moved-block <mb> -)}
sp {blocks-world*propose*initialize-blocks-world
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize-blocks-world)
}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize-blocks-world)
-->
    (<s> ^name blocks-world
         ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
chunk never
sp {blocks-world*elaborate*state*clear
    (state <s> ^name blocks-world
               ^object <block>
              -^ontop.bottom-block <block>)
-->
    (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
    (state <s> ^name blocks-world
               ^object <object>)
    (<object> ^type table)
-->
    (<s> ^clear <object>)
}
sp {blocks-world*elaborate*name
    (state <s> ^superstate nil)
-->
    (<s> ^name blocks-world)
}
sp {blocks-world*monitor*world-state
    (state <s> ^ontop <ontop>)
    (<ontop> ^top-block.name <top-name>
             ^bottom-block.name <bottom-name>)
-->
    (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*prefer*clear-block
    (state <s> ^operator <o> +
               ^desired.clear <ub>
               ^ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <ub>)
    (<o> ^moving-block <mb>
         ^destination { <db> <> <ub> })
    (<mb> ^name <mb-name>)
    (<db> ^name <db-name>)
    (<ub> ^name <ub-name>)
-->
    (write (crlf) |Prefer move | <mb-name> | --> | <db-name> | to clear | <ub-name>)}
sp {blocks-world*monitor*prefer*ontop
    (state <s> ^operator <o> +
               ^desired.ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <db>)
    (<o> ^moving-block <mb>
         ^destination <db>)
    (<mb> ^name <mb-name>)
    (<db> ^name <db-name>)
-->
    (write (crlf) |Prefer move | <mb-name> | to | <db-name>)}
sp {blocks-world*monitor*avoid*clobber*clear
    (state <s> ^operator <o> +
               ^desired.clear <db>)
    (<o> ^destination <db>
         ^moving-block <mb>)
    (<mb> ^name <mb-name>)
    (<db> ^name <db-name>)
-->
    (write (crlf) |Avoid moving | <mb-name> | to | <db-name> | so don't clobber clear | <db-name> | goal.|)}
sp {blocks-world*elaborate*state*success
    (state <s> ^desired <ds>
               ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
    (<ontopa1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<ontopa2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<ontopa3> ^top-block <blockC>
               ^bottom-block <table>)
    (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
-->
    (halt)
    (write (crlf) |Achieved Goal.|)
}
sp {blocks-world*prefer*clear-block
    (state <s> ^operator <o> +
               ^desired.clear <ub>
               ^ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <ub>)
    (<o> ^moving-block <mb>
         ^destination <> <ub>)
-->
    (<s> ^operator <o> >)}
sp {blocks-world*prefer*ontop
    (state <s> ^operator <o> +
               ^desired.ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <db>)
    (<o> ^moving-block <mb>
         ^destination <db>)
-->
    (<s> ^operator <o> >)}
sp {blocks-world*avoid*clobbering*clear-block
    (state <s> ^operator <o> +
               ^desired.clear <ub>)
    (<o> ^destination <ub>)
-->
    (<s> ^operator <o> <)}
sp {move-block*elaborate*operator-subgoal
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.operator <so>)
    (<so> ^moving-block <mb>
          ^destination <des>)
-->
    (<s> ^type operator-subgoal
         ^name blocks-world
         ^desired <d>)
    (<d> ^clear <mb> <des>)}
sp {move-block*elaborate*copy*superstate
    (state <s> ^type operator-subgoal
               ^superstate <ss>)
    (<ss> ^ { <att> <> choices
                   <> impasse 
                   <> clear 
                   <> name 
                   <> quiescence
                   <> superstate 
                   <> attribute 
                   <> operator 
                   <> desired }
     <value>)
-->
    (<s> ^<att> <value>)}
sp {blocks-world*propose*initialize
    (state <s> ^name blocks-world
              -^object)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator
    (state <s> ^name blocks-world)
    (<s> ^object <blockA>
         ^object { <> <blockA> <object> })
    (<blockA> ^type block)
   -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-block
         ^moving-block <blockA>
         ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
    (state <s> ^operator <o>
               ^clear <mblock> <tblock>
               ^ontop <ontop>)
    (<ontop> ^top-block <mblock>
             ^bottom-block { <> <tblock> <object> })
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
-->
    (<ontop> ^bottom-block <tblock>
             ^bottom-block <object> -)}
sp {blocks-world*propose*initialize-blocks-world-operator-subgoalin
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize-blocks-world-operator-subgoaling)
}
sp {blocks-world*apply*initialize-blocks-world-operator-subgoaling
    (state <s> ^operator.name initialize-blocks-world-operator-subgoaling)
-->
    (<s> ^name blocks-world
         ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
chunk never
max-elaborations 10
chunk never
sp {blocks-world*propose*initialize-blocks-world
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize-blocks-world)
}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize-blocks-world)
-->
    (<s> ^name blocks-world
         ^world-state <s>
         ^ontop <ontop1> <ontop2> <ontop3>
         ^clear <blockA> <blockC> <table>
         ^object <blockA> <blockB> <blockC> <table>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table>  ^name table ^type table)
    (write (crlf) |Initial state has A on B and B and C on the table.|)}
sp {top-ps*propose*operator*build-tower
    (state <s> ^name blocks-world
               ^object <blockA> <blockB> <blockC> <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
   -{(<s> ^ontop <ontopa1> <ontopa2> <ontopa3>)
    (<ontopa1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<ontopa2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<ontopa3> ^top-block <blockC>
               ^bottom-block <table>)}
-->
    (<s> ^operator <o>)
    (<o> ^name build-tower
         ^desired <ds>)
    (<ds> ^ontop <ontop1> <ontop2> <ontop3>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-block
    (state <s> ^name << move-block build-tower  >>
               ^world-state <ws>)
    (<ws> ^object <blockA>
            { <> <blockA> <blockB> })
    (<blockA> ^type block)
   -{(<ws> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <blockB>)}
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-block
         ^moving-block <blockA>
         ^destination <blockB>)
}
sp {blocks-world*copy*desired-tower
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.operator.desired <d>)
-->
    (<s> ^desired <d>)}
sp {blocks-world*copy*world-state
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.world-state <ws>)
-->
    (<s> ^world-state <ws>)}
sp {blocks-world*apply*operator*move-block*remove-ontop
    (state <s>  ^operator <o>
                ^world-state <ws>)
    (<ws> ^ontop <ontop>
          ^clear <mblock> <tblock>)
    (<ontop> ^top-block <mblock>
            -^bottom-block <tblock>)
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
-->
    (<ws> ^ontop <ontop> -)}
sp {blocks-world*apply*operator*move-block*create-ontop
    (state <s> ^operator <o>
               ^world-state <ws>)
    (<ws> ^clear <mblock> <tblock>)
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
        -{(<ws> ^ontop <ontopx>)
    (<ontopx> ^top-block <mblock>
              ^bottom-block <tblock>)}
-->
    (<ws> ^ontop <ontop>)
    (<ontop> ^top-block <mblock>
             ^bottom-block <tblock>)}
sp {blocks-world*apply*operator*move-block*remove-clear
    (state <s>  ^operator <o>
                ^world-state <ws>)
    (<ws> ^clear <mblock> <tblock>)
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
    (<tblock> ^type block)
-->
    (<ws> ^clear <tblock> -)}
sp {blocks-world*apply*operator*move-block*create-clear
    (state <s>  ^operator <o>
                ^world-state <ws>)
    (<ws> ^ontop <ontop> ^clear <mblock> <tblock>)
    (<ontop> ^top-block <mblock>
             ^bottom-block { <> <tblock> <bblock>})
    (<bblock> ^type block)
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
-->
    (<ws> ^clear <bblock>)}
sp {blocks-world*prefer*clear-block
    (state <s> ^operator <o> +
               ^desired.clear <ub>
               ^world-state.ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <ub>)
    (<o> ^moving-block <mb>
         ^destination <> <ub>)
-->
    (<s> ^operator <o> >)}
sp {blocks-world*prefer*clear-block*monitor
    (state <s> ^operator <o> +
               ^desired.clear <ub>
               ^world-state.ontop <ot>)
    (<ot> ^top-block <mb>
          ^bottom-block <ub>)
    (<o> ^moving-block <mb>
         ^destination { <db> <> <ub> })
    (<mb> ^name <mb-name>)
    (<db> ^name <db-name>)
    (<ub> ^name <ub-name>)
-->
    (write (crlf) |Prefer move | <mb-name> | --> | <db-name> | to clear | <ub-name>)}
sp {blocks-world*prefer*ontop
    (state <s> ^operator <o> +
               ^desired.ontop <ot>
               ^world-state <ws>)
    (<ot> ^top-block <mb>
          ^bottom-block <db>)
    (<o> ^moving-block <mb>
         ^destination <db>)
-->
    (<s> ^operator <o> >)}
sp {blocks-world*prefer*ontop*monitor
    (state <s> ^operator <o> +
               ^desired.ontop <ot>
               ^world-state <ws>)
    (<ot> ^top-block <mb>
          ^bottom-block <db>)
    (<o> ^moving-block <mb>
         ^destination <db>)
    (<mb> ^name <mb-name>)
    (<db> ^name <db-name>)
-->
    (write (crlf) |Prefer move | <mb-name> | to | <db-name>)}
sp {top-ps*monitor*goal
    (state <s> ^ontop <ontopa1> <ontopa2> <ontopa3>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (<ontopa1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<ontopa2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<ontopa3> ^top-block <blockC>
               ^bottom-block <table>)
-->
    (write (crlf) |*** ACHIEVED GOAL ***|)
    (<s> ^success *yes*)
    (halt)}
sp {blocks-world*monitor*world-state
    (state <s> ^world-state <s>
               ^ontop <ontop>)
    (<ontop> ^top-block.name <top-name>
             ^bottom-block.name <bottom-name>)
-->
    (write (crlf)|  ontop(| <top-name> |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
    (state <s> ^operator <o>)
    (<o> ^name move-block
         ^moving-block <mob>
         ^destination <dob>)
    (<mob> ^name <mob-name>)
    (<dob> ^name <dob-name>)
-->
    (write (crlf) |SELECT | <o> |: move-block(| <mob-name> |,| <dob-name> |)|)}
sp {default*opsub*propose*space*name
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.operator <so>)
    (<so> ^moving-block <mb>
          ^destination <des>)
-->
    (<s> ^problem-space <sp>
         ^name operator-subgoal
         ^desired <d>)
    (<d> ^clear <mb> <des>)}
sp {default*generic*opsub*copy*superstate
   :default
    (state <s> ^name operator-subgoal
               ^superstate <ss>)
    (<ss> ^ { <att> <> problem-space
                   <> choices
                   <> impasse 
                   <> object 
                   <> name 
                   <> quiescence
                   <> superstate 
                   <> attribute 
                   <> operator 
                   <> desired }
       <value>)
-->
    (<s> ^<att> <value>)}
sp {blocks-world*elaborate*state*clear
    (state <s> ^name blocks-world
               ^object <block>
              -^ontop.bottom-block <block>)
-->
    (<s> ^clear <block>)
}
sp {blocks-world*elaborate*state*clear-table
    (state <s> ^name blocks-world
               ^object <object>)
    (<object> ^type table)
-->
    (<s> ^clear <object>)
}
sp {blocks-world*elaborate*problem-space
    (state <s> ^name blocks-world)
-->
    (<s> ^problem-space <p>)
    (<p> ^name move-blocks
         ^default-state-copy yes
         ^two-level-attributes ontop
         ^one-level-attributes object)}
sp {blocks-world*monitor*world-state
    (state <s> ^ontop <ontop>)
    (<ontop> ^top-block.name <top-name>
             ^bottom-block.name <bottom-name>)
-->
    (write (crlf)
          |  ontop(| <top-name>
          |,| <bottom-name> |)|)}
sp {blocks-world*monitor*operator-application*move-block
    (state <s> ^operator <o>)
    (<o> ^name move-block
         ^moving-block.name <mob-name>
         ^destination.name <dob-name>)
-->
    (write (crlf)
          |  APPLIED | <o>
          |: move-block(| <mob-name>
          |,| <dob-name>
          |)|)}
sp {blocks-world*elaborate*state*success
    (state <s> ^desired <ds>
               ^ontop <ontopa1>
                { <> <ontopa1> <ontopa2> }
                { <> <ontopa1> <> <ontopa2> <ontopa3> })
    (<ontopa1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<ontopa2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<ontopa3> ^top-block <blockC>
               ^bottom-block <table>)
    (<ds> ^ontop <ontop1>
                { <> <ontop1> <ontop2> }
                { <> <ontop1> <> <ontop2> <ontop3> })
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <blockC>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
-->
    (<s> ^success <ds>)}
sp {blocks-world*reject*move-block*twice
    (state <s> ^name blocks-world
               ^operator <o> +
               ^last-moved-block <mb>)
    (<o> ^moving-block <mb>)
-->
    (<s> ^operator <o> -)}
sp {blocks-world*propose*initialize
    (state <s> ^name blocks-world
              -^object)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize)
}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
sp {blocks-world*propose*operator*move-clear-block-to-clear-object
    (state <s> ^name blocks-world)
    (<s> ^clear <blockA>
         ^clear { <> <blockA> <object> })
    (<blockA> ^type block)
   -{(<s> ^ontop <ontop>)
    (<ontop> ^top-block <blockA>
             ^bottom-block <object>)}
-->
    (<s> ^operator <o> +)
    (<o> ^name move-block
         ^moving-block <blockA>
         ^destination <object>)}
sp {blocks-world*apply*operator*move-block*change-ontop
    (state <s> ^operator <o>
               ^ontop <ontop>)
    (<ontop> ^top-block <mblock>
             ^bottom-block { <> <tblock> <object> })
    (<o> ^moving-block <mblock>
         ^destination <tblock>)
-->
    (<ontop> ^bottom-block <tblock>
             ^bottom-block <object> -)}
sp {blocks-world*apply*operator*remember*moved-block
    (state <s1> ^operator <o1>
               -^last-moved-block <mb>)
    (<o1> ^name move-block
          ^moving-block <mb>)
-->
    (<s1> ^last-moved-block <mb>)
}
sp {blocks-world*apply*operator*forget*moved-block
    (state <s> ^operator <o>
               ^last-moved-block <mb>)
    (<o> ^name move-block
         ^moving-block <> <mb>)
-->
    (<s> ^last-moved-block <mb> -)}
sp {blocks-world*propose*initialize-blocks-world-look-ahead
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o>)
    (<o> ^name initialize-blocks-world-look-ahead)}
sp {blocks-world*apply*initialize
    (state <s> ^operator.name initialize-blocks-world-look-ahead)
-->
    (<s> ^name blocks-world
         ^ontop <ontop1> <ontop2> <ontop3>
         ^object <blockA> <blockB> <blockC> <table>
         ^desired <ds>)
    (<ontop1> ^top-block <blockA>
              ^bottom-block <blockB>)
    (<ontop2> ^top-block <blockB>
              ^bottom-block <table>)
    (<ontop3> ^top-block <blockC>
              ^bottom-block <table>)
    (<blockA> ^name A ^type block)
    (<blockB> ^name B ^type block)
    (<blockC> ^name C ^type block)
    (<table> ^name table ^type table)
    (write (crlf) |Simple Blocks World - just move blocks.|)
    (write (crlf) |Initial state has A on B, B on table, and C on the table.|)
    (<ds> ^ontop <dontop1> <dontop2> <dontop3>)
    (<dontop1> ^top-block <blockA>
               ^bottom-block <blockB>)
    (<dontop2> ^top-block <blockB>
               ^bottom-block <blockC>)
    (<dontop3> ^top-block <blockC>
               ^bottom-block <table>)
    (write (crlf) |The goal is to get A on B on C on the table.|)}
multi-attributes ontop 3
multi-attributes clear 3
multi-attributes objects 4
chunk always
epmem --set trigger dc
epmem --set learning on
watch --epmem
sp {propose*init
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <op> + =)
    (<op> ^name init)
}
sp {apply*init
    (state <s> ^operator <op>)
    (<op> ^name init)
-->
    (<s> ^name epmem
         ^feature2 value
         ^feature value3
         ^id <e2>
         ^id <e3>
         ^other-id <e4>)
    (<e2> ^sub-feature value2)
    (<e3> ^sub-id <e5>)
    (<e4> ^sub-id <e6>
          ^sub-feature value2)
}
sp {epmem*propose*cbr
    (state <s> ^name epmem
              -^epmem.command.<cmd>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name cbr)
}
sp {epmem*apply*cbr-clean
    (state <s> ^operator <op>
               ^feature2 <f2>
               ^feature <f>
               ^id <e2>
               ^id <e3>
               ^other-id <e4>)
    (<e2> ^sub-feature value2)
    (<e3> ^sub-id)
    (<op> ^name cbr)
-->
    (<s> ^feature2 <f2> -
         ^feature <f> -
         ^id <e2> -
         ^id <e3> -
         ^other-id <e4> -)
}
sp {epmem*apply*cbr-query
    (state <s> ^operator <op>
               ^epmem.command <cmd>)
    (<op> ^name cbr)
-->
    (<cmd> ^query <n1>)
    (<n1> ^feature value
          ^id <n2>)
    (<n2> ^sub-feature value2
          ^sub-id <n3>)
}
sp {epmem*propose*next
    (state <s> ^name epmem
               ^epmem.command.query)
-->
    (<s> ^operator <op> + =)
    (<op> ^name next)
}
sp {epmem*apply*next
    (state <s> ^operator <op>
               ^epmem.command <cmd>)
    (<op> ^name next)
    (<cmd> ^query <q>)
-->
    (<cmd> ^query <q> -
           ^next <next>)
}
sp {epmem*done
    (state <s> ^name epmem
               ^epmem <epmem>)
    (<epmem> ^command.next <next>
             ^result.success <next>)
-->
    (halt)
}
sp {water-jug*elaborate*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents <c>
         ^volume <v>)
-->
    (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
    (state <s> ^name water-jug
               ^jug <j> <i>)
    (<j> ^volume 5 ^contents <jcon>)
    (<i> ^volume 3 ^contents <icon>)
-->
    (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name empty
         ^jug.volume <volume>)
-->
    (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name fill
         ^jug.volume <volume>)
-->
    (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^jug <i>
         ^into <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*evaluate*state*success
    (state <s> ^desired <d>
               ^name water-jug
               ^jug <j>)
    (<d> ^jug <dj>)
    (<dj> ^volume <v> ^contents <c>)
    (<j> ^volume <v> ^contents <c>)
-->
    (<s> ^success <d>)}
sp {water-jug*elaborate*problem-space
    (state <s> ^name water-jug)
-->
    (<s> ^problem-space <p>)
    (<p> ^name water-jug
         ^default-state-copy yes
         ^two-level-attributes jug
         ^dont-copy empty)}
sp {water-jug*propose*pour
    (state <s> ^name water-jug
               ^jug <i> { <> <i> <j> })
    (<i> ^contents > 0 )
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name pour
         ^jug <i>
         ^into <j>)}
sp {water-jug*apply*pour*not-empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^jug <i>
         ^into <j>)
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
    (<i> ^volume <ivol>
         ^contents { <icon> <= <jempty> })
-->
    (<i> ^contents 0 <icon> -)
    (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^jug <i>
         ^into <j>)
    (<i> ^volume <ivol>
         ^contents { <icon> > <jempty> })
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
-->
    (<i> ^contents (- <icon> <jempty>) <icon> - )
    (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name empty
         ^jug <j>)}
sp {water-jug*apply*empty
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name empty
         ^jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents 0 <contents> - )}
sp {water-jug*propose*fill
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name fill
         ^jug <j>)}
sp {water-jug*apply*fill
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name fill
         ^jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug-look-ahead
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-water-jug-look-ahead)}
sp {water-jug*apply*initialize-water-jug-look-ahead
    (state <s> ^operator.name initialize-water-jug-look-ahead)
-->
    (<s> ^name water-jug
         ^jug <i> <j>
         ^desired.jug <k>)
    (<i> ^volume 3
         ^contents 0)
    (<j> ^volume 5
         ^contents 0)
    (<k> ^volume 3
         ^contents 1)}
sp {water-jug*monitor*tied-operator*empty
    (state <s> ^impasse tie
               ^attribute operator
               ^item <item>)
    (<item> ^name empty
            ^jug.volume <volume>)
-->
    (write (crlf) |  | <item> |: empty(| <volume> |)|)}
sp {water-jug*monitor*tied-operator*fill
    (state <s> ^impasse tie
               ^attribute operator
               ^item <item>)
    (<item> ^name fill
            ^jug.volume <volume>)
-->
    (write (crlf) |  | <item> |: fill(| <volume> |)|)}
sp {water-jug*monitor*tied-operator*pour
    (state <s> ^impasse tie
               ^attribute operator
               ^item <item>)
    (<item> ^name pour
            ^jug <i> ^into <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  | <item> |: pour(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {Impasse__Operator_Tie*elaborate*superstate-set
    (state <s> ^superstate <ss>)
-->
    (<s> ^superstate-set <ss>)
}
sp {Impasse__Operator_Tie*elaborate*superstate-set2
    (state <s> ^superstate.superstate-set <ss>)
-->
    (<s> ^superstate-set <ss>)
}
sp {water-jug*evaluate*state*failure*duplicate
    (state <s2> ^name water-jug
                ^superstate-set <s1>
                ^jug <i1>
                ^jug <i2>
                ^tried-tied-operator)
    (<i1> ^volume 5 ^contents <c1>)
    (<i2> ^volume 3 ^contents <c2>)
    (<s1> ^name water-jug
          ^desired <d>
          ^jug <j1>
          ^jug <j2>)
    (<j1> ^volume 5 ^contents <c1>)
    (<j2> ^volume 3 ^contents <c2>)
-->
    (<s2> ^failure <d>)}
multi-attributes jug 3
echo "learning is on"
chunk always
sp {water-jug*elaborate*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents <c>
         ^volume <v>)
-->
    (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
    (state <s> ^name water-jug
               ^jug <j> <i>)
    (<j> ^volume 5 ^contents <jcon>)
    (<i> ^volume 3 ^contents <icon>)
-->
    (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name empty
         ^empty-jug.volume <volume>)
-->
    (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name fill
         ^fill-jug.volume <volume>)
-->
    (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^volume 3 ^contents 1)
-->
    (write (crlf) |The problem has been solved.|)
    (halt)}
sp {water-jug*propose*pour
    (state <s> ^name water-jug
               ^jug <i> { <> <i> <j> })
    (<i> ^contents > 0 )
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
    (<i> ^volume <ivol>
         ^contents { <icon> <= <jempty> })
-->
    (<i> ^contents 0 <icon> -)
    (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol>
         ^contents { <icon> > <jempty> })
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
-->
    (<i> ^contents (- <icon> <jempty>) <icon> - )
    (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name empty
         ^empty-jug <j>)}
sp {water-jug*apply*empty
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name empty
         ^empty-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents 0
         ^contents <contents> - )}
sp {water-jug*propose*fill
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name fill
         ^fill-jug <j>)}
sp {water-jug*apply*fill
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name fill
         ^fill-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
    (state <s> ^operator.name initialize-water-jug)
-->
    (<s> ^name water-jug
         ^jug <i> <j>)
    (<i> ^volume 3
         ^contents 0)
    (<j> ^volume 5
         ^contents 0)}
chunk never
multi-attributes jug 3
sp {water-jug*elaborate*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents <c>
         ^volume <v>)
-->
    (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
    (state <s> ^name water-jug
               ^jug <j> <i>)
    (<j> ^volume 5 ^contents <jcon>)
    (<i> ^volume 3 ^contents <icon>)
-->
    (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name empty
         ^empty-jug.volume <volume>)
-->
    (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name fill
         ^fill-jug.volume <volume>)
-->
    (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
    (state <s> ^name water-jug
               ^reward-link <rl>
               ^jug <j>)
    (<j> ^volume 3 ^contents 1)
-->
    (write (crlf) |The problem has been solved.|)
    (<rl> ^reward.value 10
          ^final-update true)
    (halt)}
sp {water-jug*propose*pour
    (state <s> ^name water-jug
               ^jug <i> { <> <i> <j> })
    (<i> ^contents > 0 )
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)}
gp {rl*water-jug*pour
    (state <s> ^name water-jug
               ^operator <op> +
               ^jug <j1> <j2>)
    (<op> ^name pour
          ^empty-jug.volume [3 5])
    (<j1> ^volume 3
          ^contents [0 1 2 3])
    (<j2> ^volume 5
          ^contents [0 1 2 3 4 5])
-->
    (<s> ^operator <op> = 0)
}
sp {water-jug*apply*pour*not-empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
    (<i> ^volume <ivol>
         ^contents { <icon> <= <jempty> })
-->
    (<i> ^contents 0 <icon> -)
    (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol>
         ^contents { <icon> > <jempty> })
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
-->
    (<i> ^contents (- <icon> <jempty>) <icon> - )
    (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name empty
         ^empty-jug <j>)}
gp {rl*water-jug*empty
    (state <s> ^name water-jug
               ^operator <op> +
               ^jug <j1> <j2>)
    (<op> ^name empty
          ^empty-jug.volume [3 5])
    (<j1> ^volume 3
          ^contents [0 1 2 3])
    (<j2> ^volume 5
          ^contents [0 1 2 3 4 5])
-->
    (<s> ^operator <op> = 0)
}
sp {water-jug*apply*empty
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name empty
         ^empty-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents 0
         ^contents <contents> - )}
sp {water-jug*propose*fill
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name fill
         ^fill-jug <j>)}
gp {rl*water-jug*fill
    (state <s> ^name water-jug
               ^operator <op> +
               ^jug <j1> <j2>)
    (<op> ^name fill
          ^fill-jug.volume [3 5])
    (<j1> ^volume 3
          ^contents [0 1 2 3])
    (<j2> ^volume 5
          ^contents [0 1 2 3 4 5])
-->
    (<s> ^operator <op> = 0)
}
sp {water-jug*apply*fill
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name fill
         ^fill-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
    (state <s> ^operator.name initialize-water-jug)
-->
    (<s> ^name water-jug
         ^jug <i> <j>)
    (<i> ^volume 3
         ^contents 0)
    (<j> ^volume 5
         ^contents 0)}
chunk never
multi-attributes jug 3
rl --set learning on
sp {water-jug*elaborate*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents <c>
         ^volume <v>)
-->
    (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
    (state <s> ^name water-jug
               ^jug <j> <i>)
    (<j> ^volume 5 ^contents <jcon>)
    (<i> ^volume 3 ^contents <icon>)
-->
    (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name empty
         ^empty-jug.volume <volume>)
-->
    (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name fill
         ^fill-jug.volume <volume>)
-->
    (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^volume 3 ^contents 1)
-->
    (write (crlf) |The problem has been solved.|)
    (halt)}
sp {water-jug*propose*pour
    (state <s> ^name water-jug
               ^jug <i> { <> <i> <j> })
    (<i> ^contents > 0 )
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
    (<i> ^volume <ivol>
         ^contents { <icon> <= <jempty> })
-->
    (<i> ^contents 0 <icon> -)
    (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol>
         ^contents { <icon> > <jempty> })
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
-->
    (<i> ^contents (- <icon> <jempty>) <icon> - )
    (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name empty
         ^empty-jug <j>)}
sp {water-jug*apply*empty
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name empty
         ^empty-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents 0
         ^contents <contents> - )}
sp {water-jug*propose*fill
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> + =)
    (<o> ^name fill
         ^fill-jug <j>)}
sp {water-jug*propose*initialize-water-jug
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
    (state <s> ^operator.name initialize-water-jug)
-->
    (<s> ^name water-jug
         ^jug <i> <j>)
    (<i> ^volume 3
         ^contents 0)
    (<j> ^volume 5
         ^contents 0)}
sp {fill*propose*fill-jug
    (state <s> ^name fill
               ^jug <j>)
    (<j> ^picked-up yes
        -^filled-jug yes)
-->
    (<s> ^operator <op> + =)
    (<op> ^name fill-jug)
}
sp {apply*fill-jug
    (state <s> ^operator <op>
               ^jug <j1>)
    (<op> ^name fill-jug)
-->
    (<j1> ^filled-jug yes)
}
sp {elaborate*state*name
    (state <s> ^superstate.operator.name <name>)
-->
    (<s> ^name <name>)}
sp {fill*elaborate*jug
    (state <s> ^superstate.operator.fill-jug <j>)
-->
    (<s> ^jug <j>)}
sp {fill*propose*put-down
    (state <s> ^name fill
               ^jug <j>)
    (<j> ^picked-up yes
         ^filled-jug yes)
-->
    (<s> ^operator <op> + =)
    (<op> ^name put-down)
}
sp {apply*put-down
    (state <s> ^operator <op>
               ^jug <j>)
    (<op> ^name put-down)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^picked-up yes -
         ^filled-jug yes -
         ^contents <volume>
                  <contents> -)}
sp {fill*propose*pick-up
    (state <s> ^name fill
               ^jug <j>)
    (<j> -^picked-up yes)
-->
    (<s> ^operator <op> + =)
    (<op> ^name pick-up)
}
sp {apply*pick-up
    (state <s> ^operator <op>
               ^jug <j1>)
    (<op> ^name pick-up)
-->
    (<j1> ^picked-up yes)
}
chunk never
multi-attributes jug 3
sp {water-jug*elaborate*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents <c>
         ^volume <v>)
-->
    (<j> ^empty (- <v> <c>))}
sp {water-jug*monitor*state
    (state <s> ^name water-jug
               ^jug <j> <i>)
    (<j> ^volume 5 ^contents <jcon>)
    (<i> ^volume 3 ^contents <icon>)
-->
    (write (crlf) | 5:| <jcon> | 3:| <icon> )}
sp {water-jug*monitor*operator-application*empty
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name empty
         ^empty-jug.volume <volume>)
-->
    (write (crlf) |  EMPTY(| <volume> |)|)}
sp {water-jug*monitor*operator-application*fill
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name fill
         ^fill-jug.volume <volume>)
-->
    (write (crlf) |  FILL(| <volume> |)|)}
sp {water-jug*monitor*operator-application*pour
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol> ^contents <icon>)
    (<j> ^volume <jvol> ^contents <jcon>)
-->
    (write (crlf) |  POUR(| <ivol> |:| <icon> |,| <jvol> |:| <jcon> |)|)}
sp {water-jug*detect*goal*achieved
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^volume 3 ^contents 1)
-->
    (write (crlf) |The problem has been solved.|)
    (halt)}
sp {water-jug*propose*pour
    (state <s> ^name water-jug
               ^jug <i> { <> <i> <j> })
    (<i> ^contents > 0 )
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)}
sp {water-jug*apply*pour*not-empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
    (<i> ^volume <ivol>
         ^contents { <icon> <= <jempty> })
-->
    (<i> ^contents 0 <icon> -)
    (<j> ^contents (+ <jcon> <icon>) <jcon> - )}
sp {water-jug*apply*pour*empty-source
    (state <s> ^name water-jug
               ^operator <o>)
    (<o> ^name pour
         ^empty-jug <i>
         ^fill-jug <j>)
    (<i> ^volume <ivol>
         ^contents { <icon> > <jempty> })
    (<j> ^volume <jvol>
         ^contents <jcon>
         ^empty <jempty>)
-->
    (<i> ^contents (- <icon> <jempty>) <icon> - )
    (<j> ^contents <jvol> <jcon> -)}
sp {water-jug*propose*empty
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^contents > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name empty
         ^empty-jug <j>)}
sp {water-jug*apply*empty
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name empty
         ^empty-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents 0
         ^contents <contents> - )}
sp {water-jug*propose*fill
    (state <s> ^name water-jug
               ^jug <j>)
    (<j> ^empty > 0)
-->
    (<s> ^operator <o> +)
    (<o> ^name fill
         ^fill-jug <j>)}
sp {water-jug*apply*fill
    (state <s> ^name water-jug
               ^operator <o>
               ^jug <j>)
    (<o> ^name fill
         ^fill-jug <j>)
    (<j> ^volume <volume>
         ^contents <contents>)
-->
    (<j> ^contents <volume>
                  <contents> -)}
sp {water-jug*propose*initialize-water-jug
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-water-jug)}
sp {water-jug*apply*initialize-water-jug
    (state <s> ^operator.name initialize-water-jug)
-->
    (<s> ^name water-jug
         ^jug <i> <j>
         ^last-operator none)
    (<i> ^volume 3
         ^contents 0)
    (<j> ^volume 5
         ^contents 0)}
sp {Impasse__Operator_Tie*propose*evaluate-operator
    (state <s> ^name Impasse__Operator_Tie
               ^evaluation <x>)
   -(<x> ^value)
-->
    (<s> ^operator <op> + =)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
}
sp {apply*evaluate-operator*none
    (state <s> ^operator <op>
               ^evaluation <x>
               ^last-operator none)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
-->
    (<x> ^value equal)
}
sp {apply*evaluate-operator*pour*after-fill-empty
    (state <s> ^operator <op>
               ^evaluation <x>
               ^last-operator << empty fill >>)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
    (<x> ^super-operator.name pour)
-->
    (<x> ^value best)
}
sp {apply*evaluate-operator*pour*after-pour
    (state <s> ^operator <op>
               ^evaluation <x>
               ^last-operator pour)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
    (<x> ^super-operator.name pour)
-->
    (<x> ^value worst)
}
sp {apply*evaluate-operator*fill-empty*after-empty-fill
    (state <s> ^operator <op>
               ^evaluation <x>
               ^last-operator << empty fill >>)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
    (<x> ^super-operator.name << fill empty >>)
-->
    (<x> ^value worst)
}
sp {apply*evaluate-operator*fill-empty*after-pour
    (state <s> ^operator <op>
               ^evaluation <x>
               ^last-operator pour)
    (<op> ^name evaluate-operator
          ^evaluation <x>)
    (<x> ^super-operator.name << fill empty >>)
-->
    (<x> ^value equal)
}
sp {Impasse__Operator_Tie*elaborate*state
    (state <s> ^impasse tie)
-->
    (<s> ^name Impasse__Operator_Tie)
}
sp {Impasse__Operator_Tie*elaborate*state*evaluations
    (state <s> ^name Impasse__Operator_Tie
               ^item <x>)
-->
    (<s> ^evaluation.super-operator <x>)
}
sp {Impasse__Operator_Tie*elaborate*state*last-operator
    (state <s> ^name Impasse__Operator_Tie
               ^superstate.last-operator <o>)
-->
    (<s> ^last-operator <o>)
}
sp {Impasse__Operator_Tie*propose*create-preferences
    (state <s> ^name Impasse__Operator_Tie)
    # Negated conjunction that tests that there is no evaluation that does not have a value - all have values
   -{(<s> ^evaluation <x>)
   -(<x> ^value)}
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name create-preferences)
}
sp {apply*create-preferences*best
    (state <s> ^operator <op>
               ^evaluation <x>
               ^superstate <ss>)
    (<op> ^name create-preferences)
    (<x> ^super-operator <so>
         ^value best)
-->
    (<ss> ^operator <so> >, =)
}
sp {apply*create-preferences*worst
    (state <s> ^operator <op>
               ^evaluation <x>
               ^superstate <ss>)
    (<op> ^name create-preferences)
    (<x> ^super-operator <so>
         ^value worst)
-->
    (<ss> ^operator <so> <, =)
}
sp {apply*create-preferences*equal
    (state <s> ^operator <op>
               ^evaluation <x>
               ^superstate <ss>)
    (<op> ^name create-preferences)
    (<x> ^super-operator <so>
         ^value equal)
-->
    (<ss> ^operator <so> =)
}
sp {water-jug*record*operator
    (state <s> ^name water-jug
               ^operator.name <name>)
-->
    (<s> ^last-operator <name>)}
sp {water-jug*remove*last-operator
    (state <s> ^name water-jug
               ^last-operator <name>
               ^operator.name <> <name>)
-->
    (<s> ^last-operator <name> -)}
chunk never
multi-attributes jug 3
sp {default*generic*opsub*propose*space*generic
   :default
    (state <s> ^impasse no-change ^attribute operator
               ^superstate <ss>)
    (state <ss> ^problem-space <p2>)
-->
    (<s> ^problem-space <p2>)}
sp {default*generic*opsub*elaborate*state*name*operator-subgoal
   :default
    (state <s> ^problem-space <p>
               ^impasse no-change ^attribute operator ^superstate <ss>)
    (state <ss> ^problem-space <p>)
-->
    (<s> ^name operator-subgoal)}
sp {default*generic*opsub*elaborate*state*desired
   :default
    (state <s> ^problem-space <p> ^name operator-subgoal ^superstate <ss>)
    (state <ss> ^operator <o>)
-->
    (<s> ^desired <o>)}
sp {default*generic*opsub*copy*superstate
   :default
    (state <s> ^name operator-subgoal ^superstate <ss>)
    (<ss> ^ { <att> <> problem-space <> impasse <> object <> name
                   <> superstate <> attribute <> operator <> desired }
       <value>)
-->
    (<s> ^<att> <value>)}
sp {default*generic*select*reject-desired
   :default
    (state <s> ^name operator-subgoal ^problem-space <p> ^desired <o>)
-->
    (<s> ^operator <o> -)}
sp {default*generic*opsub*detect*state*success
   :default
    (state <g-eval> ^problem-space <p> ^desired <o> ^applied <o>)
    (<o> ^achieved <ss>)
-->
    (<ss> ^success <o>)}
sp {opsub*select-operator*subgoaling
   :default
    (state <s1> ^name implement-evaluate-object ^problem-space <p>
                ^operator <> <o> ^desired <o>)
    (<o> ^name)
-->
    (<s1> ^operator <o> !)}
sp {default*generic*opsub*failure*no-operator
   :default
    (state <s> ^superstate <ss> ^impasse no-change ^attribute state ^quiescence t)
    (<ss> ^name operator-subgoal ^desired <d>)
-->
    (<ss> ^failure <d>)}
sp {default*generic*evaluation*failure*no-operator
   :default
    (state <s> ^superstate <ss> ^impasse no-change ^name operator-subgoal
               ^attribute operator ^desired <d> ^quiescence t
               ^failure <d>)
    (<ss> ^operator <so> ^desired <sd>)
-->
    (<ss> ^failure <sd>)}
sp {default*generic*opsub*avoid*duplicate-operator
   :default
    (state <s> ^impasse no-change ^name operator-subgoal
               ^attribute operator ^operator <o> + ^super-desired <sd>)
    (<o> ^name <name>)
    (<sd> ^name <name>)
-->
    (<s> ^operator <o> -)}
sp {default*generic*opsub*subgoal-on-all-desired-super-desireds
   :default
    (state <s> ^problem-space <p>
               ^impasse no-change ^attribute operator ^superstate <ss>)
    (<ss> ^problem-space <p> ^desired <o>)
-->
    (<s> ^super-desired <o>)}
sp {default*generic*opsub*subgoal-on-all-super-desireds
   :default
    (state <s> ^problem-space <p>
               ^impasse no-change ^attribute operator ^superstate <ss>)
    (<ss> ^problem-space <p> ^super-desired <o>)
-->
    (<s> ^super-desired <o>)}
sp {default*apply*evaluate*augment*evaluation-operator-super-desired
   :default
    (state <s> ^operator <o> ^superstate <ss>)
    (<ss> ^super-desired <d>)
    (<o> ^evaluation <e> ^type evaluation)
-->
    (<o> ^super-desired <d>)}
sp {default*elaborate*state*eval*super-desired
   :default
    (state <s> ^impasse no-change ^attribute operator ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^type evaluation ^super-desired <d>)
-->
    (<s> ^super-desired <d>)}
sp {top-goal*halt*success
   :default
    (state <s> ^name <name>
               ^desired <eb>
               ^superstate nil
               ^<< required-success success >> <eb>)
-->
    (write (crlf)   <name>  | achieved |)
    (halt)}
sp {top-goal*halt*failure
   :default
    (state <s> ^superstate nil
               ^desired <eb>
               ^name <name>
               ^ << prohibit-failure failure >> <eb>)
-->
    (write (crlf)  <name>  | failed|)
    (halt)}
sp {evaluate-operator*propose*look-ahead
   :default
    (state <s> ^look-ahead-operator <o>
               ^untried-tied-operator <o>)
-->
    (<s> ^operator <o> +)}
sp {evaluate-operator*propose*look-ahead*reject-all-others
   :default
    (state <s> ^look-ahead-operator <o>
               ^untried-tied-operator <o>
               ^operator { <> <o> <o1> } +)
-->
    (<s> ^operator <o1> -)}
sp {evaluate-operator*elaborate*state*tried-tied-operator
   :default
    (state <s> ^operator <o>
               ^look-ahead-operator <o>)
-->
    (<s> ^tried-tied-operator <o>)}
sp {evaluate-operator*elaborate*state*remove*untried-tied-operator
   :default
    (state <s> ^look-ahead-operator <o>
               ^operator <o>
               ^untried-tied-operator <o>)
-->
    (<s> ^untried-tied-operator <o> -)
}
sp {selection*pass-back-success
   :default
    (state <s> ^superstate.superstate.operator <sso>
               ^evaluation.symbolic-value << required-success >>) # partial-success success >>)
    (<sso> ^name evaluate-operator
           ^evaluation <e2>
           ^superoperator.name)
-->
    (<e2> ^symbolic-value partial-success)}
sp {selection*elaborate*evaluate-operator*all-operators-novalue
   :default
    (state <s> ^superstate.superstate <sss>
               ^operator <o>
              -^not-all-operators-evaluated
              -^found-value
               ^quiescence t
               ^choices multiple)
    (<sss> ^name selection
           ^operator <sso>)
    (<sso> ^name evaluate-operator
           ^evaluation <e>)
-->
    (<e> ^numeric-value novalue)}
sp {evaluate-operator*elaborate*evaluation*failure*constraint-failure
   :default
    (state <rej-state-imp> ^superstate <eval-g>
                           ^attribute operator
                           ^impasse constraint-failure)
    (<eval-g> ^superstate <select-g>)
    (<select-g> ^operator <o2>)
    (<select-g> ^evaluation <e2>)
    (<o2> ^name evaluate-operator
          ^evaluation <e2>)
-->
    (<e2> ^symbolic-value failure)}
sp {evaluate-operator*elaborate*state*desired
   :default
    (state <s> ^impasse no-change
               ^attribute operator
              -^problem-space.no-local-negations <nln>
               ^superstate.operator <so>)
    (<so>  -^default-desired-copy yes
            ^name evaluate-operator
            ^evaluation.desired <d>)
-->
    (<s> ^desired <d>)}
sp {evaluate-operator*elaborate*state*desired*nln
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^problem-space.no-local-negations <nln>
               ^superstate.operator <so>)
    (<so>   ^name evaluate-operator # ddc is assumed no with nln
            ^evaluation.desired <d>)
-->
    (<s> ^desired <d>)}
sp {evaluate-operator*elaborate*state*name
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.operator <so>)
    (<so> ^name evaluate-operator
          ^superstate.name {<> evaluate-operator <name> })
-->
    (<s> ^name <name>)}
sp {evaluate-operator*elaborate*state*duplicate-of
   :default
    (state <s> ^superstate <ss>
               ^default-state-copy yes)
    (<ss> ^operator <so>)
    (<so> ^name evaluate-operator
          ^superstate <sss>)
-->
    (<s> ^duplicate-of <sss>)}
sp {evaluate-operator*elaborate*state*look-ahead-operator*copy
   :default
    (state <s> ^problem-space.name <n>
               ^default-operator-copy yes
               ^superstate.operator <so>)
    (<so> ^name evaluate-operator
          ^superoperator <o>
          ^superproblem-space.name <n>)
-->
    (<s> ^look-ahead-operator <copy-o>)
    (<s> ^untried-tied-operator <copy-o>) # SBW 5/7/07-- -^tried-tied-operator -> ^untried-tied-operator
    (<copy-o> ^duplicate-of <o>)}
sp {evaluate-operator*elaborate*state*look-ahead-operator*no-copy
   :default
    (state <s> ^problem-space.name <p>
               ^default-operator-copy no
               ^superstate.operator <so>)
    (<so> ^name evaluate-operator
          ^superoperator <o>
          ^superproblem-space.name <p>)
-->
    (<s> ^look-ahead-operator <o>)
    (<s> ^untried-tied-operator <o>)}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal
   :default
    (state <ss> ^superstate <s>
                ^ { << required-success success partial-success
                   indifferent partial-failure failure prohibit-failure
                   >> <svalue> } <eb>)
    (<s> ^operator <so>
         ^evaluation <e>)
    (<so> ^name evaluate-operator
          ^evaluation <e>
          ^evaluation.desired <eb>)
-->
    (<e> ^symbolic-value <svalue>)}
sp {evaluate-operator*elaborate*evaluation*from-subgoal*duplicate-desired
   :default
    (state <s> ^superstate <ss>
               ^ { << required-success success partial-success
                  indifferent partial-failure failure prohibit-failure
                  >> <svalue> } <deb>)
    (<ss> ^operator <so>
          ^evaluation <e>)
    (<so> ^name evaluate-operator
          ^evaluation <e>
          ^evaluation.desired <eb>)
    (<deb> ^duplicate-of <eb>)
-->
    (<e> ^symbolic-value <svalue>)}
sp {evaluate-operator*elaborate*numeric-evaluation*from-subgoal
   :default
    (state <ss> ^superstate <s>
                ^desired <eb>
                ^numeric-value <v>)
    (<s> ^operator <so>
         ^evaluation <e>)
    (<so> ^name evaluate-operator
          ^evaluation <e>
          ^evaluation.desired <eb>)
-->
    (<e> ^numeric-value <v>)}
sp {evaluate-operator*elaborate*default-for-default-state-copy-is-yes
   :default
    (state <s> ^superstate.operator.name evaluate-operator
               ^problem-space <p>)
   -(<p> ^default-state-copy no)
-->
    (<s> ^default-state-copy yes)}
sp {evaluate-operator*elaborate*default-state-copy-from-problem-space
   :default
    (state <s> ^superstate.operator.name evaluate-operator
               ^problem-space.default-state-copy <yes-or-no>)
-->
    (<s> ^default-state-copy <yes-or-no>)}
sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^superstate.operator.name evaluate-operator
               ^problem-space <p>)
    (<p> -^all-attributes-at-level two
         -^one-level-attributes
         -^two-level-attributes
         -^dont-copy
         -^dont-copy-anything)
-->
    (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*default-copy-is-all-attributes-at-level-one*no-problem-space
   :default
    (state <s> ^impasse no-change
              -^problem-space
               ^attribute operator
               ^superstate.operator <so>)
    (<so> ^name evaluate-operator
         -^superproblem-space <p>)
-->
    (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*copy-all-attributes-at-level-one-from-problem-space
   :default
    (state <s> ^problem-space.all-attributes-at-level one
               ^default-state-copy yes)
-->
    (<s> ^all-attributes-at-level one)}
sp {evaluate-operator*elaborate*state*create-duplicates-table
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^default-state-copy yes
               ^superstate.operator.name evaluate-operator)
-->
    (<s> ^duplicates <d>)}
sp {evaluate-operator*elaborate*state*add-one-level-attributes
   :default
    (state <s> ^problem-space.one-level-attributes <att>
               ^duplicate-of.<att> <val>
               ^default-state-copy yes)
-->
    (<s> ^<att> <val>)}
sp {evaluate-operator*elaborate*state*add-all-attributes-at-level-one
   :default
    (state <s> ^problem-space <p>
               ^default-state-copy yes
               ^all-attributes-at-level one
               ^duplicate-of <ss>)
    (<p> -^dont-copy-anything
         -^dont-copy <att>)
    (<ss> ^{ <> duplicate-of <> tried-tied-operator <> problem-space
            <> impasse <> attribute <> choices <> quiescence
            <> operator <> superstate <> type <> name <> look-ahead-operator
            <att> } <val>)
-->
    (<s> ^<att> <val>)}
sp {evaluate-operator*elaborate*state*change-one-level-attribute-to-duplicate
   :default
    (state <s> ^problem-space.one-level-attributes <att>
               ^duplicates.<id> <new-id>
               ^default-state-copy yes
               ^duplicate-of.<att> <id>)
-->
    (<s> ^<att> <id> -
         ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*change-all-attributes-at-level-one-to-duplicate
   :default
    (state <s> -^problem-space.dont-copy <att>
                ^default-state-copy yes
                ^all-attributes-at-level one
                ^duplicates.<id> <new-id>
                ^duplicate-of.{ <> tried-tied-operator <att> } <id>)
-->
    (<s> ^<att> <id> -
         ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*duplicate-id-for-attribute
   :default
    (state <s> ^problem-space.two-level-attributes <att>
               ^duplicates <d>
               ^default-state-copy yes
               ^duplicate-of.<att> <id>)
-->
    (<d> ^<id> <new-id>)}
sp {evaluate-operator*elaborate*state*duplicate-id-for-all-attributes
   :default
    (state <s> ^problem-space <p>
               ^duplicates <d>
               ^default-state-copy yes
               ^duplicate-of <ss>)
    (<p> -^dont-copy-anything
         -^dont-copy <att>
          ^all-attributes-at-level two
         -^one-level-attributes <att>)
    (<ss> ^{ <> duplicate-of <> tried-tied-operator <> problem-space
            <> impasse <> attribute <> choices <> quiescence
            <> operator <> superstate
            <att> } <id>)
-->
    (<d> ^<id> <new-id>)}
output warnings off
sp {evaluate-operator*elaborate*add-attribute-to-duplicate
   :default
    (state <s> ^duplicates <d>
              -^problem-space.no-local-negations <nln>
              -^problem-space.dont-copy <sub-att>
               ^default-state-copy yes)
    (<d> ^<id> <new-id>
             - ^<sub-val>)
    (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
    (<new-id> ^<sub-att> <sub-val>)}
output warnings on
output warnings off
sp {evaluate-operator*elaborate*add-attribute-to-duplicate*nln
   :default
    (state <s> ^duplicates <d>
               ^problem-space.no-local-negations <nln>
               ^default-state-copy yes)
    (<d> ^<id> <new-id>)
    (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
    (<new-id> ^<sub-att> <sub-val>)}
output warnings on
output warnings off
sp {evaluate-operator*elaborate*add-duplicated-attribute-to-duplicate
   :default
    (state <s> ^duplicates <d>
               ^default-state-copy yes)
    (<d> ^<id> <new-id>
         ^<sub-val> <new-val>)
    (<id> ^ { <> tried-tied-operator <sub-att> } <sub-val>)
-->
    (<new-id> ^<sub-att> <new-val>)}
output warnings on
output warnings off
sp {evaluate-operator*elaborate*state*add-duplicate-to-state
   :default
    (state <s> ^problem-space.two-level-attributes <att>
               ^duplicates.<id> <new-id>
               ^default-state-copy yes
               ^duplicate-of.<att> <id>)
-->
    (<s> ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*add-duplicates-for-all-attributes
   :default
    (state <s> ^problem-space <p>
               ^duplicates.<id> <new-id>
               ^default-state-copy yes
               ^duplicate-of.{ <> tried-tied-operator <att> } <id>)
    (<p> ^all-attributes-at-level two
     - ^dont-copy-anything
     - ^dont-copy <att>
     - ^one-level-attributes <att>)
-->
    (<s> ^<att> <new-id>)}
sp {evaluate-operator*elaborate*state*eval*desired
   :default
    (state <s> ^superstate <ss>)
    (<ss> ^operator <so>)
    (<so> ^name evaluate-operator
          ^evaluation.desired <d>
          ^default-desired-copy yes)
-->
    (<s> ^desired <d-copy>)
    (<d-copy> ^duplicate-of <d>)}
sp {duplicate-desired*copy-old-value
   :default
    (state <s> ^superstate.operator <so>
               ^problem-space <p>
               ^duplicates <d>
               ^desired <o-copy>)
    (<so> ^name evaluate-operator
          ^evaluation.desired <o>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^{ <> duplicate-of <att> } <val>)
 - (<p> ^dont-copy <att>)
 - (<d> ^<val>)
-->
    (<o-copy> ^<att> <val>)}
sp {duplicate-desired*replace-old-value
   :default
    (state <s> ^duplicates.<id> <copy-id>
               ^problem-space <p>
               ^desired <o-copy>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^ { <> duplicate-of <att> } <id>)
    (<p> - ^dont-copy <att>)
-->
    (<o-copy> ^<att> <copy-id>)}
sp {evaluate-operator*elaborate*operator*default-operator-copy-is-yes
   :default
    (state <s> ^superstate.operator.name evaluate-operator
               ^problem-space <ps>)
    (<ps> -^default-operator-copy no)
-->
    (<s> ^default-operator-copy yes)}
sp {evaluate-operator*elaborate*operator*copy-default-operator-copy-from-problem-space
   :default
    (state <s> ^superstate.operator.name evaluate-operator
               ^problem-space.default-operator-copy <yes-or-no>)
-->
    (<s> ^default-operator-copy <yes-or-no>)}
sp {evaluate-operator*elaborate*state*create-duplicates-table-for-operator-only
   :default
    (state <s> ^impasse no-change
               ^attribute operator
               ^default-operator-copy yes
                                    - ^default-state-copy yes)
-->
    (<s> ^duplicates <d>)}
sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator
   :default
    (state <s> ^duplicates <d>
               ^problem-space <p>
               ^look-ahead-operator <o-copy>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^ { <> duplicate-of <att> } <val>)
    (<p> -^dont-copy <att>
         -^no-local-negations <nln>)
    (<d> - ^<val>)
-->
    (<o-copy> ^<att> <val>)}
sp {evaluate-operator*elaborate*operator*add-duplicated-attribute-to-duplicate-operator
   :default
    (state <s> ^duplicates <d>
               ^problem-space <p>
               ^look-ahead-operator <o-copy>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^ { <> duplicate-of <att> } <id>)
    (<p> -^dont-copy <att>
         -^no-local-negations <nln>)
    (<d> ^<id> <copy-id>)
-->
    (<o-copy> ^<att> <copy-id>)}
sp {evaluate-operator*elaborate*operator*add-attribute-to-duplicate-operator*nln
   :default
    (state <s> ^problem-space <p>
               ^look-ahead-operator <o-copy>)
    (<o-copy> ^duplicate-of <o>)
    (<o> ^ { <> duplicate-of <att> } <val>)
    (<p> ^no-local-negations <nln>)
-->
    (<o-copy> ^<att> <val>)}
sp {monitor*goal*success
   :default
    (state <s> ^top-state <ts>
               ^name <gname>
               ^desired <d>
               ^<< partial-success required-success success >> <d>)
    (<ts> ^superstate nil
         -^verbose false)
-->
    (write (crlf) |  Goal | <gname> | succeeded. |)}
sp {monitor*goal*failure
   :default
    (state <s> ^top-state <ts>
               ^name <gname>
               ^desired <d>
               ^<< partial-failure failure prohibit-failure >> <d>)
    (<ts> ^superstate nil
         -^verbose false)
-->
    (write (crlf) |  Goal | <gname> | failed. |)}
sp {evaluate-operator*elaborate*evaluation*failure*no-operators
   :default
    (state <goal-nc> ^superstate <state-nc>
                     ^attribute state
                     ^impasse no-change
                     ^quiescence t)
    (<state-nc> ^superstate <eval-g>
                ^attribute state
                ^impasse no-change
                ^quiescence t)
    (<eval-g> ^superstate <select-g>
              ^quiescence t)
    (<select-g> ^operator <o2>
                ^evaluation <e2>)
    (<o2> ^name evaluate-operator
          ^evaluation <e2>)
-->
    (<e2> ^symbolic-value failure)}
sp {selection*propose*evaluate-operator
   :default
    (state <s> ^name selection
               ^item <i>)
              -{(state <s> ^evaluation <e>)
    (<e> ^superoperator <i>
         ^value true)}
-->
    (<s> ^operator <o> +)
    (<o> ^name evaluate-operator
         ^superoperator <i>)}
sp {selection*select*evaluate-operator*indifferent
   :default
    (state <s> ^name selection
              -^operator-selection not-indifferent
               ^operator <o> +)
    (<o> ^name evaluate-operator)
-->
    (<s> ^operator <o> =)}
sp {selection*apply*state*evaluation
   :default
    (state <s> ^name selection
               ^operator <o>)
    (<o> ^name evaluate-operator
         ^superoperator <ob>)
-->
    (<s> ^evaluation <e>)
    (<e> ^superoperator <ob>)}
sp {selection*elaborate*evaluate-operator*evaluation
   :default
    (state <s> ^name selection
               ^operator <o>
               ^evaluation <e>)
    (<o> ^name evaluate-operator
         ^superoperator <ob>)
    (<e> ^superoperator <ob>)
-->
    (<o> ^evaluation <e>)}
sp {selection*elaborate*evaluate-operator*superproblem-space
   :default
    (state <s> ^name selection
               ^operator <o>
               ^superstate.problem-space <p2>)
    (<o> ^name evaluate-operator)
-->
    (<o> ^superproblem-space <p2>)}
sp {selection*elaborate*evaluate-operator*superstate
   :default
    (state <s> ^name selection
               ^operator <o>
               ^superstate <ss>)
    (<o> ^name evaluate-operator)
-->
    (<o> ^superstate <ss>)}
sp {selection*elaborate*name*selection
   :default
    (state <s> ^choices multiple)
-->
    (<s> ^name selection)}
sp {selection*elaborate*evaluation*value
   :default
    (state <s> ^evaluation <e>)
    (<e> ^ << numeric-value symbolic-value >>)
-->
    (<e> ^value true)}
sp {selection*elaborate*evaluation*desired
   :default
    (state <s> ^superstate.desired <d>
               ^evaluation <e>)
-->
    (<e> ^desired <d>)}
sp {selection*compare*equal-evaluation-indifferent
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>  { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <x>
          ^numeric-value <v>
          ^desired <d>)
    (<e2> ^superoperator <y>
          ^numeric-value <v>
          ^desired <d>)
  - (<d> ^equal not-indifferent)
-->
    (<ss> ^operator <x> = <y>)}
sp {selection*compare*higher-evaluation-better
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>
               ^evaluation { <> <e1> <e2> })
    (<ss> ^problem-space <p2>
          ^desired <d>)
    (<e1> ^superoperator <o1>
          ^numeric-value <v>
          ^desired <d>)
    (<e2> ^superoperator <o2>
          ^numeric-value < <v>
          ^desired <d>)
    (<d> ^better higher)
-->
    (<ss> ^operator <o2> < <o1>)}
sp {selection*compare*prefer-lower-evaluation
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>
               ^evaluation { <> <e1> <e2> })
    (<ss> ^problem-space <p2>
          ^desired <d>)
    (<e1> ^superoperator <o1>
          ^numeric-value <v>
          ^desired <d>)
    (<e2> ^superoperator <o2>
          ^numeric-value > <v>
          ^desired <d>)
    (<d> ^better lower)
-->
    (<ss> ^operator <o2> < <o1>)}
sp {selection*compare*same-symbolic-evaluations-are-indifferent
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>  { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <x>
          ^symbolic-value <v>
          ^desired <d>)
    (<e2> ^superoperator <y>
          ^symbolic-value <v>
          ^desired <d>)
-->
    (<ss> ^operator <x> = <y>)}
sp {selection*compare*success-evaluation-better-than-partial-success
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1> { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <x>
          ^symbolic-value success
          ^desired <d>)
    (<e2> ^superoperator { <> <x> <y> }
          ^symbolic-value partial-success
          ^desired <d>)
-->
    (<ss> ^operator <x> > <y>)}
sp {selection*compare*partial-failure-evaluation-better-than-failure
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>  { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <x>
          ^symbolic-value partial-failure
          ^desired <d>)
    (<e2> ^superoperator { <> <x> <y> }
          ^symbolic-value failure
          ^desired <d>)
-->
    (<ss> ^operator <x> > <y>)}
sp {selection*select*required-success-evaluation-becomes-required-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <eb>)
    (<e1> ^symbolic-value required-success
          ^desired <eb>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> !)}
sp {selection*select*success-evaluation-becomes-best-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <eb>)
    (<e1> ^symbolic-value << partial-success success >>
          ^desired <eb>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> >)}
sp {selection*select*failure-evaluation-becomes-reject-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <e>)
    (<e1> ^symbolic-value << lose failure >>
          ^desired <e>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> -)}
sp {selection*select*prohibit-failure-evaluation-becomes-prohibit-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <e>)
    (<e1> ^symbolic-value prohibit-failure
          ^desired <e>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> ~)}
sp {selection*select*indifferent-evaluation-becomes-indifferent-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <eb>)
    (<e1> ^symbolic-value indifferent
          ^desired <eb>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> =)}
sp {selection*select*partial-failure-evaluation-becomes-worst-preference
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>)
    (<ss> ^desired <e>)
    (<e1> ^symbolic-value partial-failure
          ^desired <e>
          ^superoperator <o1>)
-->
    (<ss> ^operator <o1> <)}
sp {selection*elaborate*state*all-objects-evaluated
   :default
    (state <s> ^name selection
               ^operator <o> +)
- {(<o> ^name evaluate-operator
        ^evaluation.value true)}
-->
    (<s> ^not-all-operators-evaluated true)}
sp {selection*elaborate*state*found-value-true
   :default
    (state <s> ^name selection
               ^evaluation <e>)
    (<e> ^ << numeric-value symbolic-value >> <> novalue)
-->
    (<s> ^found-value true)}
sp {selection*compare*novalue-evaluation-always-worse
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>
               ^evaluation { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <o1>
          ^numeric-value novalue
          ^desired <d>)
    (<e2> ^superoperator <o2>
          ^numeric-value <> novalue
          ^desired <d>)
-->
    (<ss> ^operator <o2> > <o1>)}
sp {monitor*operator*evaluation
   :default
    (state <s> ^top-state <ts>
               ^operator <o>)
    (<o> ^name evaluate-operator
         ^superoperator <obj>
         ^evaluation. << numeric-value symbolic-value >> <n>)
    (<obj> ^name <name>)
    (<ts> ^superstate nil
         -^verbose false)
-->
    (write (crlf) |  Evaluation of | <obj> | (|
   <name> |) is | <n>)}
sp {selection*propose*achieved-max-depth
    (state <s> ^name selection
               ^max-evaluation-depth <med>
               ^current-evaluation-depth <med>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name achieved-max-depth)
}
sp {apply*achieved-max-depth
    (state <s> ^operator <op>
               ^item <o>
               ^superstate <ss>)
    (<op> ^name achieved-max-depth)
-->
    (<ss> ^operator <o> =)
}
sp {evaluate-operator*apply*decrement-current-evaluation-depth
    (state <s> ^operator <o>
               ^current-evaluation-depth <ced>)
    (<o> ^name { <> achieved-max-depth
                <> decrement-remaining-operators 
                <> no-more-evaluations 
                <> exceed-depth 
                <> evaluate-operator 
                <> increment-current-evaluation-depth 
                <> init-current-evaluation-depth 
                <> init-remaining-operators })
-->
    (<s> ^current-evaluation-depth (- <ced> 1) <ced> -)}
sp {selection*propose*no-more-evaluations
    (state <s> ^name selection
               ^top-selection false
               ^remaining-operators 0)
-->
    (<s> ^operator <op> + =)
    (<op> ^name no-more-evaluations)
}
sp {apply*increment-no-more-evaluations
    (state <s> ^operator <op>
               ^superstate.superstate <ss>
               ^superstate.superstate.operator <o>)
    (<ss> ^unevaluated-operator <u>)
    (<o> ^name evaluate-operator
         ^evaluation <e>
         ^superoperator <u>)
    (<op> ^name no-more-evaluations)
-->
    (<e> ^symbolic-value depth-exceeded)
    (<ss> ^unevaluated-operator <u> -)
}
sp {selection*pass-back-success*iterative
   :default
    (state <s> ^superstate.superstate.operator <sso>
               ^evaluation.symbolic-value << required-success success >>)
    (<sso> ^name evaluate-operator
           ^evaluation <e2>
           ^superoperator.name)
-->
    (write (crlf) |Success | <e2> )
    (<e2> ^symbolic-value success)}
sp {selection*propose*init-current-evaluation-depth*middle-selection
    (state <s> ^name selection
               ^top-selection false
               ^superstate.current-evaluation-depth <ced>)
-->
    (<s> ^current-evaluation-depth <ced>)
}
sp {evaluate-operator*elaborate*state
    (state <s> ^superstate.operator <o>)
    (<o> ^name evaluate-operator
         ^evaluation.current-evaluation-depth <ced>)
-->
    (<s> ^current-evaluation-depth <ced>)
}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal*depth-exceeded
   :default
    (state <ss> ^superstate <s>
                ^depth-exceeded <eb>)
    (<s> ^operator <so>
         ^evaluation <e>
         ^unevaluated-operator <u>
         ^allow-one-evaluation <a>)
    (<so> ^name evaluate-operator
          ^evaluation <e>
          ^superoperator <u>
          ^evaluation.desired <eb>)
-->
    (<e> ^symbolic-value depth-exceeded)
    (<s> ^unevaluated-operator <u> -
         ^allow-one-evaluation <a> -)}
sp {evaluate-operator*elaborate*symbolic-evaluation*from-subgoal
   :default
    (state <ss> ^superstate <s>
                ^ { << required-success success partial-success
                   indifferent partial-failure failure prohibit-failure
                   >> <svalue> } <eb>)
    (<s> ^operator <so>
         ^evaluation <e>
         ^unevaluated-operator <u>
         ^allow-one-evaluation <a>)
    (<so> ^name evaluate-operator
          ^evaluation <e>
          ^superoperator <u>
          ^evaluation.desired <eb>)
-->
    (<e> ^symbolic-value <svalue>)
    (<s> ^unevaluated-operator <u> -
         ^allow-one-evaluation <a> -)}
sp {evaluate-operator*propose*exceed-depth
    (state <s> ^current-evaluation-depth <= 0
    #    ^quiescence t
         ^look-ahead-operator <o>
         #    ^depth-valid <dv>
              ^tried-tied-operator <o>)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name exceed-depth)
}
sp {evaluate-operator*compare*exceed-depth
    (state <s> ^name evaluate-operator
               ^look-ahead-operator <op2>
               ^operator <op1> +
                        <op2> +)
    (<op1> ^name exceed-depth)
-->
    (<s> ^operator <op1> < <op2>)
}
sp {apply*exceed-depth
    (state <s> ^operator <op>
               ^desired <d>)
    (<op> ^name exceed-depth)
-->
    (<s> ^depth-exceeded <d>)
}
sp {selection*mark-item-unevaluated
    (state <s> ^name selection
               ^item <i>
               ^current-evaluation-depth <ced>)
-->
    (<s> ^unevaluated-operator <i>)
}
sp {selection*mark-remaining-operators-unused
    (state <s> ^name selection
               ^remaining-operators <ro>)
-->
    (<s> ^allow-one-evaluation <a>)
}
sp {selection*propose*evaluate-operator
   :default
    (state <s> ^name selection
               ^item <i>
               ^current-evaluation-depth <ced>
               ^remaining-operators <ro>
               ^allow-one-evaluation <al>
               ^unevaluated-operator <i>)
-->
    (<s> ^operator <o> +)
    (<o> ^name evaluate-operator
         ^superoperator <i>
         ^current-evaluation-depth <ced>
         ^remaining-operators <ro>)}
sp {apply*evaluate-operator*clean-up-evaluations
    (state <s> ^operator <op>
               ^evaluation <e2>)
    (<op> ^name evaluate-operator
          ^current-evaluation-depth <ced>
          ^remaining-operators <ro>)
    (<e2> ^value true)
   -(<e2> ^current-evaluation-depth <ced>)
-->
    (<s> ^evaluation <e2> -)
}
sp {selection*elaborate*evaluate-operator*remaining-operators*current-evaluation-depth
   :default
    (state <s> ^name selection
               ^current-evaluation-depth <ced>
               ^remaining-operators <ro>
               ^operator <o>
               ^evaluation <e>)
    (<o> ^name evaluate-operator
         ^evaluation <e>)
-->
    (<e> ^remaining-operators <ro>
         ^current-evaluation-depth <ced>)}
sp {selection*elaboration*top-selection
    (state <s> ^name selection
              -^superstate.superstate.name selection)
-->
    (<s> ^top-selection true)
}
sp {selection*elaboration*not-top-selection
    (state <s> ^name selection
               ^superstate.superstate.name selection)
-->
    (<s> ^top-selection false)
}
sp {selection*compare*same-symbolic-evaluations-are-indifferent
   :default
    (state <s> ^name selection
               ^superstate <ss>
               ^evaluation <e1>  { <> <e1> <e2> })
    (<ss> ^desired <d>)
    (<e1> ^superoperator <x>
          ^symbolic-value { <> partial-success <> depth-exceeded <v> }
          ^desired <d>)
    (<e2> ^superoperator <y>
          ^symbolic-value <v>
          ^desired <d>)
-->
    (<ss> ^operator <x> = <y>)}
sp {selection*monitor*depth
    (state <s> ^name selection
               ^current-evaluation-depth <ced>
               ^remaining-operators <ro>)
-->
    (write (crlf) |Depth: | <ced> |, | <ro>)
}
sp {selection*propose*init-current-evaluation-depth*top-selection
    (state <s> ^name selection
               ^top-selection true
              -^current-evaluation-depth
              -^superstate.start-depth)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name init-current-evaluation-depth
          ^value 1)
}
sp {selection*propose*init-current-evaluation-depth*top-selection*start-depth
    (state <s> ^name selection
               ^top-selection true
              -^current-evaluation-depth
               ^superstate.start-depth <sd>)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name init-current-evaluation-depth
          ^value <sd>)
}
sp {apply*init-current-evaluation-depth
    (state <s> ^operator <op>)
    (<op> ^name init-current-evaluation-depth
          ^value <v>)
-->
    (<s> ^current-evaluation-depth <v>)
}
sp {apply*init-current-evaluation-depth*max
    (state <s> ^top-selection true
               ^operator <op>)
    (<op> ^name init-current-evaluation-depth)
-->
    (<s> ^max-evaluation-depth 50)
}
sp {selection*propose*increment-current-evaluation-depth
    (state <s> ^name selection
               ^top-selection true
               ^remaining-operators 0
               ^current-evaluation-depth <ced>
               ^item-count <toc>)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name increment-current-evaluation-depth
          ^current-evaluation-depth <ced>)
}
sp {apply*increment-current-evaluation-depth
    (state <s> ^operator <op>
               ^item-count <toc>
               ^remaining-operators 0
               ^current-evaluation-depth <ced>)
    (<op> ^name increment-current-evaluation-depth)
-->
    (<s> ^remaining-operators <toc> 0 -
         ^current-evaluation-depth (+ 1 <ced>) <ced> -)
}
sp {apply*increment-current-evalaution*clean-up-evaluations
    (state <s> ^operator <op>
               ^evaluation <e2>)
    (<op> ^name increment-current-evaluation-depth
          ^current-evaluation-depth <ced>)
    (<e2> ^value true)
-->
    (<s> ^evaluation <e2> -)
}
sp {selection*elaborate*no-remaining-operators
    (state <s> ^name selection)
-->
    (<s> ^no-remaining-operators <n>)
}
sp {selection*propose*init-remaining-operators
    (state <s> ^name selection
               ^no-remaining-operators <n>
               ^item-count <toc>)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name init-remaining-operators
          ^value <toc>)
}
sp {apply*init-remaining-operators
    (state <s> ^operator <op>
               ^no-remaining-operators <n>)
    (<op> ^name init-remaining-operators
          ^value <toc>)
-->
    (<s> ^remaining-operators <toc>)
    (<s> ^no-remaining-operators <n> -)
}
sp {selection*propose*decrement-remaining-operators
    (state <s> ^name selection
               ^current-evaluation-depth <ced>
               ^remaining-operators <ro>
               ^evaluation <e>)
    (<e> ^current-evaluation-depth <ced>
         ^remaining-operators <ro>
         ^value true)
-->
    (<s> ^operator <op> + =, >)
    (<op> ^name decrement-remaining-operators)
}
sp {apply*decrement-remaining-operators
    (state <s> ^operator <op>
               ^remaining-operators <ro>)
    (<op> ^name decrement-remaining-operators)
-->
    (<s> ^remaining-operators (- <ro> 1)
                             <ro> -)
}
sp {default*elaborate*state*io
   "Elaborate each substate with io pointer."
   :default
    (state <s> ^impasse no-change
               ^superstate.io <io>)
-->
    (<s> ^io <io>)}
sp {elaborate*state*operator*name
   "Elaborate substates with name of operator."
   :default
    (state <s> ^superstate.operator.name <name>)
-->
    (<s> ^name <name>)}
sp {top-ps*propose*wait
   "Propose wait if there is a state no-change."
   :default
    (state <s> ^attribute state
               ^choices none
              -^operator.name wait)
-->
    (<s> ^operator <o> + <)
    (<o> ^name wait)}
sp {top-ps*apply*wait*random
   "Fake production just to avoid extra operator no-change."
   :default
    (state <s> ^operator <o>)
    (<o> ^name wait)
-->
    (<o> ^random elaboration)}
sp {default*top-goal*halt*operator*failure
   "Halt if no operator can be selected for the top goal."
   :default
    (state <s> ^superstate nil)
    (state <ss> ^impasse constraint-failure ^superstate <s>)
-->
    (write (crlf) |No operator can be selected for top goal.| )
    (write (crlf) |Soar must halt.| )
    (halt)}
sp {default*select*indifferent-and-worst*tied
   "Indifferent an object if it leads to a tie that can not be resolved."
   :default
    (state <s1> ^operator <o> +)
    (state <s2> ^superstate <s1>
                ^item <o>
                ^quiescence t)
    (state <s3> ^attribute state
                ^choices none
                ^superstate <s2>
                ^quiescence t)
-->
    (<s1> ^operator <o> =, < )}
sp {default*select*reject*conflict
   "Reject an object if it leads to a conflict that can not be resolved."
   :default
    (state <s1> ^operator <o> +)
    (state <s2> ^impasse conflict
                ^attribute operator
                ^superstate <s1>
                ^item <o>
                ^quiescence t)
    (state <s3> ^attribute state
                ^choices none
                ^superstate <s2>
                ^quiescence t)
-->
    (<s1> ^operator <o> -)}
sp {elaborate*top-state*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)
}
sp {elaborate*state*name
    (state <s> ^superstate.operator.name <name>)
-->
    (<s> ^name <name>)
}
sp {elaborate*state*top-state
    (state <s> ^superstate.top-state <ts>)
-->
    (<s> ^top-state <ts>)
}
sp {elaborations*elaborate*state*digit-cue
    (state <s> ^digit <d>)
    (<d> ^word <word>
         ^number <number>)
-->
    (<d> ^cue <c>)
    (<c> ^word <word>
         ^number <number>)
}
sp {elaborations*elaborate*state*bad-retrieval*gm
    (state <s> ^epmem.result.graph-match 0)
-->
    (write |BAD RETRIEVAL!!!|)
    (halt)
}
sp {testing*propose*testing-convert
    (state <s> ^name testing
               ^superstate <ss>)
    (<ss> ^episode <ep>
          ^size.number <size>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name testing-convert
          ^type convert
          ^number <ep>
          ^places <size>)
}
sp {apply*testing-convert
    (state <s> ^operator <op>
               ^convert-result <r>
               ^superstate <ss>)
    (<op> ^name testing-convert)
-->
    (<ss> ^convert-result <r>)
}
sp {count-epmem*propose*storing
    (state <s> ^name count-epmem
               ^mode storing)
-->
    (<s> ^operator <op> + =)
    (<op> ^name storing)
}
sp {count-epmem*elaborate*storing
    (state <s> ^name count-epmem
               ^mode storing
               ^digit <d>
               ^smem.command <cmd>)
-->
    (<cmd> ^store <d>)
}
sp {apply*storing*done
    (state <s> ^operator <op>
               ^mode storing)
    (<op> ^name storing)
-->
    (<s> ^mode storing - recording
         ^lti t)
}
sp {convert*propose*convert-done
    (state <s> ^name convert
               ^current <p>
               ^places <p>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name convert-done)
}
sp {apply*convert-done
    (state <s> ^operator <op>
               ^superstate <ss>
               ^result <r>)
    (<op> ^name convert-done)
-->
    (<ss> ^convert-result <r>)
}
sp {convert*elaborate*substate
    (state <s> ^superstate.operator <so>)
    (<so> ^type convert
          ^number <n>
          ^places <p>)
-->
    (<s> ^name convert
         ^number <n>
         ^places <p>)
}
sp {convert*propose*convert-init
    (state <s> ^name convert
              -^current)
-->
    (<s> ^operator <op> + =)
    (<op> ^name convert-init)
}
sp {apply*convert-init
    (state <s> ^operator <op>)
    (<op> ^name convert-init)
-->
    (<s> ^result <r>
         ^current 0
         ^pow-ten 10)
}
sp {convert*propose*convert-digit
    (state <s> ^name convert
               ^current <c>
               ^places {<> <c>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name convert-digit)
}
sp {apply*convert-digit*intermediate
    (state <s> ^operator <op>
               ^pow-ten <pow-ten>
               ^number <n>)
    (<op> ^name convert-digit)
-->
    (<s> ^intermediate (int (mod (int (* (/ <n> <pow-ten>) 10)) 10)))
}
sp {apply*convert-digit
    (state <s> ^operator <op>
               ^current <c>
               ^intermediate <i>
               ^pow-ten <pow-ten>
               ^result <r>
               ^top-state.digit <digit-c> <digit-i>)
    (<op> ^name convert-digit)
    (<digit-c> ^previous.number <c>
               ^word <word-current>)
    (<digit-i> ^number <i>)
-->
    (<s> ^current <c> - (+ <c> 1)
         ^pow-ten <pow-ten> - (* <pow-ten> 10)
         ^intermediate <i> -)
    (<r> ^<word-current> <digit-i>)
}
sp {power*elaborate*substate
    (state <s> ^superstate.operator <so>)
    (<so> ^type power
          ^x <x>
          ^y <y>)
-->
    (<s> ^name power
         ^x <x>
         ^y <y>)
}
sp {power*propose*power-init
    (state <s> ^name power
              -^result)
-->
    (<s> ^operator <op> + =)
    (<op> ^name power-init)
}
sp {apply*power-init
    (state <s> ^operator <op>)
    (<op> ^name power-init)
-->
    (<s> ^result 1
         ^current 0)
}
sp {power*propose*power-done
    (state <s> ^name power
               ^current <y>
               ^y <y>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name power-done)
}
sp {apply*power-done
    (state <s> ^operator <op>
               ^superstate.operator <ss-op>
               ^result <r>)
    (<op> ^name power-done)
-->
    (<ss-op> ^result <r>)
}
sp {power*propose*power-next
    (state <s> ^name power
               ^current <c>
               ^y {<> <c>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name power-next)
}
sp {apply*power-next
    (state <s> ^operator <op>
               ^current <c>
               ^x <x>
               ^result <r>)
    (<op> ^name power-next)
-->
    (<s> ^result <r> -
         ^result (* <r> <x>)
         ^current <c> -
         ^current (+ <c> 1))
}
sp {count-epmem*propose*recording
    (state <s> ^name count-epmem
               ^mode recording
               ^episode <ep>
               ^max {<> <ep>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name recording)
}
sp {apply*recording*clean-old
    (state <s> ^operator <op>
               ^io.output-link <out>
               ^episode <ep>
               ^symbolic <sym>)
    (<op> ^name recording)
    (<out> ^record {<> <ep> <ep-old>})
    (<sym> ^episode <ep-old>)
-->
    (<out> ^record <ep-old> -)
    (<s> ^symbolic <sym> -)
}
sp {apply*recording*copy-symbolic
    (state <s> ^operator <op>
               ^episode <ep>
               ^convert-result <r>)
    (<op> ^name recording)
-->
    (<s> ^symbolic.converted <c>)
}
sp {apply*recording*copy-result
    (state <s> ^operator <op>
               ^convert-result.<digit-name> <digit>
               ^symbolic.converted <c>)
    (<op> ^name recording)
-->
    (<c> ^<digit-name> <digit>)
}
sp {apply*recording*sym-episode
    (state <s> ^operator <op>
               ^symbolic <sym>
               ^episode <ep>
               ^convert-result <r>)
    (<op> ^name recording)
    (<sym> ^converted <c>)
   -{(<r> ^<attr> <val>)
   -(<c> ^<attr> <val>)}
-->
    (<sym> ^episode <ep>)
}
sp {apply*recording*done
    (state <s> ^operator <op>
               ^episode <ep>
               ^symbolic.episode <ep>
               ^io.output-link <out>
               ^convert-result <r>)
    (<op> ^name recording)
-->
    (<s> ^episode <ep> - (+ <ep> 1)
         ^convert-result <r> -)
    (<out> ^record <ep>)
}
sp {count-epmem*propose*done
    (state <s> ^name count-epmem
               ^mode testing
               ^counter <ct>
               ^max <ct>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name done)
}
sp {apply*done
    (state <s> ^operator <op>)
    (<op> ^name done)
-->
    (write |COUNTING TEST SUCCEEDED!|)
    (halt)
}
sp {count-epmem*propose*switch
    (state <s> ^name count-epmem
               ^mode recording
               ^episode <max>
               ^max <max>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name switch)
}
sp {apply*switch*ep*increment
    (state <s> ^operator <op>
               ^mode recording
               ^episode <max>
               ^test-mode increment)
    (<op> ^name switch)
-->
    (<s> ^episode <max> - 1)
}
sp {apply*switch*ep*single
    (state <s> ^operator <op>
               ^mode recording
               ^episode <max>
               ^test-mode single
               ^test-ep <test-ep>)
    (<op> ^name switch)
-->
    (<s> ^episode <max> - <test-ep>)
}
sp {apply*switch*ready
    (state <s> ^operator <op>
               ^symbolic <sym>
               ^io.output-link <out>
               ^mode recording
               ^episode <max>)
    (<op> ^name switch)
    (<out> ^record <old>)
    (<sym> ^episode <old>)
-->
    (<s> ^symbolic <sym> -
         ^mode recording - testing
         ^counter 1)
    (<out> ^record <old> -)
    (write |STORAGE DONE (| <max> | episodes) - READY TO BEGIN QUERY|)
    (interrupt)
}
sp {propose*initialize-count-epmem
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-count-epmem)
}
sp {apply*initialize-count-epmem
    (state <s> ^operator <op>)
    (<op> ^name initialize-count-epmem)
-->
    (<s> ^name count-epmem
         ^digit <d0> <d1> <d2> <d3> <d4> <d5> <d6> <d7> <d8> <d9>
         ^episode 1
         ^mode storing           # << storing recording >> set to storing to convert all digits to long-term identifiers before recording episodes
         ^size <d2>              # set to a digit identifier to determine number of stored episodes/test queries (max = 10^(size.number)-1)
         ^test-mode increment    # << increment single >>
         ^test-ep 1)             # if single, the episode to test
    (<d0> ^word zero
          ^number 0
          ^next <d1>
          ^previous nil)
    (<d1> ^word one
          ^number 1
          ^next <d2>
          ^previous <d0>)
    (<d2> ^word two
          ^number 2
          ^next <d3>
          ^previous <d1>)
    (<d3> ^word three
          ^number 3
          ^next <d4>
          ^previous <d2>)
    (<d4> ^word four
          ^number 4
          ^next <d5>
          ^previous <d3>)
    (<d5> ^word five
          ^number 5
          ^next <d6>
          ^previous <d4>)
    (<d6> ^word six
          ^number 6
          ^next <d7>
          ^previous <d5>)
    (<d7> ^word seven
          ^number 7
          ^next <d8>
          ^previous <d6>)
    (<d8> ^word eight
          ^number 8
          ^next <d9>
          ^previous <d7>)
    (<d9> ^word nine
          ^number 9
          ^next nil
          ^previous <d8>)
}
sp {recording*propose*recording-convert
    (state <s> ^name recording
               ^superstate <ss>)
    (<ss> ^episode <ep>
          ^size.number <size>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name recording-convert
          ^type convert
          ^number <ep>
          ^places <size>)
}
sp {apply*recording-convert
    (state <s> ^operator <op>
               ^convert-result <r>
               ^superstate <ss>)
    (<op> ^name recording-convert)
-->
    (<ss> ^convert-result <r>)
}
sp {count-epmem*propose*testing
    (state <s> ^name count-epmem
               ^mode testing
               ^counter <ct>
               ^max {<> <ct>})
-->
    (<s> ^operator <op> + =)
    (<op> ^name testing)
}
sp {apply*testing*copy-symbolic
    (state <s> ^operator <op>
               ^episode <ep>
               ^convert-result <r>
               ^epmem.command <cmd>)
    (<op> ^name testing)
-->
    (<cmd> ^query <q>)
    (<q> ^symbolic <sym>)
    (<sym> ^episode <ep>
           ^converted <c>)
}
sp {apply*testing*copy-result*cue
    (state <s> ^operator <op>
               ^convert-result.<digit-name> <digit>
               ^epmem.command.query.symbolic.converted <c>
              -^lti t)
    (<op> ^name testing)
    (<digit> ^cue <digit-cue>)
-->
    (<c> ^<digit-name> <digit-cue>)
}
sp {apply*testing*copy-result*lti
    (state <s> ^operator <op>
               ^convert-result.<digit-name> <digit>
               ^epmem.command.query.symbolic.converted <c>
               ^lti t)
    (<op> ^name testing)
-->
    (<c> ^<digit-name> <digit>)
}
sp {apply*testing*next
    (state <s> ^operator <op>
               ^epmem <epmem>
               ^convert-result <r>
               ^counter <ct>)
    (<op> ^name testing)
    (<epmem> ^command <cmd>
             ^result.graph-match 1)
    (<cmd> ^query <q>)
-->
    (<s> ^convert-result <r> -
         ^counter <ct> - (+ <ct> 1))
    (<cmd> ^query <q> -)
}
sp {apply*testing*next*increment
    (state <s> ^operator <op>
               ^epmem.result.graph-match 1
               ^test-mode increment
               ^episode <ep>)
    (<op> ^name testing)
-->
    (<s> ^episode <ep> - (+ <ep> 1))
}
sp {count-epmem*propose*max
    (state <s> ^name count-epmem
               ^size.number <size>
              -^max)
-->
    (<s> ^operator <op> + =)
    (<op> ^name max
          ^type power
          ^x 10
          ^y <size>)
}
sp {apply*max
    (state <s> ^operator <op>)
    (<op> ^name max
          ^result <r>)
-->
    (<s> ^max <r>)
}
smem --set timers off
smem --set learning on
epmem --set trigger output
epmem --set phase output
epmem --set graph-match on
epmem --set timers off
epmem --set learning on
watch 0
timers --off
chunk always
sp {top-state*elaborate*missionaries-and-cannibals
    (state <s> ^superstate nil)
-->
    (<s> ^name mac)}
sp {mac*elaborate*problem-space
    (state <s> ^name mac)
-->
    (<s> ^problem-space <p>)
    (<p> ^name missionaries-and-cannibals
         ^default-state-copy yes
         ^two-level-attributes right-bank left-bank)}
sp {mac*elaborate*initial-state
    (state <s> ^superstate nil
               ^name mac)
-->
    (<s> ^right-bank <r>
         ^left-bank <l>
         ^desired <d>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*operator*move-mac-boat1
    "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 0
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 1
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat2
    "Moves two missionaries or two cannibals."
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 1
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 2
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat11
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^missionaries > 0
            ^cannibals > 0
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^missionaries 1
         ^cannibals 1
         ^boat 1
         ^types 2)}
sp {apply*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << missionaries cannibals boat >> <type> } <num>
         ^bank <bank>
         ^types <types>)
    (<bank> ^<type> <bank-num>
            ^other-bank <obank>)
    (<obank> ^<type> <obank-num>)
-->
    (<bank> ^<type> <bank-num> -
    (- <bank-num> <num>))
    (<obank> ^<type> <obank-num> -
    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^<bank> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
    (<dls> ^missionaries <m>
           ^cannibals <c>)
-->
    (<s> ^success <d>)
    (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^missionaries { <n> > 0 }
            ^cannibals > <n>)
-->
    (write (crlf) |Failure!|)
    (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*state-no-change
    (state <s> ^desired <d>
               ^problem-space.name missionaries-and-cannibals)
    (state <ss> ^superstate <s>
                ^attribute state
                ^quiescence t
                ^impasse no-change)
-->
    (write (crlf) |######## STATE NO-CHANGE Failure! #########|)
    (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*duplicate
    (state <s1> ^desired <d>
                ^right-bank <rb>
                ^left-bank <lb>)
    (<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
    (state { <> <s1> <s2> }
^right-bank <rb2>
^left-bank <lb2>
^tried-tied-operator)
    (<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
   -(state <s3> ^superstate <s2>)
-->
    (write (crlf) |Duplicate State Detected.|)
    (<s2> ^failure <d>)}
sp {monitor*move-mac-boat*evaluation
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator
         ^operator <to>)
    (<to> ^name move-mac-boat
          ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Evaluate move | <number> | | <type>)}
sp {elaborate*top-state*name
    (state <s> ^superstate nil)
-->
    (<s> ^name mac)
}
sp {monitor*move-boat
    (state <s> ^operator <o>)
    (<o> ^name move-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^<bank> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
    (<dls> ^missionaries <m>
           ^cannibals <c>)
-->
    (<s> ^success <d>)
    (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^missionaries { <n> > 0 }
            ^cannibals > <n>)
-->
    (write (crlf) |Failure!|)
    (<s> ^failure <d>)}
sp {mac*elaborate*problem-space
    (state <s> ^name mac)
-->
    (<s> ^problem-space <p>)
    (<p> ^name missionaries-and-cannibals
         ^default-state-copy yes
         ^two-level-attributes right-bank left-bank)}
sp {mac*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> + =)
    (<o> ^name initialize-mac-planning)
}
sp {mac*apply*initialize
    (state <s> ^operator.name initialize-mac-planning)
-->
    (<s> ^name mac
         ^left-bank <l>
         ^right-bank <r>
         ^desired <d>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*initialize
    (state <s> ^name mac
              -^left-bank)
-->
    (<s> ^operator <o> + =)
    (<o> ^name initialize)
}
sp {mac*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^name mac
         ^left-bank <l>
         ^right-bank <r>
         ^desired <d>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
output warnings on
output warnings off
sp {mac*evaluate*state*failure*duplicate
    (state <s1> ^desired <d>
                ^right-bank <rb>
                ^left-bank <lb>)
    (<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
    ( { <> <s1> <s2> }
^right-bank <rb2>
^left-bank <lb2>
^tried-tied-operator)
    (<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
   -(state <s3> ^superstate <s2>)
-->
    (write (crlf) |Duplicate State Detected.|)
    (<s2> ^failure <d>)}
output warnings on
output warnings off
sp {mac*evaluate*state*failure*state-no-change
    (state <s> ^desired <d>
               ^problem-space.name missionaries-and-cannibals)
    (state <ss> ^superstate <s>
                ^attribute state
                ^quiescence t
                ^impasse no-change)
-->
    (write (crlf) |######## STATE NO-CHANGE Failure! #########|)
    (<s> ^failure <d>)}
sp {monitor*move-mac-boat*evaluation
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator
         ^operator <to>)
    (<to> ^name move-boat
          ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Evaluate move | <number> | | <type>)}
sp {mac*propose*operator*move-boat1
   "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 0
            ^boat 1)
-->
    (<s> ^operator <o> +)
    (<o> ^name move-boat
         ^bank <bank>
         ^<type> 1
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-boat2
   "Moves two missionaries or two cannibals."
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 1
            ^boat 1)
-->
    (<s> ^operator <o> +)
    (<o> ^name move-boat
         ^bank <bank>
         ^<type> 2
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-boat11
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^missionaries > 0
            ^cannibals > 0
            ^boat 1)
-->
    (<s> ^operator <o> +)
    (<o> ^name move-boat
         ^bank <bank>
         ^missionaries 1
         ^cannibals 1
         ^boat 1
         ^types 2)}
sp {apply*move-boat
    (state <s> ^operator <o>)
    (<o> ^name move-boat
         ^{ << missionaries cannibals boat >> <type> } <num>
         ^bank <bank>
         ^types <types>)
    (<bank> ^<type> <bank-num>
            ^other-bank <obank>)
    (<obank> ^<type> <obank-num>)
-->
    (<bank> ^<type> <bank-num> -
    (- <bank-num> <num>))
    (<obank> ^<type> <obank-num> -
    (+ <obank-num> <num>))}
chunk always
multi-attributes holds 3
chunk never
sp {mac*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> + =)
    (<o> ^name initialize-mac)
}
sp {mac*apply*initialize
    (state <s> ^operator.name initialize-mac)
-->
    (<s> ^name mac
         ^holds <h1> <h2> <h3> <h4>
         ^boat <leftbank>
         ^desired <d>)
    (<h1> ^type missionaries
          ^number 3
          ^opposite <h3>
          ^side <leftbank>)
    (<h2> ^type cannibals
          ^number 3
          ^opposite <h4>
          ^side <leftbank>)
    (<h3> ^type missionaries
          ^number 0
          ^opposite <h1>
          ^side <rightbank>)
    (<h4> ^type cannibals
          ^number 0
          ^opposite <h2>
          ^side <rightbank>)
    (<leftbank> ^name leftbank
                ^opposite-of <rightbank>)
    (<rightbank> ^name rightbank
                 ^opposite-of <leftbank>)
}
sp {mac*elaborate*problem-space
    (state <s> ^name mac)
-->
    (<s> ^problem-space <p>)
    (<p> ^name missionaries-and-cannibals
         ^default-state-copy yes
         ^one-level-attributes boat
         ^two-level-attributes holds)}
sp {mac*propose*operator*move1
    "Moves either a single missionary or a cannibal."
    (state <s> ^problem-space.name missionaries-and-cannibals
               ^holds <h1>
               ^boat <f>)
    (<h1> ^number { <n> <> 0 }
          ^side <f>)
-->
    (<s> ^operator <o>)
    (<o> ^name move1
         ^holds <h1>)}
sp {mac*propose*operator*move2
    "Moves either a single missionary or a cannibal."
    (state <s> ^problem-space.name missionaries-and-cannibals
               ^holds <h1>
               ^boat <f>)
    (<h1> ^number > 1
          ^side <f>)
-->
    (<s> ^operator <o>)
    (<o> ^name move2
         ^holds <h1>)}
sp {mac*propose*operator*move11
    "Moves either a single missionary or a cannibal."
    (state <s> ^problem-space.name missionaries-and-cannibals
               ^holds <h1> <h2>
               ^boat <f>)
    (<h1> ^type cannibals
          ^number { <n1> <> 0}
          ^side <f>)
    (<h2> ^type missionaries
          ^number { <n2> <> 0 }
          ^side <f>)
-->
    (<s> ^operator <o>)
    (<o> ^name move11
         ^holds <h1> <h2>)}
sp {apply*move1
    (state <s> ^operator <o>)
    (<o> ^name << move1 move11 >>
         ^holds <h1>)
    (<h1> ^number <r1>
          ^opposite <il>)
    (<il> ^number <l1>)
-->
    (<h1> ^number <r1> -
    (- <r1> 1))
    (<il> ^number <l1> -
    (+ <l1> 1))}
sp {apply*move2
    (state <s> ^operator <o>)
    (<o> ^name move2
         ^holds <h1>)
    (<h1> ^number <r1>
          ^opposite <h2>)
    (<h2> ^number <l1>)
-->
    (<h1> ^number <r1> -
    (- <r1> 2))
    (<h2> ^number <l1> -
    (+ <l1> 2))}
sp {apply*move-boat
    (state <s> ^operator <o>
               ^boat <x>)
    (<o> ^name << move1 move2 move11 >>
         ^holds.side <x>)
    (<x> ^opposite-of <y>)
-->
    (<s> ^boat <y> <x> -)}
sp {monitor*move1
    (state <s> ^operator <o>)
    (<o> ^name << move1 move11 >>
         ^holds.type <m>)
-->
    (write (crlf) | Move one | <m>)}
sp {monitor*move2
    (state <s> ^operator <o>)
    (<o> ^name move2
         ^holds.type <m>)
-->
    (write (crlf) | Move two | <m>)}
sp {monitor*move-side
    (state <s> ^operator <o>)
    (<o> ^name << move1 move2 move11 >>
         ^holds.side <x>)
    (<x> ^opposite-of.name <side2>
         ^name <side1>)
-->
    (write (crlf) | From | <side1> | to | <side2>)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^holds <h1> <h2>)
    (<h1> ^type missionaries
          ^number { <n> > 0 }
          ^side <loc>)
    (<h2> ^type cannibals
          ^number > <n>
          ^side <loc>)
-->
    (<s> ^failure <d>)
    (write (crlf) |Failure - too many cannibals on side:| <loc>)}
sp {mac*evaluate*state*failure*state-no-change
    (state <s> ^desired <d>
               ^problem-space.name missionaries-and-cannibals)
    (state <ss> ^superstate <s>
                ^attribute state
                ^quiescence t
                ^impasse no-change)
-->
    (<s> ^failure <d>)
    (write (crlf) |Failure - no operators can apply.|)}
sp {mac*evaluate*state*failure*detect-state-duplicate
    (state <s> ^holds <a1> <a2>
               ^desired <d>)
    (<a1> ^type missionaries
          ^number 0
          ^side <side>)
    (<a2> ^type cannibals
          ^number 0
          ^side <side>)
    (state { <> <s> <ss> } ^desired <d>
                           ^holds <b1> <b2>
                           ^tried-tied-operator)
    (<b1> ^type missionaries
          ^number 0
          ^side <side>)
    (<b2> ^type cannibals
          ^number 0
          ^side <side>)
   -(state <sss> ^superstate <ss>)
-->
    (<ss> ^failure <d>)
    (write (crlf) |Failure - Duplicate State.|)}
    ## This also defines implicitly the desired state
    ## of the problem.
    #
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^holds <h1> <h2>)
    (<h1> ^type missionaries
          ^number 3
          ^side <loc>)
    (<h2> ^type cannibals
          ^number 3
          ^side <loc>)
    (<loc> ^name rightbank)
-->
    (<s> ^success <d>)
    (write (crlf) |Success.|)}
sp {monitor*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
chunk never
sp {mac*elaborate*initial*desired-state
    (state <s> ^superstate nil)
-->
    (<s> ^name mac
         ^left-bank <l>
         ^right-bank <r>
         ^desired <d>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*operator*move-mac-boat1
    "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 0
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 1
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat2
    "Moves two missionaries or two cannibals."
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 1
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 2
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat11
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^missionaries > 0
            ^cannibals > 0
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^missionaries 1
         ^cannibals 1
         ^boat 1
         ^types 2)}
sp {apply*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << missionaries cannibals boat >> <type> } <num>
         ^bank <bank>)
    (<bank> ^<type> <bank-num>
            ^other-bank <obank>)
    (<obank> ^<type> <obank-num>)
-->
    (<bank> ^<type> <bank-num> -
    (- <bank-num> <num>))
    (<obank> ^<type> <obank-num> -
    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^<side> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <side> } <dls>)
    (<dls> ^missionaries <m>
           ^cannibals <c>)
-->
    (write (crlf) |The problem has been solved.|)
    (halt)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^missionaries { <n> > 0 }
            ^cannibals > <n>)
-->
    (write (crlf) |Failure State.|)
    (<s> ^failure <d>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*1
    (state <s> ^name mac
               ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^{ << missionaries cannibals >> <type> } <n>
         ^types 1)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^types 1
          ^bank <bank>
          ^type <type>
          ^number <n>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*2
    (state <s> ^name mac
               ^operator <o>)
    (<o> ^name move-mac-boat
         ^boat <bank>
         ^types 2)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^types 2
          ^bank <bank>)}
sp {mac*apply*move-mac-boat*remove*old*last-operator
    (state <s> ^name mac
               ^operator <o>
               ^<lr-bank>.other-bank <o-bank>
               ^last-operator <lo>)
    (<lo> ^bank <obank>)
-->
    (<s> ^last-operator <lo> -)}
sp {mac*select*operator*prefer*inverse*failure*types*1
    (state <s> ^name mac
               ^operator <o> +
               ^failure <d>
               ^last-operator <lo>)
    (<o> ^name move-mac-boat
         ^<type> <number>
         ^types 1)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
    (<s> ^operator <o> >)}
sp {mac*select*operator*prefer*inverse*failure*types*2
    (state <s> ^name mac
               ^operator <o> +
               ^failure <d>
               ^last-operator.types 2)
    (<o> ^types 2)
-->
    (<s> ^operator <o> >)}
sp {mac*select*operator*avoid*inverse*not*failure*1
    (state <s> ^name mac
               ^operator <o> +
              -^failure <d>
               ^last-operator <lo>)
    (<o> ^types 1
         ^<type> <number>)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
    (<s> ^operator <o> < )}
sp {mac*select*operator*avoid*inverse*not*failure*2
    (state <s> ^name mac
               ^operator <o> +
              -^failure <d>
               ^last-operator.types 2)
    (<o> ^types 2)
-->
    (<s> ^operator <o> < )}
sp {mac*select*operator*prefer*inverse*failure*types*1
    (state <s> ^name mac
               ^operator <o> +
               ^failure <d>
               ^last-operator <lo>)
    (<o> ^name move-boat
         ^<type> <number>
         ^types 1)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
    (<s> ^operator <o> >)}
sp {mac*select*operator*prefer*inverse*failure*types*2
    (state <s> ^name mac
               ^operator <o> +
               ^failure <d>
               ^last-operator.types 2)
    (<o> ^types 2)
-->
    (<s> ^operator <o> >)}
sp {mac*select*operator*avoid*inverse*not*failure*1
    (state <s> ^name mac
               ^operator <o> +
              -^failure <d>
               ^last-operator <lo>)
    (<o> ^types 1
         ^<type> <number>)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
    (<s> ^operator <o> < )}
sp {mac*select*operator*avoid*inverse*not*failure*2
    (state <s> ^name mac
               ^operator <o> +
              -^failure <d>
               ^last-operator.types 2)
    (<o> ^types 2)
-->
    (<s> ^operator <o> < )}
sp {monitor*move-boat
    (state <s> ^operator <o>)
    (<o> ^name move-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^<side> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <side> } <dls>)
    (<dls> ^missionaries <m>
           ^cannibals <c>)
-->
    (write (crlf) |The problem has been solved.|)
    (halt)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^missionaries { <n> > 0 }
            ^cannibals > <n>)
-->
    (write (crlf) |Failure State.|)
    (<s> ^failure <d>)}
sp {mac*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> + =)
    (<o> ^name initialize-mac)
}
sp {mac*apply*initialize
    (state <s> ^operator.name initialize-mac)
-->
    (<s> ^name mac
         ^left-bank <l>
         ^right-bank <r>
         ^desired <d>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*initialize
    (state <s> ^name mac
              -^left-bank)
-->
    (<s> ^operator <o> + =)
    (<o> ^name initialize)
}
sp {mac*apply*initialize
    (state <s> ^operator.name initialize)
-->
    (<s> ^name mac
         ^left-bank <l>
         ^right-bank <r>
         ^desired <d>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<d> ^right-bank <dl>)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*operator*move-boat1
   "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 0
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-boat
         ^bank <bank>
         ^<type> 1
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-boat2
   "Moves two missionaries or two cannibals."
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 1
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-boat
         ^bank <bank>
         ^<type> 2
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-boat11
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^missionaries > 0
            ^cannibals > 0
            ^boat 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-boat
         ^bank <bank>
         ^missionaries 1
         ^cannibals 1
         ^boat 1
         ^types 2)}
sp {apply*move-boat
    (state <s> ^operator <o>)
    (<o> ^name move-boat
         ^{ << missionaries cannibals boat >> <type> } <num>
         ^bank <bank>)
    (<bank> ^<type> <bank-num>
            ^other-bank <obank>)
    (<obank> ^<type> <obank-num>)
-->
    (<bank> ^<type> <bank-num> -
    (- <bank-num> <num>))
    (<obank> ^<type> <obank-num> -
    (+ <obank-num> <num>))}
sp {mac*apply*move-boat*record*last-operator*types*1
    (state <s> ^name mac
               ^operator <o>)
    (<o> ^name move-boat
         ^bank <bank>
         ^{ << missionaries cannibals >> <type> } <n>
         ^types 1)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^types 1
          ^bank <bank>
          ^type <type>
          ^number <n>)}
sp {mac*apply*move-boat*record*last-operator*types*2
    (state <s> ^name mac
               ^operator <o>)
    (<o> ^name move-boat
         ^boat <bank>
         ^types 2)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^types 2
          ^bank <bank>)}
sp {mac*apply*move-boat*remove*old*last-operator
    (state <s> ^name mac
               ^operator <o>
               ^<lr-bank>.other-bank <o-bank>
               ^last-operator <lo>)
    (<lo> ^bank <obank>)
-->
    (<s> ^last-operator <lo> -)}
chunk never
chunk always
sp {top-state*elaborate*missionaries-and-cannibals
    (state <s> ^superstate nil)
-->
    (<s> ^name mac)}
sp {mac*elaborate*problem-space
    (state <s> ^name mac)
-->
    (<s> ^problem-space <p>)
    (<p> ^name missionaries-and-cannibals
         ^default-state-copy yes
         ^two-level-attributes right-bank left-bank)}
sp {mac*elaborate*initial-state
    (state <s> ^superstate nil)
-->
    (<s> ^right-bank <r>
         ^left-bank <l>
         ^desired <d>)
    (<r> ^missionaries 0
         ^cannibals 0
         ^boat 0
         ^other-bank <l>)
    (<l> ^missionaries 3
         ^cannibals 3
         ^boat 1
         ^other-bank <r>)
    (<d> ^right-bank <dl>
         ^better higher)
    (<dl> ^missionaries 3
          ^cannibals 3
          ^boat 1)
}
sp {mac*propose*operator*move-mac-boat1
   "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 0
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 1
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat2
   "Moves two missionaries or two cannibals."
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^{ << cannibals missionaries >> <type> } > 1
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^<type> 2
         ^boat 1
         ^types 1)}
sp {mac*propose*operator*move-mac-boat11
    (state <s> ^name mac
               ^ << right-bank left-bank >> <bank>)
    (<bank> ^missionaries > 0
            ^cannibals > 0
            ^boat 1)
-->
    (<s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^bank <bank>
         ^missionaries 1
         ^cannibals 1
         ^boat 1
         ^types 2)}
sp {apply*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << missionaries cannibals boat >> <type> } <num>
         ^bank <bank>
         ^types <types>)
    (<bank> ^<type> <bank-num>
            ^other-bank <obank>)
    (<obank> ^<type> <obank-num>)
-->
    (<bank> ^<type> <bank-num> -
    (- <bank-num> <num>))
    (<obank> ^<type> <obank-num> -
    (+ <obank-num> <num>))}
sp {monitor*move-mac-boat
    (state <s> ^operator <o>)
    (<o> ^name move-mac-boat
         ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 1)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 0)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^left-bank <l>
               ^right-bank <r>)
    (<l> ^missionaries <ml>
         ^cannibals <cl>
         ^boat 0)
    (<r> ^missionaries <mr>
         ^cannibals <cr>
         ^boat 1)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {mac*detect*state*success
    (state <s> ^desired <d>
               ^<bank> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
    (<dls> ^missionaries <m>
           ^cannibals <c>)
-->
    (<s> ^success <d>)
    (write (crlf) |Success!|)}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^desired <d>
               ^<< right-bank left-bank >> <bank>)
    (<bank> ^missionaries { <n> > 0 }
            ^cannibals > <n>)
-->
    (write (crlf) |Failure!|)
    (<s> ^failure <d>)}
sp {mac*evaluate*state*failure*duplicate
    (state <s1> ^desired <d>
                ^right-bank <rb>
                ^left-bank <lb>)
    (<rb> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
    (state { <> <s1> <s2> }
^right-bank <rb2>
^left-bank <lb2>
^tried-tied-operator)
    (<rb2> ^missionaries <rbm> ^cannibals <rbc> ^boat <rbb>)
    (<lb2> ^missionaries <lbm> ^cannibals <lbc> ^boat <lbb>)
   -(state <s3> ^superstate <s2>)
-->
    (write (crlf) |Duplicate State Detected.|)
    (<s2> ^failure <d>)}
sp {mac*evaluate*state*number
    (state <s> ^desired <d>
               ^tried-tied-operator
               ^<bank> <ls>)
    (<ls> ^missionaries <m>
          ^cannibals <c>)
    (<d> ^{ << right-bank left-bank >> <bank> } <dls>)
-->
    (<s> ^numeric-value (+ <m> <c>))
    (write (crlf) |Evaluation: | (+ <m> <c>))}
sp {monitor*move-mac-boat*evaluation
    (state <s> ^operator <o>)
    (<o> ^name evaluate-operator
         ^operator <to>)
    (<to> ^name move-mac-boat
          ^{ << cannibals missionaries >>  <type> } <number>)
-->
    (write (crlf) | Evaluate move | <number> | | <type>)}
chunk never
sp {mac*elaborate*state*name
    (state <s> ^superstate nil)
-->
    (<s> ^name mac)}
sp {mac*elaborate*initial-state
    (state <s> ^name mac)
-->
    (<s> ^missionaries <m>
         ^cannibals <c>
         ^boat <b>)
    (<b> ^left 1
         ^right 0)
    (<m> ^left 3
         ^right 0)
    (<c> ^left 3
         ^right 0)
}
sp {mac*propose*move-mac-boat*1
   "Moves either a single missionary or a cannibal."
    (state <s> ^name mac
               ^{ << cannibals missionaries >> <type> }.<bank> > 0
               ^boat.<bank> 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^types 1
         ^boat 1
         ^<type> 1)}
sp {mac*propose*move-mac-boat*2
   "Moves either a two missionaries or two cannibals."
    (state <s> ^name mac
               ^{ << cannibals missionaries >> <type> }.<bank> > 1
               ^boat.<bank> 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^types 1
         ^boat 1
         ^<type> 2)}
sp {mac*propose*move-mac-boat*11
    (state <s> ^name mac
               ^cannibals.<bank> > 0
               ^missionaries.<bank> > 0
               ^boat.<bank> 1)
-->
    (<s> ^operator <o> + =)
    (<o> ^name move-mac-boat
         ^types 2
         ^boat 1
         ^missionaries 1
         ^cannibals 1)}
sp {apply*move-mac-boat
    (state <s> ^operator <o>
               ^<type> <type-id>
               ^boat <b>)
    (<b> ^{ << left right >> <bank>  } 1
         ^{ << left right >> <obank> } 0)
    (<o> ^name move-mac-boat
         ^{ << boat missionaries cannibals >> <type> } <number>)
    (<type-id> ^<bank> <bank-num>
               ^<obank> <obank-num>)
-->
    (<type-id> ^<bank> <bank-num> -
    (- <bank-num> <number>)
^<obank> <obank-num> -
    (+ <obank-num> <number>))}
sp {mac*apply*move-mac-boat*record*last-operator*types*1
    (state <s> ^name mac
               ^operator <o>
               ^boat.<bank> 1)
    (<o> ^name move-mac-boat
         ^{ << missionaries cannibals >> <type> } <n>
         ^types 1)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^boat <bank>
          ^types 1
          ^type <type>
          ^number <n>)}
sp {mac*apply*move-mac-boat*record*last-operator*types*2
    (state <s> ^name mac
               ^operator <o>
               ^boat.<bank> 1)
    (<o> ^name move-mac-boat
         ^types 2)
-->
    (<s> ^last-operator <o1>)
    (<o1> ^types 2
          ^boat <bank>)}
sp {mac*apply*move-mac-boat*remove*old*last-operator
    (state <s> ^name mac
               ^operator.name move-mac-boat
               ^boat.<bank> 0
               ^last-operator <lo>)
    (<lo> ^boat <bank>)
-->
    (<s> ^last-operator <lo> -)}
sp {mac*select*operator*inverse*failure*types*1
    (state <s> ^name mac
               ^operator <o> +
               ^failure true
               ^last-operator <lo>)
    (<o> ^name move-mac-boat
         ^<type> <number>
         ^types 1)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
 # (write (crlf) |Undo last move.|)
    (<s> ^operator <o> > )}
sp {mac*select*operator*inverse*types*2
    (state <s> ^name mac
               ^operator <o> +
               ^failure true
               ^last-operator <lo>)
    (<o> ^types 2)
    (<lo> ^types 2)
-->
    (<s> ^operator <o> > )}
sp {mac*select*operator*inverse*not*failure*types*1
    (state <s> ^name mac
               ^operator <o> +
              -^failure true
               ^last-operator <lo>)
    (<o> ^types 1
         ^<type> <number>)
    (<lo> ^types 1
          ^type <type>
          ^number <number>)
-->
    (<s> ^operator <o> < )}
sp {mac*select*operator*inverse*not*failure*types*2
    (state <s> ^name mac
               ^operator <o> +
              -^failure true
               ^last-operator <lo>)
    (<o> ^types 2)
    (<lo> ^types 2)
-->
    (<s> ^operator <o> < )}
sp {mac*evaluate*state*failure*more*cannibals
    (state <s> ^name mac
               ^missionaries <m>
               ^cannibals <c>)
    (<m> ^<bank> { <n> > 0 })
    (<c> ^<bank> > <n>)
-->
    (write (crlf) |Failure State.|)
    (<s> ^failure true)}
    ## This implicitly defines the desired state of the problem.
    #
sp {mac*detect*state*success
    (state <s> ^name mac
               ^missionaries.right 3
               ^cannibals.right 3)
-->
    (write (crlf) |Success!|)
    (halt)}
sp {monitor*move
    (state <s> ^name mac
               ^operator <o>)
    (<o> ^{ << missionaries cannibals >> <type> } <number>)
-->
    (write | Move | <number> | | <type>)}
sp {monitor*state*left
    (state <s> ^name mac
               ^boat.left 1
               ^missionaries.left <ml>
               ^missionaries.right <mr>
               ^cannibals.left <cl>
               ^cannibals.right <cr>)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> | B ~~~   |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {monitor*state*right
    (state <s> ^name mac
               ^boat.right 1
               ^missionaries.left <ml>
               ^missionaries.right <mr>
               ^cannibals.left <cl>
               ^cannibals.right <cr>)
-->
    (write (crlf) | M: | <ml> |, C: | <cl> |   ~~~ B |
                 | M: | <mr> |, C: | <cr> |  |)}
sp {propose*hello-world
    (state <s> ^type state)
-->
    (<s> ^operator <o> +)
    (<o> ^name hello-world)
}
sp {apply*hello-world
    (state <s> ^operator <o>)
    (<o> ^name hello-world)
-->
    (write |Hello World|)
    (halt)
}
sp {eight*elaborate*problem-space
    (state <s> ^name fifteen-puzzle)
-->
    (<s> ^problem-space <p>)
    (<p> ^name fifteen-puzzle
         ^default-state-copy yes
         ^default-operator-copy no
         ^one-level-attributes blank-cell
         ^two-level-attributes binding)}
sp {eight*operator*move-tile*inverse*reject
   "Reject the operator that was applied to create this state."
    (state <s> ^problem-space.name fifteen-puzzle
               ^operator <o> +
               ^tile-cell <tc>)
    (<o> ^tile-cell <tc>)
-->
    (<s> ^operator <o> - )}
sp {eight*monitor*state
    (state <s> ^binding <x11> <x12> <x13> <x14>
                       <x21> <x22> <x23> <x24>
                       <x31> <x32> <x33> <x34>
                       <x41> <x42> <x43> <x44>)
    (<x11> ^cell.name c11 ^tile <o11>)
    (<o11> ^name <v11>)
    (<x12> ^cell.name c12 ^tile <o12>)
    (<o12> ^name <v12>)
    (<x13> ^cell.name c13 ^tile <o13>)
    (<o13> ^name <v13>)
    (<x14> ^cell.name c14 ^tile <o14>)
    (<o14> ^name <v14>)
    (<x21> ^cell.name c21 ^tile <o21>)
    (<o21> ^name <v21>)
    (<x22> ^cell.name c22 ^tile <o22>)
    (<o22> ^name <v22>)
    (<x23> ^cell.name c23 ^tile <o23>)
    (<o23> ^name <v23>)
    (<x24> ^cell.name c24 ^tile <o24>)
    (<o24> ^name <v24>)
    (<x31> ^cell.name c31 ^tile <o31>)
    (<o31> ^name <v31>)
    (<x32> ^cell.name c32 ^tile <o32>)
    (<o32> ^name <v32>)
    (<x33> ^cell.name c33 ^tile <o33>)
    (<o33> ^name <v33>)
    (<x34> ^cell.name c34 ^tile <o34>)
    (<o34> ^name <v34>)
    (<x41> ^cell.name c41 ^tile <o41>)
    (<o41> ^name <v41>)
    (<x42> ^cell.name c42 ^tile <o42>)
    (<o42> ^name <v42>)
    (<x43> ^cell.name c43 ^tile <o43>)
    (<o43> ^name <v43>)
    (<x44> ^cell.name c44 ^tile <o44>)
    (<o44> ^name <v44>)
-->
    (write (crlf)  |      ---------------------|  | | (crlf) | | )
    (write |     \||  | | <v11>  | | |\||  | | <v21>  | | |\||  | | <v31>  | | |\||  | | <v41>  | | |\||  | | (crlf) | | )
    (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
    (write |     \||  | | <v12>  | | |\||  | | <v22>  | | |\||  | | <v32>  | | |\||  | | <v42>  | | |\||  | | (crlf) | | )
    (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
    (write |     \||  | | <v13>  | | |\||  | | <v23>  | | |\||  | | <v33>  | | |\||  | | <v43>  | | |\||  | | (crlf) | | )
    (write |     \|----\|----\|----\|----\||  | | (crlf) | | )
    (write |     \||  | | <v14>  | | |\||  | | <v24>  | | |\||  | | <v34>  | | |\||  | | <v44>  | | |\||  | | (crlf) | | )
    (write |     ---------------------|  | | (crlf) | | )}
sp {eight*detect*state*success
    (state <s> ^problem-space.name fifteen-puzzle
               ^desired <d>
               ^binding <x11> <x12> <x13> <x14>
                       <x21> <x22> <x23> <x24>
                       <x31> <x32> <x33> <x34>
                       <x41> <x42> <x43> <x44>)
    (<x11> ^cell.name c11 ^tile <o11>)
    (<x12> ^cell.name c12 ^tile <o12>)
    (<x13> ^cell.name c13 ^tile <o13>)
    (<x14> ^cell.name c14 ^tile <o14>)
    (<x21> ^cell.name c21 ^tile <o21>)
    (<x22> ^cell.name c22 ^tile <o22>)
    (<x23> ^cell.name c23 ^tile <o23>)
    (<x24> ^cell.name c24 ^tile <o24>)
    (<x31> ^cell.name c31 ^tile <o31>)
    (<x32> ^cell.name c32 ^tile <o32>)
    (<x33> ^cell.name c33 ^tile <o33>)
    (<x34> ^cell.name c34 ^tile <o34>)
    (<x41> ^cell.name c41 ^tile <o41>)
    (<x42> ^cell.name c42 ^tile <o42>)
    (<x43> ^cell.name c43 ^tile <o43>)
    (<x44> ^cell.name c44 ^tile <o44>)
    (<d> ^binding <d11> <d12> <d13> <d14>
                 <d21> <d22> <d23> <d24>
                 <d31> <d32> <d33> <d34>
                 <d41> <d42> <d43> <d44>)
    (<d11> ^cell.name c11 ^tile <o11>)
    (<d12> ^cell.name c12 ^tile <o12>)
    (<d13> ^cell.name c13 ^tile <o13>)
    (<d14> ^cell.name c14 ^tile <o14>)
    (<d21> ^cell.name c21 ^tile <o21>)
    (<d22> ^cell.name c22 ^tile <o22>)
    (<d23> ^cell.name c23 ^tile <o23>)
    (<d24> ^cell.name c24 ^tile <o24>)
    (<d31> ^cell.name c31 ^tile <o31>)
    (<d32> ^cell.name c32 ^tile <o32>)
    (<d33> ^cell.name c33 ^tile <o33>)
    (<d34> ^cell.name c34 ^tile <o34>)
    (<d41> ^cell.name c41 ^tile <o41>)
    (<d42> ^cell.name c42 ^tile <o42>)
    (<d43> ^cell.name c43 ^tile <o43>)
    (<d44> ^cell.name c44 ^tile <o44>)
-->
    (<s> ^success <d>)}
    ## Define the initial state and the desired state:
    ## each state is a set of bindings#
    ## each binding points to a cell and a tile#
    ## each cell points to its neighboring cells.
sp {fifteen-puzzle*propose*initialize
    (state <s> ^name fifteen-puzzle
              -^blank-cell)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize)}
sp {eight*create*state*initial-and-desired-states
    (state <s> ^operator.name initialize
               ^desired <d>)
-->
    (<s> ^blank-cell <c44> ^tile-cell nil
         ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8> <bb9> <bb10> <bb11> <bb12> <bb13> <bb14> <bb15>)
    (<bb0>  ^cell  <c11> ^tile  <t2>)
    (<bb1>  ^cell  <c12> ^tile  <t1>)
    (<bb2>  ^cell  <c13> ^tile  <t7>)
    (<bb3>  ^cell  <c14> ^tile  <t8>)
    (<bb4>  ^cell  <c21> ^tile  <t6>)
    (<bb5>  ^cell  <c22> ^tile  <t15>)
    (<bb6>  ^cell  <c23> ^tile  <t3>)
    (<bb7>  ^cell  <c24> ^tile  <t4>)
    (<bb8>  ^cell  <c31> ^tile  <t5>)
    (<bb9>  ^cell  <c32> ^tile  <t9>)
    (<bb10> ^cell  <c33> ^tile <t10>)
    (<bb11> ^cell  <c34> ^tile <t11>)
    (<bb12> ^cell  <c41> ^tile <t12>)
    (<bb13> ^cell  <c42> ^tile <t13>)
    (<bb14> ^cell  <c43> ^tile <t14>)
    (<bb15> ^cell  <c44> ^tile <t0>)
    (<c11> ^name c11 ^cell <c12> ^cell <c21>)
    (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
    (<c13> ^name c13 ^cell <c12> ^cell <c23> ^cell <c14>)
    (<c14> ^name c14 ^cell <c13> ^cell <c24>)
    (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
    (<c22> ^name c22 ^cell <c21> ^cell <c12> ^cell <c23> ^cell <c32>)
    (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13> ^cell <c24>)
    (<c24> ^name c24 ^cell <c14> ^cell <c23> ^cell <c34>)
    (<c31> ^name c31 ^cell <c32> ^cell <c21> ^cell <c41>)
    (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33> ^cell <c42>)
    (<c33> ^name c33 ^cell <c32> ^cell <c23> ^cell <c43>)
    (<c34> ^name c34 ^cell <c33> ^cell <c24> ^cell <c44>)
    (<c41> ^name c41 ^cell <c31> ^cell <c42>)
    (<c42> ^name c42 ^cell <c41> ^cell <c32> ^cell <c43>)
    (<c43> ^name c43 ^cell <c42> ^cell <c33> ^cell <c44>)
    (<c44> ^name c44 ^cell <c43> ^cell <c34>)
    (<t0> ^name |0 |)
    (<t1> ^name |1 |)
    (<t2> ^name |2 |)
    (<t3> ^name |3 |)
    (<t4> ^name |4 |)
    (<t5> ^name |5 |)
    (<t6> ^name |6 |)
    (<t7> ^name |7 |)
    (<t8> ^name |8 |)
    (<t9> ^name |9 |)
    (<t10> ^name |10|)
    (<t11> ^name |11|)
    (<t12> ^name |12|)
    (<t13> ^name |13|)
    (<t14> ^name |14|)
    (<t15> ^name |15|)
    (<d> ^better higher
         ^binding <d16> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8> <d9> <d10> <d11>
                 <d12> <d13> <d14> <d15>)
    (<d1> ^cell <c11> ^tile <t1>)
    (<d2> ^cell <c12> ^tile <t2>)
    (<d3> ^cell <c13> ^tile <t3>)
    (<d4> ^cell <c14> ^tile <t4>)
    (<d5> ^cell <c21> ^tile <t5>)
    (<d6> ^cell <c22> ^tile <t6>)
    (<d7> ^cell <c23> ^tile <t7>)
    (<d8> ^cell <c24> ^tile <t8>)
    (<d9> ^cell <c31> ^tile <t9>)
    (<d10> ^cell <c32> ^tile <t10>)
    (<d11> ^cell <c33> ^tile <t11>)
    (<d12> ^cell <c34> ^tile <t12>)
    (<d13> ^cell <c41> ^tile <t13>)
    (<d14> ^cell <c42> ^tile <t14>)
    (<d15> ^cell <c43> ^tile <t15>)
    (<d16> ^cell <c44> ^tile <t0>)}
    ## A numeric evaluation function,
    ## based on changes by operators, is used
    ## to evaluate state.
sp {eight*elaborate*state*evaluation*positive*one
    (state <s> ^desired.binding <b2>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^binding <b1>)
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^cell <c1> ^tile <v1>)
-->
    (<s> ^numeric-value 1)}
    ## 0 points for not moving tile in or out of its desired cell
    #
sp {eight*elaborate*state*evaluation*neutral*zero
    (state <s> ^desired <d>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^blank-cell <c0>
               ^binding <b1> { <> <b1> <b2> } { <> <b1> <> <b2> <b3> })
    (<d> ^binding <b4> { <> <b4> <b5> })
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^tile <v2>)
    (<b3> ^tile <v3>)
    (<b4> ^cell <c1> ^tile { <> <v1> <v2> })
    (<b5> ^cell <c0> ^tile { <> <v1> <v3> })
-->
    (<s> ^numeric-value 0)}
    ## -1 points for moving tile out of its desired cell
    #
sp {eight*elaborate*state*evaluation*negative*one
    (state <s> ^desired.binding <b2>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^binding <b1>
               ^blank-cell <c0>)
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^cell <c0> ^tile <v1>)
-->
    (<s> ^numeric-value -1)}
    ## Each state contains nine bindings.
    ## The bindings connect together a cell, one of the nine positions on
    ## the board and a tile, one of the movable pieces.
    ## The cells have pointers, ^cell, to each of their adjacent cells.
    ## The state also has a pointer to the blank-cell and the cell
    ## that the last moved tile is in -- this improves efficiency and
    ## simplify computations that depend on the previous operator.
    ## Each operator contains a pointer to the cell with the blank
    ## and the cell with the tile to be moved.
    ## Define the initial state and the desired state:
    ## each state is a set of bindings#
    ## each binding points to a cell and a tile#
    ## each cell points to its neighboring cells.
sp {fifteen-puzzle*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-fifteen-puzzle)}
sp {eight*create*state*initial-and-desired-states
    (state <s> ^operator.name initialize-fifteen-puzzle)
-->
    (<s> ^name fifteen-puzzle
         ^desired <d>
         ^blank-cell <c44> ^tile-cell nil
         ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8> <bb9> <bb10> <bb11> <bb12> <bb13> <bb14> <bb15>)
    (<bb0>  ^cell  <c11> ^tile  <t2>)
    (<bb1>  ^cell  <c12> ^tile  <t1>)
    (<bb2>  ^cell  <c13> ^tile  <t7>)
    (<bb3>  ^cell  <c14> ^tile  <t8>)
    (<bb4>  ^cell  <c21> ^tile  <t6>)
    (<bb5>  ^cell  <c22> ^tile  <t15>)
    (<bb6>  ^cell  <c23> ^tile  <t3>)
    (<bb7>  ^cell  <c24> ^tile  <t4>)
    (<bb8>  ^cell  <c31> ^tile  <t5>)
    (<bb9>  ^cell  <c32> ^tile  <t9>)
    (<bb10> ^cell  <c33> ^tile <t10>)
    (<bb11> ^cell  <c34> ^tile <t11>)
    (<bb12> ^cell  <c41> ^tile <t12>)
    (<bb13> ^cell  <c42> ^tile <t13>)
    (<bb14> ^cell  <c43> ^tile <t14>)
    (<bb15> ^cell  <c44> ^tile <t0>)
    (<c11> ^name c11 ^cell <c12> ^cell <c21>)
    (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
    (<c13> ^name c13 ^cell <c12> ^cell <c23> ^cell <c14>)
    (<c14> ^name c14 ^cell <c13> ^cell <c24>)
    (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
    (<c22> ^name c22 ^cell <c21> ^cell <c12> ^cell <c23> ^cell <c32>)
    (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13> ^cell <c24>)
    (<c24> ^name c24 ^cell <c14> ^cell <c23> ^cell <c34>)
    (<c31> ^name c31 ^cell <c32> ^cell <c21> ^cell <c41>)
    (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33> ^cell <c42>)
    (<c33> ^name c33 ^cell <c32> ^cell <c23> ^cell <c43>)
    (<c34> ^name c34 ^cell <c33> ^cell <c24> ^cell <c44>)
    (<c41> ^name c41 ^cell <c31> ^cell <c42>)
    (<c42> ^name c42 ^cell <c41> ^cell <c32> ^cell <c43>)
    (<c43> ^name c43 ^cell <c42> ^cell <c33> ^cell <c44>)
    (<c44> ^name c44 ^cell <c43> ^cell <c34>)
    (<t0> ^name |0 |)
    (<t1> ^name |1 |)
    (<t2> ^name |2 |)
    (<t3> ^name |3 |)
    (<t4> ^name |4 |)
    (<t5> ^name |5 |)
    (<t6> ^name |6 |)
    (<t7> ^name |7 |)
    (<t8> ^name |8 |)
    (<t9> ^name |9 |)
    (<t10> ^name |10|)
    (<t11> ^name |11|)
    (<t12> ^name |12|)
    (<t13> ^name |13|)
    (<t14> ^name |14|)
    (<t15> ^name |15|)
    (<d> ^better higher
         ^binding <d16> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8> <d9> <d10> <d11>
                 <d12> <d13> <d14> <d15>)
    (<d1> ^cell <c11> ^tile <t1>)
    (<d2> ^cell <c12> ^tile <t2>)
    (<d3> ^cell <c13> ^tile <t3>)
    (<d4> ^cell <c14> ^tile <t4>)
    (<d5> ^cell <c21> ^tile <t5>)
    (<d6> ^cell <c22> ^tile <t6>)
    (<d7> ^cell <c23> ^tile <t7>)
    (<d8> ^cell <c24> ^tile <t8>)
    (<d9> ^cell <c31> ^tile <t9>)
    (<d10> ^cell <c32> ^tile <t10>)
    (<d11> ^cell <c33> ^tile <t11>)
    (<d12> ^cell <c34> ^tile <t12>)
    (<d13> ^cell <c41> ^tile <t13>)
    (<d14> ^cell <c42> ^tile <t14>)
    (<d15> ^cell <c43> ^tile <t15>)
    (<d16> ^cell <c44> ^tile <t0>)}
sp {eight*create*operator*move-tile
    (state <s> ^name fifteen-puzzle
               ^blank-cell <c1>)
    (<c1> ^cell <c2>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-tile
         ^tile-cell <c2>
         ^blank-cell <c1>)}
sp {eight*apply*operator*move-tile
    (state <s> ^operator <o>
               ^binding <b1> { <> <b1> <b2>}
               ^blank-cell <c1>)
    (<o> ^name move-tile
         ^tile-cell <c2>
         ^blank-cell <c1>)
    (<b1> ^tile <t1> ^cell <c1>)
    (<b2> ^tile <t2> ^cell <c2>)
-->
    (<s> ^blank-cell <c1> - <c2>)
    (<b1> ^tile <t1> - <t2>)
    (<b2> ^tile <t2> - <t1>)}
sp {eight*apply*operator*remove-tile-cell
    (state <s> ^operator <o>
               ^tile-cell <last-move>)
    (<o> ^name move-tile
         ^blank-cell <> <last-move>)
-->
    (<s> ^tile-cell <last-move> -)}
sp {eight*apply*operator*add-tile-cell
    (state <s> ^operator <o>
               ^blank-cell <c1>)
    (<o> ^name move-tile
         ^blank-cell <c1>)
-->
    (<s> ^tile-cell <c1>)}
chunk always
multi-attributes binding 10
multi-attributes operator 4
sp {eight*elaborate*problem-space
    (state <s> ^name eight-puzzle)
-->
    (<s> ^problem-space <p>)
    (<p> ^name eight-puzzle
         ^default-state-copy yes
         ^default-operator-copy no
         ^one-level-attributes blank-cell
         ^two-level-attributes binding)}
sp {eight*operator*move-tile*inverse*reject
   "Reject the operator that was applied to create this state."
    (state <s> ^problem-space.name eight-puzzle
               ^operator <o> +
               ^tile-cell <tc>)
    (<o> ^tile-cell <tc>)
-->
    (<s> ^operator <o> - )}
    ## Want this to fire whenever an op is installed or
    ## whenever op is applied (bindings change) but NOT both.
    ## Try requiring that operator be finished.
    #
sp {eight*monitor*state
    (state <s> ^binding <x11> <x12> <x13>
                       <x21> <x22> <x23>
                       <x31> <x32> <x33>)
    (<x11> ^cell.name c11 ^tile <o11>)
    (<o11> ^name <v11>)
    (<x12> ^cell.name c12 ^tile <o12>)
    (<o12> ^name <v12>)
    (<x13> ^cell.name c13 ^tile <o13>)
    (<o13> ^name <v13>)
    (<x21> ^cell.name c21 ^tile <o21>)
    (<o21> ^name <v21>)
    (<x22> ^cell.name c22 ^tile <o22>)
    (<o22> ^name <v22>)
    (<x23> ^cell.name c23 ^tile <o23>)
    (<o23> ^name <v23>)
    (<x31> ^cell.name c31 ^tile <o31>)
    (<o31> ^name <v31>)
    (<x32> ^cell.name c32 ^tile <o32>)
    (<o32> ^name <v32>)
    (<x33> ^cell.name c33 ^tile <o33>)
    (<o33> ^name <v33>)
-->
    (write (crlf)  |      -------------|  | | (crlf) | | )
    (write |     \||  | | <v11>  | | |\||  | | <v21>  | | |\||  | | <v31>  | | |\||  | | (crlf) | | )
    (write |     \|---\|---\|---\||  | | (crlf) | | )
    (write |     \||  | | <v12>  | | |\||  | | <v22>  | | |\||  | | <v32>  | | |\||  | | (crlf) | | )
    (write |     \|---\|---\|---\||  | | (crlf) | | )
    (write |     \||  | | <v13>  | | |\||  | | <v23>  | | |\||  | | <v33>  | | |\||  | | (crlf) | | )
    (write |     -------------|  | | (crlf) | | )}
sp {eight*detect*state*success
    (state <s> ^problem-space.name eight-puzzle
               ^desired <d>
               ^binding <x11> <x12> <x13>
                       <x21> <x22> <x23>
                       <x31> <x32> <x33>)
    (<x11> ^cell.name c11 ^tile <o11>)
    (<x12> ^cell.name c12 ^tile <o12>)
    (<x13> ^cell.name c13 ^tile <o13>)
    (<x21> ^cell.name c21 ^tile <o21>)
    (<x22> ^cell.name c22 ^tile <o22>)
    (<x23> ^cell.name c23 ^tile <o23>)
    (<x31> ^cell.name c31 ^tile <o31>)
    (<x32> ^cell.name c32 ^tile <o32>)
    (<x33> ^cell.name c33 ^tile <o33>)
    (<d> ^binding <d11> <d12> <d13>
                 <d21> <d22> <d23>
                 <d31> <d32> <d33>)
    (<d11> ^cell.name c11 ^tile <o11>)
    (<d12> ^cell.name c12 ^tile <o12>)
    (<d13> ^cell.name c13 ^tile <o13>)
    (<d21> ^cell.name c21 ^tile <o21>)
    (<d22> ^cell.name c22 ^tile <o22>)
    (<d23> ^cell.name c23 ^tile <o23>)
    (<d31> ^cell.name c31 ^tile <o31>)
    (<d32> ^cell.name c32 ^tile <o32>)
    (<d33> ^cell.name c33 ^tile <o33>)
-->
    (<s> ^success <d>)}
    ## Define the initial state and the desired state:
    ## each state is a set of bindings#
    ## each binding points to a cell and a tile#
    ## each cell points to its neighboring cells.
sp {eight-puzzle*propose*initialize
    (state <s> ^name eight-puzzle
              -^blank-cell)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize)}
sp {eight*create*state*initial-and-desired-states
    (state <s> ^operator.name initialize
               ^desired <d>)
-->
    (<s> ^blank-cell <c23>
         ^tile-cell nil
         ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8>)
    (<bb0> ^cell <c11> ^tile <t2>)
    (<bb1> ^cell <c12> ^tile <t1>)
    (<bb2> ^cell <c13> ^tile <t7>)
    (<bb3> ^cell <c21> ^tile <t8>)
    (<bb4> ^cell <c22> ^tile <t6>)
    (<bb5> ^cell <c23> ^tile <t0>)
    (<bb6> ^cell <c31> ^tile <t3>)
    (<bb7> ^cell <c32> ^tile <t4>)
    (<bb8> ^cell <c33> ^tile <t5>)
    (<c11> ^name c11 ^cell <c12> ^cell <c21>)
    (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
    (<c13> ^name c13 ^cell <c12> ^cell <c23>)
    (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
    (<c22> ^name c22 ^cell <c21> ^cell <c12>
           ^cell <c23> ^cell <c32>)
    (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13>)
    (<c31> ^name c31 ^cell <c32> ^cell <c21>)
    (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33>)
    (<c33> ^name c33 ^cell <c32> ^cell <c23>)
    (<t0> ^name 0)
    (<t1> ^name 1)
    (<t2> ^name 2)
    (<t3> ^name 3)
    (<t4> ^name 4)
    (<t5> ^name 5)
    (<t6> ^name 6)
    (<t7> ^name 7)
    (<t8> ^name 8)
    (<d> ^better higher
         ^binding <d0> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8>)
    (<d1> ^cell <c11> ^tile <t1>)
    (<d2> ^cell <c12> ^tile <t8>)
    (<d3> ^cell <c13> ^tile <t7>)
    (<d8> ^cell <c21> ^tile <t2>)
    (<d0> ^cell <c22> ^tile <t0>)
    (<d4> ^cell <c23> ^tile <t6>)
    (<d7> ^cell <c31> ^tile <t3>)
    (<d6> ^cell <c32> ^tile <t4>)
    (<d5> ^cell <c33> ^tile <t5>)}
    ## A numeric evaluation function,
    ## based on changes by operators, is used
    ## to evaluate state.
sp {eight*elaborate*state*evaluation*positive*one
    (state <s> ^desired.binding <b2>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^binding <b1>)
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^cell <c1> ^tile <v1>)
-->
    (<s> ^numeric-value 1)}
    ## 0 points for not moving tile in or out of its desired cell
    #
sp {eight*elaborate*state*evaluation*neutral*zero
    (state <s> ^desired <d>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^blank-cell <c0>
               ^binding <b1> { <> <b1> <b2> } { <> <b1> <> <b2> <b3> })
    (<d> ^binding <b4> { <> <b4> <b5> })
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^tile <v2>)
    (<b3> ^tile <v3>)
    (<b4> ^cell <c1> ^tile { <> <v1> <v2> })
    (<b5> ^cell <c0> ^tile { <> <v1> <v3> })
-->
    (<s> ^numeric-value 0)}
    ## -1 points for moving tile out of its desired cell
    #
sp {eight*elaborate*state*evaluation*negative*one
    (state <s> ^desired.binding <b2>
               ^tried-tied-operator
               ^tile-cell <c1>
               ^binding <b1>
               ^blank-cell <c0>)
    (<b1> ^cell <c1> ^tile <v1>)
    (<b2> ^cell <c0> ^tile <v1>)
-->
    (<s> ^numeric-value -1)}
    ## Define the initial state and the desired state:
    ## each state is a set of bindings#
    ## each binding points to a cell and a tile#
    ## each cell points to its neighboring cells.
sp {eight-puzzle*propose*initialize
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-eight-puzzle)}
sp {eight*create*state*initial-and-desired-states
    (state <s> ^operator.name initialize-eight-puzzle)
-->
    (<s> ^name eight-puzzle
         ^desired <d>
         ^blank-cell <c23>
         ^tile-cell nil
         ^binding <bb0> <bb1> <bb2> <bb3> <bb4>
                 <bb5> <bb6> <bb7> <bb8>)
    (<bb0> ^cell <c11> ^tile <t2>)
    (<bb1> ^cell <c12> ^tile <t1>)
    (<bb2> ^cell <c13> ^tile <t7>)
    (<bb3> ^cell <c21> ^tile <t8>)
    (<bb4> ^cell <c22> ^tile <t6>)
    (<bb5> ^cell <c23> ^tile <t0>)
    (<bb6> ^cell <c31> ^tile <t3>)
    (<bb7> ^cell <c32> ^tile <t4>)
    (<bb8> ^cell <c33> ^tile <t5>)
    (<c11> ^name c11 ^cell <c12> ^cell <c21>)
    (<c12> ^name c12 ^cell <c11> ^cell <c13> ^cell <c22>)
    (<c13> ^name c13 ^cell <c12> ^cell <c23>)
    (<c21> ^name c21 ^cell <c11> ^cell <c31> ^cell <c22>)
    (<c22> ^name c22 ^cell <c21> ^cell <c12>
           ^cell <c23> ^cell <c32>)
    (<c23> ^name c23 ^cell <c22> ^cell <c33> ^cell <c13>)
    (<c31> ^name c31 ^cell <c32> ^cell <c21>)
    (<c32> ^name c32 ^cell <c31> ^cell <c22> ^cell <c33>)
    (<c33> ^name c33 ^cell <c32> ^cell <c23>)
    (<t0> ^name 0)
    (<t1> ^name 1)
    (<t2> ^name 2)
    (<t3> ^name 3)
    (<t4> ^name 4)
    (<t5> ^name 5)
    (<t6> ^name 6)
    (<t7> ^name 7)
    (<t8> ^name 8)
    (<d> ^better higher
         ^binding <d0> <d1> <d2> <d3> <d4> <d5>
                 <d6> <d7> <d8>)
    (<d1> ^cell <c11> ^tile <t1>)
    (<d2> ^cell <c12> ^tile <t8>)
    (<d3> ^cell <c13> ^tile <t7>)
    (<d8> ^cell <c21> ^tile <t2>)
    (<d0> ^cell <c22> ^tile <t0>)
    (<d4> ^cell <c23> ^tile <t6>)
    (<d7> ^cell <c31> ^tile <t3>)
    (<d6> ^cell <c32> ^tile <t4>)
    (<d5> ^cell <c33> ^tile <t5>)}
    ## Each state contains nine bindings.
    ## The bindings connect together a cell, one of the nine positions on
    ## the board and a tile, one of the movable pieces.
    ## The cells have pointers, ^cell, to each of their adjacent cells.
    ## The state also has a pointer to the blank-cell and the cell
    ## that the last moved tile is in -- this improves efficiency and
    ## simplify computations that depend on the previous operator.
    ## Each operator contains a pointer to the cell with the blank
    ## and the cell with the tile to be moved.
sp {eight*create*operator*move-tile
    (state <s> ^name eight-puzzle
               ^blank-cell <c1>)
    (<c1> ^cell <c2>)
-->
    (<s> ^operator <o>)
    (<o> ^name move-tile
         ^tile-cell <c2>
         ^blank-cell <c1>)}
sp {eight*apply*operator*move-tile
    (state <s> ^operator <o>
               ^binding <b1> { <> <b1> <b2>}
               ^blank-cell <c1>)
    (<o> ^name move-tile
         ^tile-cell <c2>
         ^blank-cell <c1>)
    (<b1> ^tile <t1> ^cell <c1>)
    (<b2> ^tile <t2> ^cell <c2>)
-->
    (<s> ^blank-cell <c1> - <c2>)
    (<b1> ^tile <t1> - <t2>)
    (<b2> ^tile <t2> - <t1>)}
sp {eight*apply*operator*remove-tile-cell
    (state <s> ^operator <o>
               ^tile-cell <last-move>)
    (<o> ^name move-tile
         ^blank-cell <> <last-move>)
-->
    (<s> ^tile-cell <last-move> -)}
sp {eight*apply*operator*add-tile-cell
    (state <s> ^operator <o>
               ^blank-cell <c1>)
    (<o> ^name move-tile
         ^blank-cell <c1>)
-->
    (<s> ^tile-cell <c1>)}
chunk always
multi-attributes binding 10
multi-attributes operator 4
sp {elaborate*top-state*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)
}
sp {elaborate*state*name
    (state <s> ^superstate.operator.name <name>)
-->
    (<s> ^name <name>)
}
sp {elaborate*state*top-state
    (state <s> ^superstate.top-state <ts>)
-->
    (<s> ^top-state <ts>)
}
sp {reward
    (state <s> ^reward-link <rl>)
-->
    (<rl> ^reward.value 100)
}
sp {value*function
   :template
    (state <s> ^operator <op> +)
    (<op> ^name <op-name>
          ^rl <num>)
-->
    (<s> ^operator <op> = 0)
}
sp {one*propose*one-two
    (state <s> ^name one
               ^phase two)
-->
    (<s> ^operator <op> +)
    (<op> ^name one-two
          ^rl alpha)
}
sp {apply*one-two
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name one-two)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^case one -
          ^case two)
}
sp {one*propose*one-one
    (state <s> ^name one
              -^phase)
-->
    (<s> ^operator <op> +)
    (<op> ^name one-one
          ^rl alpha)
}
sp {apply*one-one
    (state <s> ^operator <op>)
    (<op> ^name one-one)
-->
    (<s> ^phase two)
}
sp {propose*initialize-rl-unit
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-rl-unit
         ^rl alpha)
}
sp {apply*initialize-rl-unit
    (state <s> ^operator <op>)
    (<op> ^name initialize-rl-unit)
-->
    (<s> ^name rl-unit
         ^case one
         ^max-cases five)
}
sp {rl-unit*propose*two
    (state <s> ^name rl-unit
               ^case two)
-->
    (<s> ^operator <op> + =)
    (<op> ^name two)
}
sp {rl-unit*propose*four
    (state <s> ^name rl-unit
               ^case four)
-->
    (<s> ^operator <op> + =)
    (<op> ^name four)
}
sp {rl-unit*propose*done
    (state <s> ^name rl-unit
               ^max-cases <max>
               ^case <max>)
-->
    (<s> ^operator <op> + =)
    (<op> ^name done)
}
sp {apply*done
    (state <s> ^operator <op>)
    (<op> ^name done)
-->
    (halt)
}
sp {two*propose*two-two
    (state <s> ^name two
               ^phase two)
-->
    (<s> ^operator <op> +)
    (<op> ^name two-two)
}
sp {apply*two-two
    (state <s> ^operator <op>)
    (<op> ^name two-two)
-->
    (<s> ^phase two -
         ^phase three)
}
sp {two*propose*two-one
    (state <s> ^name two
              -^phase)
-->
    (<s> ^operator <op> +)
    (<op> ^name two-one
          ^rl alpha)
}
sp {apply*two-one
    (state <s> ^operator <op>)
    (<op> ^name two-one)
-->
    (<s> ^phase two)
}
sp {two*propose*two-three
    (state <s> ^name two
               ^phase three)
-->
    (<s> ^operator <op> +)
    (<op> ^name two-three
          ^rl alpha)
}
sp {apply*two-three
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name two-three)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^case two -
          ^case three)
}
sp {four*propose*four-two
    (state <s> ^name four
               ^phase two)
-->
    (<s> ^operator <op> + =)
    (<op> ^name four-two)
}
sp {apply*four-two
    (state <s> ^operator <op>)
    (<op> ^name four-two)
-->
    (<s> ^phase two -
         ^phase three)
}
sp {four*propose*four-three
    (state <s> ^name four
               ^phase three)
-->
    (<s> ^operator <op> + =)
    (<op> ^name four-three)
}
sp {four*propose*four-one
    (state <s> ^name four
              -^phase)
-->
    (<s> ^operator <op> +)
    (<op> ^name four-one
          ^rl alpha)
}
sp {apply*four-one
    (state <s> ^operator <op>)
    (<op> ^name four-one)
-->
    (<s> ^phase two)
}
sp {four-three*propose*four-three-one
    (state <s> ^name four-three)
-->
    (<s> ^operator <op> + =)
    (<op> ^name four-three-one)
}
sp {apply*four-three-one
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name four-three-one)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^phase three -
          ^phase four)
}
sp {four*propose*four-four
    (state <s> ^name four
               ^phase four)
-->
    (<s> ^operator <op> +)
    (<op> ^name four-four
          ^rl alpha)
}
sp {apply*four-four
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name four-four)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^case four -
          ^case five)
}
sp {rl-unit*propose*three
    (state <s> ^name rl-unit
               ^case three)
-->
    (<s> ^operator <op> +)
    (<op> ^name three)
}
sp {three*propose*three-one
    (state <s> ^name three
              -^phase)
-->
    (<s> ^operator <op> + =)
    (<op> ^name three-one
          ^rl alpha)
}
sp {three-one*propose*three-one-one
    (state <s> ^name three-one)
-->
    (<s> ^operator <op> + =)
    (<op> ^name three-one-one)
}
sp {apply*three-one-one
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name three-one-one)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^phase two)
}
sp {three*propose*three-two
    (state <s> ^name three
               ^phase two)
-->
    (<s> ^operator <op> + =)
    (<op> ^name three-two
          ^rl alpha)
}
sp {apply*three-two
    (state <s> ^operator <op>
               ^superstate <ss>)
    (<op> ^name three-two)
    (<ss> ^operator <ss-op>)
-->
    (<ss> ^case three -
          ^case four)
}
sp {rl-unit*propose*one
    (state <s> ^name rl-unit
               ^case one)
-->
    (<s> ^operator <op> + =)
    (<op> ^name one)
}
rl --set learning on
rl --set learning-rate 0.1
rl --set discount-rate 0.5
watch --rl
sp {elaborate*top-state*top-state
    (state <s> ^superstate nil)
-->
    (<s> ^top-state <s>)
}
sp {elaborate*state*name
    (state <s> ^superstate <ss>)
    (<ss> ^operator <op>)
    (<op> ^name <name>)
-->
    (<s> ^name <name>)
}
sp {elaborate*state*top-state
    (state <s> ^superstate <ss>)
    (<ss> ^top-state <ts>)
-->
    (<s> ^top-state <ts>)
}
sp {elaborate*reward
    (state <s> ^name left-right
               ^reward-link <r>
               ^location <d-name>
               ^direction <dir>)
    (<dir> ^name <d-name> ^reward <d-reward>)
-->
    (<r> ^reward <rr>)
    (<rr> ^value <d-reward>)
}
sp {elaborate*done
    (state <s> ^name left-right
               ^location {<> start})
-->
    (halt)
}
sp {propose*initialize-left-right
    (state <s> ^superstate nil
              -^name)
-->
    (<s> ^operator <o> +)
    (<o> ^name initialize-left-right)
}
sp {apply*initialize-left-right
    (state <s> ^operator <op>)
    (<op> ^name initialize-left-right)
-->
    (<s> ^name left-right
         ^direction <d1> <d2>
         ^location start)
    (<d1> ^name left ^reward -1)
    (<d2> ^name right ^reward 1)
}
sp {left-right*propose*move
    (state <s> ^name left-right
               ^direction <d>
               ^location start)
    (<d> ^name <dir>)
-->
    (<s> ^operator <op> +)
    (<op> ^name move
          ^dir <dir>)
}
sp {left-right*rl*left
    (state <s> ^name left-right
               ^operator <op> +)
    (<op> ^name move
          ^dir left)
-->
    (<s> ^operator <op> = 0)
}
sp {left-right*rl*right
    (state <s> ^name left-right
               ^operator <op> +)
    (<op> ^name move
          ^dir right)
-->
    (<s> ^operator <op> = 0)
}
sp {apply*move
    (state <s> ^operator <op>
               ^location start)
    (<op> ^name move
          ^dir <dir>)
-->
    (<s> ^location start - <dir>)
    (write (crlf) |Moved: | <dir>)
}
rl --set learning on

# the following 3 commands test the fix for issues 95 and 102
sp {literals_test
    (state <s> ^superstate nil) # }}}}
-->
    (<s> ^literal |##}}}}}{{##|)}

w 0 # blah blah blah

# should be empty
